import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "module";
/******/ var __webpack_modules__ = ({

/***/ 7981:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHash = getHash;
exports.createCurve = createCurve;
/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const weierstrass_ts_1 = __nccwpck_require__(7760);
/** connects noble-curves to noble-hashes */
function getHash(hash) {
    return { hash };
}
/** @deprecated use new `weierstrass()` and `ecdsa()` methods */
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash });
    return { ...create(defHash), create };
}
//# sourceMappingURL=_shortw_utils.js.map

/***/ }),

/***/ 9328:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wNAF = void 0;
exports.negateCt = negateCt;
exports.normalizeZ = normalizeZ;
exports.mulEndoUnsafe = mulEndoUnsafe;
exports.pippenger = pippenger;
exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
exports.validateBasic = validateBasic;
exports._createCurveFields = _createCurveFields;
/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __nccwpck_require__(8403);
const modular_ts_1 = __nccwpck_require__(6557);
const _0n = BigInt(0);
const _1n = BigInt(1);
function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
/**
 * Takes a bunch of Projective Points but executes only one
 * inversion on all of them. Inversion is very slow operation,
 * so this improves performance massively.
 * Optimization: converts a list of projective points to a list of identical points with Z=1.
 */
function normalizeZ(c, points) {
    const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
        throw new Error('array expected');
    points.forEach((p, i) => {
        if (!(p instanceof c))
            throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
        throw new Error('array of scalars expected');
    scalars.forEach((s, i) => {
        if (!field.isValid(s))
            throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    // To disable precomputes:
    // return 1;
    return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
    if (n !== _0n)
        throw new Error('invalid wNAF');
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Table generation takes **30MB of ram and 10ms on high-end CPU**,
 * but may take much longer on slow devices. Actual generation will happen on
 * first call of `multiply()`. By default, `BASE` point is precomputed.
 *
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */
class wNAF {
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n) {
            if (n & _1n)
                p = p.add(d);
            d = d.double();
            n >>= _1n;
        }
        return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
     * - ùëä is the window size
     * - ùëõ is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            // i=1, bc we skip 0
            for (let i = 1; i < windowSize; i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
        // Scalar should be smaller than field order
        if (!this.Fn.isValid(n))
            throw new Error('invalid scalar');
        // Accumulators
        let p = this.ZERO;
        let f = this.BASE;
        // This code was first written with assumption that 'f' and 'p' will never be infinity point:
        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
        // there is negate now: it is possible that negated element from low value
        // would be the same as high element, which will create carry into next window.
        // It's not obvious how this can fail, but still worth investigating later.
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // bits are 0: add garbage to fake point
                // Important part for const-time getPublicKey: add random "noise" point to f.
                f = f.add(negateCt(isNegF, precomputes[offsetF]));
            }
            else {
                // bits are 1: add to result point
                p = p.add(negateCt(isNeg, precomputes[offset]));
            }
        }
        assert0(n);
        // Return both real and fake points: JIT won't eliminate f.
        // At this point there is a way to F be infinity-point even if p is not,
        // which makes it less const-time: around 1 bigint multiply.
        return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            if (n === _0n)
                break; // Early-exit, skip 0 value
            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // Window bits are 0: skip processing.
                // Move to next window.
                continue;
            }
            else {
                const item = precomputes[offset];
                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
            }
        }
        assert0(n);
        return acc;
    }
    getPrecomputes(W, point, transform) {
        // Calculate precomputes on a first run, reuse them after
        let comp = pointPrecomputes.get(point);
        if (!comp) {
            comp = this.precomputeWindow(point, W);
            if (W !== 1) {
                // Doing transform outside of if brings 15% perf hit
                if (typeof transform === 'function')
                    comp = transform(comp);
                pointPrecomputes.set(point, comp);
            }
        }
        return comp;
    }
    cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
    }
    hasCache(elm) {
        return getW(elm) !== 1;
    }
}
exports.wNAF = wNAF;
/**
 * Endomorphism-specific multiplication for Koblitz curves.
 * Cost: 128 dbl, 0-256 adds.
 */
function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
            p1 = p1.add(acc);
        if (k2 & _1n)
            p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
    }
    return { p1, p2 };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka secret keys / bigints)
 */
function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
        throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12)
        windowSize = wbits - 3;
    else if (wbits > 4)
        windowSize = wbits - 2;
    else if (wbits > 0)
        windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits = Number((scalar >> BigInt(i)) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
            for (let j = 0; j < windowSize; j++)
                sum = sum.double();
    }
    return sum;
}
/**
 * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @returns function which multiplies points with scaars
 */
function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    /**
     * Performance Analysis of Window-based Precomputation
     *
     * Base Case (256-bit scalar, 8-bit window):
     * - Standard precomputation requires:
     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops
     *   - Plus 255 summary additions = 8,191 total ops
     *   Note: Summary additions can be optimized via accumulator
     *
     * Chunked Precomputation Analysis:
     * - Using 32 chunks requires:
     *   - 255 additions per chunk
     *   - 256 doublings
     *   - Total: (255 √ó 32) + 256 = 8,416 ops
     *
     * Memory Usage Comparison:
     * Window Size | Standard Points | Chunked Points
     * ------------|-----------------|---------------
     *     4-bit   |     520         |      15
     *     8-bit   |    4,224        |     255
     *    10-bit   |   13,824        |   1,023
     *    16-bit   |  557,056        |  65,535
     *
     * Key Advantages:
     * 1. Enables larger window sizes due to reduced memory overhead
     * 2. More efficient for smaller scalar counts:
     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops
     *    - ~2x faster than standard 8,191 ops
     *
     * Limitations:
     * - Not suitable for plain precomputes (requires 256 constant doublings)
     * - Performance degrades with larger scalar counts:
     *   - Optimal for ~256 scalars
     *   - Less efficient for 4096+ scalars (Pippenger preferred)
     */
    validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1; // table size (without zero)
    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
        }
        return res;
    });
    return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
            throw new Error('array of scalars must be smaller than array of points');
        let res = zero;
        for (let i = 0; i < chunks; i++) {
            // No need to double if accumulator is still zero.
            if (res !== zero)
                for (let j = 0; j < windowSize; j++)
                    res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
                const n = scalars[j];
                const curr = Number((n >> shiftBy) & MASK);
                if (!curr)
                    continue; // skip zero scalars chunks
                res = res.add(tables[j][curr - 1]);
            }
        }
        return res;
    };
}
// TODO: remove
/** @deprecated */
function validateBasic(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
function createField(order, field, isLE) {
    if (field) {
        if (field.ORDER !== order)
            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');
        (0, modular_ts_1.validateField)(field);
        return field;
    }
    else {
        return (0, modular_ts_1.Field)(order, { isLE });
    }
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === undefined)
        FpFnLE = type === 'edwards';
    if (!CURVE || typeof CURVE !== 'object')
        throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ['p', 'n', 'h']) {
        const val = CURVE[p];
        if (!(typeof val === 'bigint' && val > _0n))
            throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = type === 'weierstrass' ? 'b' : 'd';
    const params = ['Gx', 'Gy', 'a', _b];
    for (const p of params) {
        // @ts-ignore
        if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp, Fn };
}
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ 8753:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrimeEdwardsPoint = void 0;
exports.edwards = edwards;
exports.eddsa = eddsa;
exports.twistedEdwards = twistedEdwards;
/**
 * Twisted Edwards curve. The formula is: ax¬≤ + y¬≤ = 1 + dx¬≤y¬≤.
 * For design rationale of types / exports, see weierstrass module documentation.
 * Untwisted Edwards curves exist, but they aren't used in real-world protocols.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __nccwpck_require__(8403);
const curve_ts_1 = __nccwpck_require__(9328);
const modular_ts_1 = __nccwpck_require__(6557);
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
function isEdValidXY(Fp, CURVE, x, y) {
    const x2 = Fp.sqr(x);
    const y2 = Fp.sqr(y);
    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
    return Fp.eql(left, right);
}
function edwards(params, extraOpts = {}) {
    const validated = (0, curve_ts_1._createCurveFields)('edwards', params, extraOpts, extraOpts.FpFnLE);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor } = CURVE;
    (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: 'function' });
    // Important:
    // There are some places where Fp.BYTES is used instead of nByteLength.
    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.
    // TODO: test and find curves which behave otherwise.
    const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);
    const modP = (n) => Fp.create(n); // Function overrides
    // sqrt(u/v)
    const uvRatio = extraOpts.uvRatio ||
        ((u, v) => {
            try {
                return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
            }
            catch (e) {
                return { isValid: false, value: _0n };
            }
        });
    // Validate whether the passed curve params are valid.
    // equation ax¬≤ + y¬≤ = 1 + dx¬≤y¬≤ should work for generator point.
    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    /**
     * Asserts coordinate is valid: 0 <= n < MASK.
     * Coordinates >= Fp.ORDER are allowed for zip215.
     */
    function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)('coordinate ' + title, n, min, MASK);
        return n;
    }
    function aextpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ExtendedPoint expected');
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        const is0 = p.is0();
        if (iz == null)
            iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily
        const x = modP(X * iz);
        const y = modP(Y * iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
            return { x: _0n, y: _1n };
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return { x, y };
    });
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0())
            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?
        // Equation in affine coordinates: ax¬≤ + y¬≤ = 1 + dx¬≤y¬≤
        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX¬≤ + Y¬≤)Z¬≤ = Z‚Å¥ + dX¬≤Y¬≤
        const { X, Y, Z, T } = p;
        const X2 = modP(X * X); // X¬≤
        const Y2 = modP(Y * Y); // Y¬≤
        const Z2 = modP(Z * Z); // Z¬≤
        const Z4 = modP(Z2 * Z2); // Z‚Å¥
        const aX2 = modP(X2 * a); // aX¬≤
        const left = modP(Z2 * modP(aX2 + Y2)); // (aX¬≤ + Y¬≤)Z¬≤
        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z‚Å¥ + dX¬≤Y¬≤
        if (left !== right)
            throw new Error('bad point: equation left != right (1)');
        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
            throw new Error('bad point: equation left != right (2)');
        return true;
    });
    // Extended Point works in extended coordinates: (X, Y, Z, T) ‚àã (x=X/Z, y=Y/Z, T=xy).
    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
    class Point {
        constructor(X, Y, Z, T) {
            this.X = acoord('x', X);
            this.Y = acoord('y', Y);
            this.Z = acoord('z', Z, true);
            this.T = acoord('t', T);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        static fromAffine(p) {
            if (p instanceof Point)
                throw new Error('extended point not allowed');
            const { x, y } = p || {};
            acoord('x', x);
            acoord('y', y);
            return new Point(x, y, _1n, modP(x * y));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(bytes, zip215 = false) {
            const len = Fp.BYTES;
            const { a, d } = CURVE;
            bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, 'point'));
            (0, utils_ts_1._abool2)(zip215, 'zip215');
            const normed = (0, utils_ts_1.copyBytes)(bytes); // copy again, we'll manipulate it
            const lastByte = bytes[len - 1]; // select last byte
            normed[len - 1] = lastByte & ~0x80; // clear last bit
            const y = (0, utils_ts_1.bytesToNumberLE)(normed);
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // RFC8032 prohibits >= p, but ZIP215 doesn't
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            const max = zip215 ? MASK : Fp.ORDER;
            (0, utils_ts_1.aInRange)('point.y', y, _0n, max);
            // Ed25519: x¬≤ = (y¬≤-1)/(dy¬≤+1) mod p. Ed448: x¬≤ = (y¬≤-1)/(dy¬≤-1) mod p. Generic case:
            // ax¬≤+y¬≤=1+dx¬≤y¬≤ => y¬≤-1=dx¬≤y¬≤-ax¬≤ => y¬≤-1=x¬≤(dy¬≤-a) => x¬≤=(y¬≤-1)/(dy¬≤-a)
            const y2 = modP(y * y); // denominator is always non-0 mod p.
            const u = modP(y2 - _1n); // u = y¬≤ - 1
            const v = modP(d * y2 - a); // v = d y¬≤ + 1.
            let { isValid, value: x } = uvRatio(u, v); // ‚àö(u/v)
            if (!isValid)
                throw new Error('bad point: invalid y coordinate');
            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
            if (!zip215 && x === _0n && isLastByteOdd)
                // if x=0 and x_0 = 1, fail
                throw new Error('bad point: x=0 and x_0=1');
            if (isLastByteOdd !== isXOdd)
                x = modP(-x); // if x_0 != x mod 2, set x = p-x
            return Point.fromAffine({ x, y });
        }
        static fromHex(bytes, zip215 = false) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)('point', bytes), zip215);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
                this.multiply(_2n); // random number
            return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
            assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
            aextpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            // Flips point sign to a negative one (-x, y in affine coords)
            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a } = CURVE;
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const A = modP(X1 * X1); // A = X12
            const B = modP(Y1 * Y1); // B = Y12
            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
            const D = modP(a * A); // D = a*A
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
            const G = D + B; // G = D+B
            const F = G - C; // F = G-C
            const H = D - B; // H = D-B
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
            aextpoint(other);
            const { a, d } = CURVE;
            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
            const A = modP(X1 * X2); // A = X1*X2
            const B = modP(Y1 * Y2); // B = Y1*Y2
            const C = modP(T1 * d * T2); // C = T1*d*T2
            const D = modP(Z1 * Z2); // D = Z1*Z2
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
            const F = D - C; // F = D-C
            const G = D + C; // G = D+C
            const H = modP(B - a * A); // H = B-a*A
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
            // 1 <= scalar < L
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: expected 1 <= sc < curve.n');
            const { p, f } = wnaf.cached(this, scalar, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
            return (0, curve_ts_1.normalizeZ)(Point, [p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
            // 0 <= scalar < L
            if (!Fn.isValid(scalar))
                throw new Error('invalid scalar: expected 0 <= sc < curve.n');
            if (scalar === _0n)
                return Point.ZERO;
            if (this.is0() || scalar === _1n)
                return this;
            return wnaf.unsafe(this, scalar, (p) => (0, curve_ts_1.normalizeZ)(Point, p), acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return wnaf.unsafe(this, CURVE.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
            if (cofactor === _1n)
                return this;
            return this.multiplyUnsafe(cofactor);
        }
        toBytes() {
            const { x, y } = this.toAffine();
            // Fp.toBytes() allows non-canonical encoding of y (>= p).
            const bytes = Fp.toBytes(y);
            // Each y has 2 valid points: (x, y), (x,-y).
            // When compressing, it's enough to store y and use the last byte to encode sign of x
            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;
            return bytes;
        }
        toHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
            return this.X;
        }
        get ey() {
            return this.Y;
        }
        get ez() {
            return this.Z;
        }
        get et() {
            return this.T;
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        toRawBytes() {
            return this.toBytes();
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    // zero / infinity / identity point
    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
/**
 * Base class for prime-order points like Ristretto255 and Decaf448.
 * These points eliminate cofactor issues by representing equivalence classes
 * of Edwards curve points.
 */
class PrimeEdwardsPoint {
    constructor(ep) {
        this.ep = ep;
    }
    // Static methods that must be implemented by subclasses
    static fromBytes(_bytes) {
        (0, utils_ts_1.notImplemented)();
    }
    static fromHex(_hex) {
        (0, utils_ts_1.notImplemented)();
    }
    get x() {
        return this.toAffine().x;
    }
    get y() {
        return this.toAffine().y;
    }
    // Common implementations
    clearCofactor() {
        // no-op for prime-order groups
        return this;
    }
    assertValidity() {
        this.ep.assertValidity();
    }
    toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
    }
    toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
    }
    toString() {
        return this.toHex();
    }
    isTorsionFree() {
        return true;
    }
    isSmallOrder() {
        return false;
    }
    add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
    }
    subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
    }
    double() {
        return this.init(this.ep.double());
    }
    negate() {
        return this.init(this.ep.negate());
    }
    precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
        return this.toBytes();
    }
}
exports.PrimeEdwardsPoint = PrimeEdwardsPoint;
/**
 * Initializes EdDSA signatures over given Edwards curve.
 */
function eddsa(Point, cHash, eddsaOpts = {}) {
    if (typeof cHash !== 'function')
        throw new Error('"hash" function param is required');
    (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
        adjustScalarBytes: 'function',
        randomBytes: 'function',
        domain: 'function',
        prehash: 'function',
        mapToCurve: 'function',
    });
    const { prehash } = eddsaOpts;
    const { BASE, Fp, Fn } = Point;
    const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
    const domain = eddsaOpts.domain ||
        ((data, ctx, phflag) => {
            (0, utils_ts_1._abool2)(phflag, 'phflag');
            if (ctx.length || phflag)
                throw new Error('Contexts/pre-hash are not supported');
            return data;
        }); // NOOP
    // Little-endian SHA512 with modulo n
    function modN_LE(hash) {
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash)); // Not Fn.fromBytes: it has length limit
    }
    // Get the hashed private scalar per RFC8032 5.1.5
    function getPrivateScalar(key) {
        const len = lengths.secretKey;
        key = (0, utils_ts_1.ensureBytes)('private key', key, len);
        // Hash private key with curve's hash function to produce uniformingly random input
        // Check byte lengths: ensure(64, h(ensure(32, key)))
        const hashed = (0, utils_ts_1.ensureBytes)('hashed private key', cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
        const scalar = modN_LE(head); // The actual private scalar
        return { head, prefix, scalar };
    }
    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */
    function getExtendedPublicKey(secretKey) {
        const { head, prefix, scalar } = getPrivateScalar(secretKey);
        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
    }
    /** Calculates EdDSA pub key. RFC8032 5.1.5. */
    function getPublicKey(secretKey) {
        return getExtendedPublicKey(secretKey).pointBytes;
    }
    // int('LE', SHA512(dom2(F, C) || msgs)) mod N
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)('context', context), !!prehash)));
    }
    /** Signs message with privateKey. RFC8032 5.1.6 */
    function sign(msg, secretKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        if (prehash)
            msg = prehash(msg); // for ed25519ph etc.
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
        const R = BASE.multiply(r).toBytes(); // R = rG
        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L
        if (!Fn.isValid(s))
            throw new Error('sign failed: invalid s'); // 0 <= s < L
        const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
        return (0, utils_ts_1._abytes2)(rs, lengths.signature, 'result');
    }
    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
    const verifyOpts = { zip215: true };
    /**
     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
     * An extended group equation is checked.
     */
    function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = lengths.signature;
        sig = (0, utils_ts_1.ensureBytes)('signature', sig, len);
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, lengths.publicKey);
        if (zip215 !== undefined)
            (0, utils_ts_1._abool2)(zip215, 'zip215');
        if (prehash)
            msg = prehash(msg); // for ed25519ph, etc
        const mid = len / 2;
        const r = sig.subarray(0, mid);
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
        let A, R, SB;
        try {
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            A = Point.fromBytes(publicKey, zip215);
            R = Point.fromBytes(r, zip215);
            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside
        }
        catch (error) {
            return false;
        }
        if (!zip215 && A.isSmallOrder())
            return false; // zip215 allows public keys of small order
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        // Extended group equation
        // [8][S]B = [8]R + [8][k]A'
        return RkA.subtract(SB).clearCofactor().is0();
    }
    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448
    const lengths = {
        secretKey: _size,
        publicKey: _size,
        signature: 2 * _size,
        seed: _size,
    };
    function randomSecretKey(seed = randomBytes(lengths.seed)) {
        return (0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed');
    }
    function keygen(seed) {
        const secretKey = utils.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    function isValidSecretKey(key) {
        return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
    }
    function isValidPublicKey(key, zip215) {
        try {
            return !!Point.fromBytes(key, zip215);
        }
        catch (error) {
            return false;
        }
    }
    const utils = {
        getExtendedPublicKey,
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         */
        toMontgomery(publicKey) {
            const { y } = Point.fromBytes(publicKey);
            const size = lengths.publicKey;
            const is25519 = size === 32;
            if (!is25519 && size !== 57)
                throw new Error('only defined for 25519 and 448');
            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);
            return Fp.toBytes(u);
        },
        toMontgomerySecret(secretKey) {
            const size = lengths.secretKey;
            (0, utils_ts_1._abytes2)(secretKey, size);
            const hashed = cHash(secretKey.subarray(0, size));
            return adjustScalarBytes(hashed).subarray(0, size);
        },
        /** @deprecated */
        randomPrivateKey: randomSecretKey,
        /** @deprecated */
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return Object.freeze({
        keygen,
        getPublicKey,
        sign,
        verify,
        utils,
        Point,
        lengths,
    });
}
function _eddsa_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
    const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
    const eddsaOpts = {
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve,
    };
    return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa) {
    const Point = eddsa.Point;
    const legacy = Object.assign({}, eddsa, {
        ExtendedPoint: Point,
        CURVE: c,
        nBitLength: Point.Fn.BITS,
        nByteLength: Point.Fn.BYTES,
    });
    return legacy;
}
// TODO: remove. Use eddsa
function twistedEdwards(c) {
    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point = edwards(CURVE, curveOpts);
    const EDDSA = eddsa(Point, hash, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
}
//# sourceMappingURL=edwards.js.map

/***/ }),

/***/ 7281:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._DST_scalar = void 0;
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const utils_ts_1 = __nccwpck_require__(8403);
const modular_ts_1 = __nccwpck_require__(6557);
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_ts_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << (8 * length))
        throw new Error('invalid I2OSP input: ' + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
function normDST(DST) {
    if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== 'string')
        throw new Error('DST must be Uint8Array or string');
    return typeof DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
}
/**
 * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.
 * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).
 */
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
        throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
/**
 * Produces a uniformly random byte string using an extendable-output function (XOF) H.
 * 1. The collision resistance of H MUST be at least k bits.
 * 2. H MUST be an XOF that has been proved indifferentiable from
 *    a random oracle under a reasonable cryptographic assumption.
 * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).
 */
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.
 * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_ts_1._validateObject)(options, {
        p: 'bigint',
        m: 'number',
        k: 'number',
        hash: 'function',
    });
    const { p, k, m, hash, expand, DST } = options;
    if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error('expected valid hash');
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        // 6.6.3
        // Exceptional cases of iso_map are inputs that cause the denominator of
        // either rational function to evaluate to zero; such cases MUST return
        // the identity point on E.
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv); // xNum / xDen
        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)('HashToScalar-');
/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */
function createHasher(Point, mapToCurve, defaults) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    function map(num) {
        return Point.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
            return Point.ZERO; // zero will throw in assert
        P.assertValidity();
        return P;
    }
    return {
        defaults,
        hashToCurve(msg, options) {
            const opts = Object.assign({}, defaults, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
            const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
            const opts = Object.assign({}, defaults, optsDst, options);
            const u = hash_to_field(msg, 1, opts);
            const u0 = map(u[0]);
            return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
            if (!Array.isArray(scalars))
                throw new Error('expected array of bigints');
            for (const i of scalars)
                if (typeof i !== 'bigint')
                    throw new Error('expected array of bigints');
            return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
            // @ts-ignore
            const N = Point.Fn.ORDER;
            const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
            return hash_to_field(msg, 1, opts)[0][0];
        },
    };
}
//# sourceMappingURL=hash-to-curve.js.map

/***/ }),

/***/ 6557:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/**
 * Utils for modular division and fields.
 * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __nccwpck_require__(8403);
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);
// prettier-ignore
const _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
function pow(num, power, modulo) {
    return FpPow(Field(modulo), num, power);
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */
function invert(number, modulo) {
    if (number === _0n)
        throw new Error('invert: expected non-zero number');
    if (modulo <= _0n)
        throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function assertIsSquare(Fp, root, n) {
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n) / _4n;
    const root = Fp.pow(n, p1div4);
    assertIsSquare(Fp, root, n);
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    assertIsSquare(Fp, root, n);
    return root;
}
// Based on RFC9380, Kong algorithm
// prettier-ignore
function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic
    return (Fp, n) => {
        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4
        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1
        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1
        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1
        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x
        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x
        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x
        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2
        assertIsSquare(Fp, root, n);
        return root;
    };
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Initialization (precomputation).
    // Caching initialization could boost perf by 7%.
    if (P < _3n)
        throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n;
    let S = 0;
    while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000)
            throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1)
        return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
            return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1)
            throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
                return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i) ‚â° 1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while (!Fp.eql(t_tmp, Fp.ONE)) {
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M)
                    throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P ‚â° 3 (mod 4)
 * 2. P ‚â° 5 (mod 8)
 * 3. P ‚â° 9 (mod 16)
 * 4. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */
function FpSqrt(P) {
    // P ‚â° 3 (mod 4) => ‚àön = n^((P+1)/4)
    if (P % _4n === _3n)
        return sqrt3mod4;
    // P ‚â° 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n)
        return sqrt5mod8;
    // P ‚â° 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)
    if (P % _16n === _9n)
        return sqrt9mod16(P);
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'number',
        BITS: 'number',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    (0, utils_ts_1._validateObject)(field, opts);
    // const max = 16384;
    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');
    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');
    return field;
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(Fp, num, power) {
    if (power < _0n)
        throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n)
        return Fp.ONE;
    if (power === _1n)
        return num;
    let p = Fp.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */
function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
// TODO: remove
function FpDiv(Fp, lhs, rhs) {
    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue
 * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue
 * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)
 */
function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no)
        throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(Fp, n) {
    const l = FpLegendre(Fp, n);
    return l === 1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined)
        (0, utils_ts_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Creates a finite field. Major performance optimizations:
 * * 1. Denormalized operations like mulN instead of mul.
 * * 2. Identical object shape: never add or remove keys.
 * * 3. `Object.freeze`.
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 *
 * Note about field properties:
 * * CHARACTERISTIC p = prime number, number of elements in main subgroup.
 * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
 *
 * @param ORDER field order, probably prime, or could be composite
 * @param bitLen how many bits the field consumes
 * @param isLE (default: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?
isLE = false, opts = {}) {
    if (ORDER <= _0n)
        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    let modFromBytes = false;
    let allowedLengths = undefined;
    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
            throw new Error('cannot specify opts in two arguments');
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
            _nbitLength = _opts.BITS;
        if (_opts.sqrt)
            _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === 'boolean')
            isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === 'boolean')
            modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
    }
    else {
        if (typeof bitLenOrOpts === 'number')
            _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
            _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
        throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths: allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt ||
            ((n) => {
                if (!sqrtP)
                    sqrtP = FpSqrt(ORDER);
                return sqrtP(f, n);
            }),
        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes, skipValidation = true) => {
            if (allowedLengths) {
                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);
                }
                const padded = new Uint8Array(BYTES);
                // isLE add 0 to right, !isLE to the left.
                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
                bytes = padded;
            }
            if (bytes.length !== BYTES)
                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
            if (modFromBytes)
                scalar = mod(scalar, ORDER);
            if (!skipValidation)
                if (!f.isValid(scalar))
                    throw new Error('invalid field element: outside of range 0..ORDER');
            // NOTE: we don't validate scalar here, please use isValid. This done such way because some
            // protocol may allow non-reduced scalar that reduced later or changed some other way.
            return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => (c ? b : a),
    });
    return Object.freeze(f);
}
// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?
// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).
// which mean we cannot force this via opts.
// Not sure what to do with randomBytes, we can accept it inside opts if wanted.
// Probably need to export getMinHashLength somewhere?
// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {
//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;
//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?
//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;
//   return reduced;
// },
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use `mapKeyToField` instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
}
//# sourceMappingURL=modular.js.map

/***/ }),

/***/ 5449:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.montgomery = montgomery;
/**
 * Montgomery curve methods. It's not really whole montgomery curve,
 * just bunch of very specific methods for X25519 / X448 from
 * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __nccwpck_require__(8403);
const modular_ts_1 = __nccwpck_require__(6557);
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
function validateOpts(curve) {
    (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: 'function',
        powPminus2: 'function',
    });
    return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type === 'x25519';
    if (!is25519 && type !== 'x448')
        throw new Error('invalid type');
    const randomBytes_ = rand || utils_ts_1.randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    // RFC 7748 #5:
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and
    // (156326 - 2) / 4 = 39081 for curve448/X448
    // const a = is25519 ? 156326n : 486662n;
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    // RFC: x25519 "the resulting integer is of the form 2^254 plus
    // eight times a value between 0 and 2^251 - 1 (inclusive)"
    // x448: "2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)"
    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
    const maxAdded = is25519
        ? BigInt(8) * _2n ** BigInt(251) - _1n
        : BigInt(4) * _2n ** BigInt(445) - _1n;
    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)
    const modP = (n) => (0, modular_ts_1.mod)(n, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
    }
    function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)('u coordinate', u, fieldLen);
        // RFC: When receiving such an array, implementations of X25519
        // (but not X448) MUST mask the most significant bit in the final byte.
        if (is25519)
            _u[31] &= 127; // 0b0111_1111
        // RFC: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.  The non-canonical
        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224
        // - 1 through 2^448 - 1 for X448.
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
    }
    function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)('scalar', scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        // Some public keys are useless, of low-order. Curve author doesn't think
        // it needs to be validated, but we do it nonetheless.
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n)
            throw new Error('invalid private or public key received');
        return encodeU(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    // cswap from RFC7748 "example code"
    function cswap(swap, x_2, x_3) {
        // dummy = mask(swap) AND (x_2 XOR x_3)
        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2
        // and x_3, computed, e.g., as mask(swap) = 0 - swap.
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy
        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy
        return { x_2, x_3 };
    }
    /**
     * Montgomery x-only multiplication ladder.
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */
    function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)('u', u, _0n, P);
        (0, utils_ts_1.aInRange)('scalar', scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = (k >> t) & _1n;
            swap ^= k_t;
            ({ x_2, x_3 } = cswap(swap, x_2, x_3));
            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent
        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))
    }
    const lengths = {
        secretKey: fieldLen,
        publicKey: fieldLen,
        seed: fieldLen,
    };
    const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
        (0, utils_ts_1.abytes)(seed, lengths.seed);
        return seed;
    };
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: scalarMultBase(secretKey) };
    }
    const utils = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey,
    };
    return {
        keygen,
        getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey) => scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils,
        GuBytes: GuBytes.slice(),
        lengths,
    };
}
//# sourceMappingURL=montgomery.js.map

/***/ }),

/***/ 2210:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHash = exports.validateObject = exports.memoized = exports.notImplemented = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.aInRange = exports.inRange = exports.asciiToBytes = exports.copyBytes = exports.equalBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToNumber = exports.numberToHexUnpadded = exports.abool = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
/**
 * Deprecated module: moved from curves/abstract/utils.js to curves/utils.js
 * @module
 */
const u = __nccwpck_require__(8403);
/** @deprecated moved to `@noble/curves/utils.js` */
exports.abytes = u.abytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.anumber = u.anumber;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToHex = u.bytesToHex;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToUtf8 = u.bytesToUtf8;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.concatBytes = u.concatBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.hexToBytes = u.hexToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.isBytes = u.isBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.randomBytes = u.randomBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.utf8ToBytes = u.utf8ToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.abool = u.abool;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToHexUnpadded = u.numberToHexUnpadded;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.hexToNumber = u.hexToNumber;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToNumberBE = u.bytesToNumberBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToNumberLE = u.bytesToNumberLE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToBytesBE = u.numberToBytesBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToBytesLE = u.numberToBytesLE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToVarBytesBE = u.numberToVarBytesBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.ensureBytes = u.ensureBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.equalBytes = u.equalBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.copyBytes = u.copyBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.asciiToBytes = u.asciiToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.inRange = u.inRange;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.aInRange = u.aInRange;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitLen = u.bitLen;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitGet = u.bitGet;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitSet = u.bitSet;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitMask = u.bitMask;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.createHmacDrbg = u.createHmacDrbg;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.notImplemented = u.notImplemented;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.memoized = u.memoized;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.validateObject = u.validateObject;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.isHash = u.isHash;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 7760:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DER = exports.DERErr = void 0;
exports._splitEndoScalar = _splitEndoScalar;
exports._normFnElement = _normFnElement;
exports.weierstrassN = weierstrassN;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
exports.ecdh = ecdh;
exports.ecdsa = ecdsa;
exports.weierstrassPoints = weierstrassPoints;
exports._legacyHelperEquat = _legacyHelperEquat;
exports.weierstrass = weierstrass;
/**
 * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_js_1 = __nccwpck_require__(9149);
const utils_1 = __nccwpck_require__(6161);
const utils_ts_1 = __nccwpck_require__(8403);
const curve_ts_1 = __nccwpck_require__(9328);
const modular_ts_1 = __nccwpck_require__(6557);
// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)
const divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
/**
 * Splits scalar for GLV endomorphism.
 */
function _splitEndoScalar(k, basis, n) {
    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`
    // Since part can be negative, we need to do this on point.
    // TODO: verifyScalar function which consumes lambda
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    // |k1|/|k2| is < sqrt(N), but can be negative.
    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n;
    const k2neg = k2 < _0n;
    if (k1neg)
        k1 = -k1;
    if (k2neg)
        k2 = -k2;
    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.
    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.
    const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n; // Half bits of N
    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error('splitScalar (endomorphism): failed, k=' + k);
    }
    return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
    if (!['compact', 'recovered', 'der'].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
}
function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
        // @ts-ignore
        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];
    }
    (0, utils_ts_1._abool2)(optsn.lowS, 'lowS');
    (0, utils_ts_1._abool2)(optsn.prehash, 'prehash');
    if (optsn.format !== undefined)
        validateSigFormat(optsn.format);
    return optsn;
}
class DERErr extends Error {
    constructor(m = '') {
        super(m);
    }
}
exports.DERErr = DERErr;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
exports.DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length & 1)
                throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if ((len.length / 2) & 128)
                throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag)
                throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong)
                length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen)
                    throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4)
                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen)
                    throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0)
                    throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)
                    length = (length << 8) | b;
                pos += lenLen;
                if (length < 128)
                    throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
                throw new E('tlv.decode: wrong value length');
            return { v, l: data.subarray(pos + length) };
        },
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
                throw new E('integer: negative integers are not allowed');
            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 0b1000)
                hex = '00' + hex;
            if (hex.length & 1)
                throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
                throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128))
                throw new E('invalid signature integer: unnecessary leading zero');
            return (0, utils_ts_1.bytesToNumberBE)(data);
        },
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function _normFnElement(Fn, key) {
    const { BYTES: expected } = Fn;
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else {
        let bytes = (0, utils_ts_1.ensureBytes)('private key', key);
        try {
            num = Fn.fromBytes(bytes);
        }
        catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
    }
    if (!Fn.isValidNot0(num))
        throw new Error('invalid private key: out of range [1..N-1]');
    return num;
}
/**
 * Creates weierstrass Point constructor, based on specified curve options.
 *
 * @example
```js
const opts = {
  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
  h: BigInt(1),
  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
const p256_Point = weierstrass(opts);
```
 */
function weierstrassN(params, extraOpts = {}) {
    const validated = (0, curve_ts_1._createCurveFields)('weierstrass', params, extraOpts);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: 'boolean',
        clearCofactor: 'function',
        isTorsionFree: 'function',
        fromBytes: 'function',
        toBytes: 'function',
        endo: 'object',
        wrapPrivateKey: 'boolean',
    });
    const { endo } = extraOpts;
    if (endo) {
        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {
            throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
    }
    const lengths = getWLengths(Fp, Fn);
    function assertCompressionIsSupported() {
        if (!Fp.isOdd)
            throw new Error('compression is not supported: Field does not have .isOdd()');
    }
    // Implements IEEE P1363 point encoding
    function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
        if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        }
        else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));
        }
    }
    function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, undefined, 'Point');
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        // No actual validation is done here: use .assertValidity()
        if (length === comp && (head === 0x02 || head === 0x03)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
                throw new Error('bad point: is not on curve, wrong x');
            const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b
            let y;
            try {
                y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4
            }
            catch (sqrtError) {
                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                throw new Error('bad point: is not on curve, sqrt error' + err);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1; // ECDSA-specific
            if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
            return { x, y };
        }
        else if (length === uncomp && head === 0x04) {
            // TODO: more checks
            const L = Fp.BYTES;
            const x = Fp.fromBytes(tail.subarray(0, L));
            const y = Fp.fromBytes(tail.subarray(L, L * 2));
            if (!isValidXY(x, y))
                throw new Error('bad point: is not on curve');
            return { x, y };
        }
        else {
            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x¬≤ * x
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x¬≥ + a * x + b
    }
    // TODO: move top-level
    /** Checks whether equation holds for given x, y: y¬≤ == x¬≥ + ax + b */
    function isValidXY(x, y) {
        const left = Fp.sqr(y); // y¬≤
        const right = weierstrassEquation(x); // x¬≥ + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y¬≤ = x¬≥ + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    // Test 2: discriminant Œî part should be non-zero: 4a¬≥ + 27b¬≤ != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error('bad curve params: a or b');
    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */
    function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))
            throw new Error(`bad point coordinate ${title}`);
        return n;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
            throw new Error('no endo');
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        // Fast-path for normalized points
        if (Fp.eql(Z, Fp.ONE))
            return { x: X, y: Y };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
            throw new Error('invZ was invalid');
        return { x, y };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
                return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error('bad point: x or y not field elements');
        if (!isValidXY(x, y))
            throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ‚àã (x=X/Z, y=Y/Z).
     * Default Point works in 2d / affine coordinates: (x, y).
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
            this.X = acoord('x', X);
            this.Y = acoord('y', Y, true);
            this.Z = acoord('z', Z);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)
            if (Fp.is0(x) && Fp.is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
            const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, undefined, 'point')));
            P.assertValidity();
            return P;
        }
        static fromHex(hex) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex));
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
                this.multiply(_3n); // random number
            return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            const { endo } = extraOpts;
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: out of range'); // 0 is invalid
            let point, fake; // Fake point is used to const-time mult
            const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
            /** See docs for {@link EndomorphismOpts} */
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
                const { p: k1p, f: k1f } = mul(k1);
                const { p: k2p, f: k2f } = mul(k2);
                fake = k1f.add(k2f);
                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);
            }
            else {
                const { p, f } = mul(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
            const { endo } = extraOpts;
            const p = this;
            if (!Fn.isValid(sc))
                throw new Error('invalid scalar: out of range'); // 0 is valid
            if (sc === _0n || p.is0())
                return Point.ZERO;
            if (sc === _1n)
                return p; // fast-path
            if (wnaf.hasCache(this))
                return this.multiply(sc);
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe
                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);
            }
            else {
                return wnaf.unsafe(p, sc);
            }
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? undefined : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
            const { isTorsionFree } = extraOpts;
            if (cofactor === _1n)
                return true;
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
            const { clearCofactor } = extraOpts;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
            // can we use this.clearCofactor()?
            return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
            (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
            return this.X;
        }
        get py() {
            return this.X;
        }
        get pz() {
            return this.Z;
        }
        toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
// Points start with byte 0x02 when y is even; otherwise 0x03
function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    (0, modular_ts_1.validateField)(Fp);
    const { A, B, Z } = opts;
    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
    if (!Fp.isOdd)
        throw new Error('Field does not have .isOdd()');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4
        return { x, y };
    };
}
function getWLengths(Fp, Fn) {
    return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES,
    };
}
/**
 * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.
 * This helper ensures no signature functionality is present. Less code, smaller bundle size.
 */
function ecdh(Point, ecdhOpts = {}) {
    const { Fn } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
    function isValidSecretKey(secretKey) {
        try {
            return !!_normFnElement(Fn, secretKey);
        }
        catch (error) {
            return false;
        }
    }
    function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
            const l = publicKey.length;
            if (isCompressed === true && l !== comp)
                return false;
            if (isCompressed === false && l !== publicKeyUncompressed)
                return false;
            return !!Point.fromBytes(publicKey);
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Produces cryptographically secure secret key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed'), Fn.ORDER);
    }
    /**
     * Computes public key for a secret key. Checks for validity of the secret key.
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        if (typeof item === 'bigint')
            return false;
        if (item instanceof Point)
            return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey)
            return undefined;
        const l = (0, utils_ts_1.ensureBytes)('key', item).length;
        return l === publicKey || l === publicKeyUncompressed;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from secret key A and public key B.
     * Checks: 1) secret key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
            throw new Error('first arg must be private key');
        if (isProbPub(publicKeyB) === false)
            throw new Error('second arg must be public key');
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB); // checks for being on-curve
        return b.multiply(s).toBytes(isCompressed);
    }
    const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
/**
 * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.
 * We need `hash` for 2 features:
 * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`
 * 2. k generation in `sign`, using HMAC-drbg(hash)
 *
 * ECDSAOpts are only rarely needed.
 *
 * @example
 * ```js
 * const p256_Point = weierstrass(...);
 * const p256_sha256 = ecdsa(p256_Point, sha256);
 * const p256_sha224 = ecdsa(p256_Point, sha224);
 * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });
 * ```
 */
function ecdsa(Point, hash, ecdsaOpts = {}) {
    (0, utils_1.ahash)(hash);
    (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function',
    });
    const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
    const hmac = ecdsaOpts.hmac ||
        ((key, ...msgs) => (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,
        format: undefined, //'compact' as ECDSASigFormat,
        extraEntropy: false,
    };
    const defaultSigOpts_format = 'compact';
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
    }
    function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
    }
    /**
     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = validateRS('r', r); // r in [1..N-1];
            this.s = validateRS('s', s); // s in [1..N-1];
            if (recovery != null)
                this.recovery = recovery;
            Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
            validateSigLength(bytes, format);
            let recid;
            if (format === 'der') {
                const { r, s } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
                return new Signature(r, s);
            }
            if (format === 'recovered') {
                recid = bytes[0];
                format = 'compact';
                bytes = bytes.subarray(1);
            }
            const L = Fn.BYTES;
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            // ECDSA recovery is hard for cofactor > 1 curves.
            // In sign, `r = q.x mod n`, and here we recover q.x from r.
            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.
            // However, for cofactor>1, r+n may not get q.x:
            // r+n*i would need to be done instead where i is unknown.
            // To easily get i, we either need to:
            // a. increase amount of valid recid values (4, 5...); OR
            // b. prohibit non-prime-order signatures (recid > 1).
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1)
                throw new Error('recovery id is ambiguous for h>1 curve');
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
                throw new Error('recovery id 2 or 3 invalid');
            const x = Fp.toBytes(radj);
            const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj); // r^-1
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', messageHash)); // Truncate hash
            const u1 = Fn.create(-h * ir); // -hr^-1
            const u2 = Fn.create(s * ir); // sr^-1
            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
                throw new Error('point at infinify');
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
            validateSigFormat(format);
            if (format === 'der')
                return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            const r = Fn.toBytes(this.r);
            const s = Fn.toBytes(this.s);
            if (format === 'recovered') {
                if (this.recovery == null)
                    throw new Error('recovery bit must be present');
                return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
            }
            return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() { }
        static fromCompact(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'compact');
        }
        static fromDER(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'der');
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return this.toBytes('der');
        }
        toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));
        }
        toCompactRawBytes() {
            return this.toBytes('compact');
        }
        toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));
        }
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = ecdsaOpts.bits2int ||
        function bits2int_def(bytes) {
            // Our custom check "just in case", for protection against DoS
            if (bytes.length > 8192)
                throw new Error('input is too large');
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = ecdsaOpts.bits2int_modN ||
        function bits2int_modN_def(bytes) {
            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // Pads output with zero as per spec
    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */
    function int2octets(num) {
        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`
        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
    }
    function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, undefined, 'message');
        return prehash ? (0, utils_ts_1._abytes2)(hash(message), undefined, 'prehashed message') : message;
    }
    /**
     * Steps A, D of RFC6979 3.2.
     * Creates RFC6979 seed; converts msg/privKey to numbers.
     * Used only in sign, not in verify.
     *
     * Warning: we cannot assume here that message has same amount of bytes as curve order,
     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.
     */
    function prepSig(message, privateKey, opts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (extraEntropy != null && extraEntropy !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            // gen random bytes OR pass as-is
            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        // To transform k => Signature:
        // q = k‚ãÖG
        // r = q.x mod n
        // s = k^-1(m + rd) mod n
        // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to
        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            // Important: all mod() calls here must be done over N
            const k = bits2int(kBytes); // mod n, not mod p
            if (!Fn.isValidNot0(k))
                return; // Valid scalars (including k) must be in 1..N-1
            const ik = Fn.inv(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = k‚ãÖG
            const r = Fn.create(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = Fn.neg(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    /**
     * Signs message hash with a secret key.
     *
     * ```
     * sign(m, d) where
     *   k = rfc6979_hmac_drbg(m, d)
     *   (x, y) = G √ó k
     *   r = x mod n
     *   s = (m + dr) / k mod n
     * ```
     */
    function sign(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)('message', message);
        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);
        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G
        return sig;
    }
    function tryParsingSig(sg) {
        // Try to deduce format
        let sig = undefined;
        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex &&
            sg !== null &&
            typeof sg === 'object' &&
            typeof sg.r === 'bigint' &&
            typeof sg.s === 'bigint';
        if (!isHex && !isObj)
            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        if (isObj) {
            sig = new Signature(sg.r, sg.s);
        }
        else if (isHex) {
            try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'der');
            }
            catch (derError) {
                if (!(derError instanceof exports.DER.Err))
                    throw derError;
            }
            if (!sig) {
                try {
                    sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'compact');
                }
                catch (error) {
                    return false;
                }
            }
        }
        if (!sig)
            return false;
        return sig;
    }
    /**
     * Verifies a signature against message and public key.
     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.
     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   u1 = hs^-1 mod n
     *   u2 = rs^-1 mod n
     *   R = u1‚ãÖG + u2‚ãÖP
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)('message', message), prehash);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const sig = format === undefined
            ? tryParsingSig(signature)
            : Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', signature), format);
        if (sig === false)
            return false;
        try {
            const P = Point.fromBytes(publicKey);
            if (lowS && sig.hasHighS())
                return false;
            const { r, s } = sig;
            const h = bits2int_modN(message); // mod n, not mod p
            const is = Fn.inv(s); // s^-1 mod n
            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n
            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n
            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1‚ãÖG + u2‚ãÖP
            if (R.is0())
                return false;
            const v = Fn.create(R.x); // v = r.x mod n
            return v === r;
        }
        catch (e) {
            return false;
        }
    }
    function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash,
    });
}
/** @deprecated use `weierstrass` in newer releases */
function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point);
}
function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths
        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))
        : undefined;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths: allowedLengths,
        modFromBytes: c.wrapPrivateKey,
    });
    const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes,
    };
    return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN,
    };
    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _legacyHelperEquat(Fp, a, b) {
    /**
     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula. Takes x, returns y¬≤.
     * @returns y¬≤
     */
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x¬≤ * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x¬≥ + a * x + b
    }
    return weierstrassEquation;
}
function _weierstrass_new_output_to_legacy(c, Point) {
    const { Fp, Fn } = Point;
    function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
    return Object.assign({}, {
        CURVE: c,
        Point: Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder,
    });
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS)),
    });
}
// _ecdsa_legacy
function weierstrass(c) {
    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, hash, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
}
//# sourceMappingURL=weierstrass.js.map

/***/ }),

/***/ 9038:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
/**
 * ed25519 Twisted Edwards curve with following addons:
 * - X25519 ECDH
 * - Ristretto cofactor elimination
 * - Elligator hash-to-group / point indistinguishability
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __nccwpck_require__(8872);
const utils_js_1 = __nccwpck_require__(6161);
const curve_ts_1 = __nccwpck_require__(9328);
const edwards_ts_1 = __nccwpck_require__(8753);
const hash_to_curve_ts_1 = __nccwpck_require__(7281);
const modular_ts_1 = __nccwpck_require__(6557);
const montgomery_ts_1 = __nccwpck_require__(5449);
const utils_ts_1 = __nccwpck_require__(8403);
// prettier-ignore
const _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _5n = BigInt(5), _8n = BigInt(8);
// P = 2n**255n-19n
const ed25519_CURVE_p = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed');
// N = 2n**252n + 27742317777372353535851937790883648493n
// a = Fp.create(BigInt(-1))
// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
const ed25519_CURVE = /* @__PURE__ */ (() => ({
    p: ed25519_CURVE_p,
    n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),
    h: _8n,
    a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),
    d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),
    Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),
    Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),
}))();
function ed25519_pow_2_252_3(x) {
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE_p;
    const x2 = (x * x) % P;
    const b2 = (x2 * x) % P; // x^3, 11
    const b4 = ((0, modular_ts_1.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111
    const b5 = ((0, modular_ts_1.pow2)(b4, _1n, P) * x) % P; // x^31
    const b10 = ((0, modular_ts_1.pow2)(b5, _5n, P) * b5) % P;
    const b20 = ((0, modular_ts_1.pow2)(b10, _10n, P) * b10) % P;
    const b40 = ((0, modular_ts_1.pow2)(b20, _20n, P) * b20) % P;
    const b80 = ((0, modular_ts_1.pow2)(b40, _40n, P) * b40) % P;
    const b160 = ((0, modular_ts_1.pow2)(b80, _80n, P) * b80) % P;
    const b240 = ((0, modular_ts_1.pow2)(b160, _80n, P) * b80) % P;
    const b250 = ((0, modular_ts_1.pow2)(b240, _10n, P) * b10) % P;
    const pow_p_5_8 = ((0, modular_ts_1.pow2)(b250, _2n, P) * x) % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 127; // 0b0111_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
}
// ‚àö(-1) aka ‚àö(a) aka 2^((p-1)/4)
// Fp.sqrt(Fp.neg(1))
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
// sqrt(u/v)
function uvRatio(u, v) {
    const P = ed25519_CURVE_p;
    const v3 = (0, modular_ts_1.mod)(v * v * v, P); // v¬≥
    const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P); // v‚Å∑
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, modular_ts_1.mod)(u * v3 * pow, P); // (uv¬≥)(uv‚Å∑)^(p-5)/8
    const vx2 = (0, modular_ts_1.mod)(v * x * x, P); // vx¬≤
    const root1 = x; // First root candidate
    const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx¬≤ = u (mod p), x is a square root
    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P); // If vx¬≤ = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx¬≤ = -u‚àö(-1)
    if (useRoot1)
        x = root1;
    if (useRoot2 || noRoot)
        x = root2; // We return root2 anyway, for const-time
    if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
}
const Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
const Fn = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha2_js_1.sha512,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/‚àöv
    uvRatio,
}))();
/**
 * ed25519 curve with EdDSA signatures.
 * @example
 * import { ed25519 } from '@noble/curves/ed25519';
 * const { secretKey, publicKey } = ed25519.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = ed25519.sign(msg, priv);
 * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215
 * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5
 */
exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
        throw new Error('Context is too big');
    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
/** Context of ed25519. Uses context for domain separation. */
exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain,
}))();
/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */
exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha2_js_1.sha512,
})))();
/**
 * ECDH using curve25519 aka x25519.
 * @example
 * import { x25519 } from '@noble/curves/ed25519';
 * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';
 * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';
 * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases
 * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);
 * x25519.getPublicKey(x25519.utils.randomSecretKey());
 */
exports.x25519 = (() => {
    const P = Fp.ORDER;
    return (0, montgomery_ts_1.montgomery)({
        P,
        type: 'x25519',
        powPminus2: (x) => {
            // x^(p-2) aka x^(2^255-21)
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes,
    });
})();
// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
// SageMath returns different root first and everything falls apart
const ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic
const ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1
const ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)
// prettier-ignore
function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)
}
const ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0
function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
    // map_to_curve_elligator2_curve25519(u)
    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true); // batch division
    return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)
}
/** Hashing to ed25519 points / field. RFC 9380 methods. */
exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',
    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',
    p: ed25519_CURVE_p,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha2_js_1.sha512,
}))();
// ‚àö(-1) aka ‚àö(a) aka 2^((p-1)/4)
const SQRT_M1 = ED25519_SQRT_M1;
// ‚àö(ad - 1)
const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
// 1 / ‚àö(a-d)
const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
// 1-d¬≤
const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
// (d-1)¬≤
const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
// Calculates 1/‚àö(number)
const invertSqrt = (number) => uvRatio(_1n, number);
const MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
const bytes255ToNumberLE = (bytes) => exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
/**
 * Computes Elligator map for Ristretto255.
 * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
 * the [website](https://ristretto.group/formulas/elligator.html).
 */
function calcElligatorRistrettoMap(r0) {
    const { d } = ed25519_CURVE;
    const P = ed25519_CURVE_p;
    const mod = (n) => Fp.create(n);
    const r = mod(SQRT_M1 * r0 * r0); // 1
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
    let c = BigInt(-1); // 3
    const D = mod((c - d * r) * mod(r + d)); // 4
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
    let s_ = mod(s * r0); // 6
    if (!(0, modular_ts_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
    if (!Ns_D_is_sq)
        s = s_; // 7
    if (!Ns_D_is_sq)
        c = r; // 8
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
    const s2 = s * s;
    const W0 = mod((s + s) * D); // 10
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
    const W2 = mod(_1n - s2); // 12
    const W3 = mod(_1n + s2); // 13
    return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
}
function ristretto255_map(bytes) {
    (0, utils_js_1.abytes)(bytes, 64);
    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
}
/**
 * Wrapper over Edwards Point for ristretto255.
 *
 * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
 * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
 * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
 * but it should work in its own namespace: do not combine those two.
 * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).
 */
class _RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
    constructor(ep) {
        super(ep);
    }
    static fromAffine(ap) {
        return new _RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
    }
    assertSame(other) {
        if (!(other instanceof _RistrettoPoint))
            throw new Error('RistrettoPoint expected');
    }
    init(ep) {
        return new _RistrettoPoint(ep);
    }
    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
    static hashToCurve(hex) {
        return ristretto255_map((0, utils_ts_1.ensureBytes)('ristrettoHash', hex, 64));
    }
    static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes, 32);
        const { a, d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const s = bytes255ToNumberLE(bytes);
        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
        // 3. Check that s is non-negative, or else abort
        if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P))
            throw new Error('invalid ristretto255 encoding 1');
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2); // 4 (a is -1)
        const u2 = mod(_1n - a * s2); // 5
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2); // 6
        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
        const Dx = mod(I * u2); // 8
        const Dy = mod(I * Dx * v); // 9
        let x = mod((s + s) * Dx); // 10
        if ((0, modular_ts_1.isNegativeLE)(x, P))
            x = mod(-x); // 10
        const y = mod(u1 * Dy); // 11
        const t = mod(x * y); // 12
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error('invalid ristretto255 encoding 2');
        return new _RistrettoPoint(new exports.ed25519.Point(x, y, _1n, t));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */
    static fromHex(hex) {
        return _RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)('ristrettoHex', hex, 32));
    }
    static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(_RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
     */
    toBytes() {
        let { X, Y, Z, T } = this.ep;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1
        const u2 = mod(X * Y); // 2
        // Square root always exists
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
        const D1 = mod(invsqrt * u1); // 4
        const D2 = mod(invsqrt * u2); // 5
        const zInv = mod(D1 * D2 * T); // 6
        let D; // 7
        if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
            let _x = mod(Y * SQRT_M1);
            let _y = mod(X * SQRT_M1);
            X = _x;
            Y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        }
        else {
            D = D2; // 8
        }
        if ((0, modular_ts_1.isNegativeLE)(X * zInv, P))
            Y = mod(-Y); // 9
        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))
        if ((0, modular_ts_1.isNegativeLE)(s, P))
            s = mod(-s);
        return Fp.toBytes(s); // 11
    }
    /**
     * Compares two Ristretto points.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
     */
    equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X2, Y: Y2 } = other.ep;
        const mod = (n) => Fp.create(n);
        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
    }
    is0() {
        return this.equals(_RistrettoPoint.ZERO);
    }
}
// Do NOT change syntax: the following gymnastics is done,
// because typescript strips comments, which makes bundlers disable tree-shaking.
// prettier-ignore
_RistrettoPoint.BASE = 
/* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.BASE))();
// prettier-ignore
_RistrettoPoint.ZERO = 
/* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.ZERO))();
// prettier-ignore
_RistrettoPoint.Fp = 
/* @__PURE__ */ (() => Fp)();
// prettier-ignore
_RistrettoPoint.Fn = 
/* @__PURE__ */ (() => Fn)();
exports.ristretto255 = { Point: _RistrettoPoint };
/** Hashing to ristretto255 points / field. RFC 9380 methods. */
exports.ristretto255_hasher = {
    hashToCurve(msg, options) {
        const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
        return ristretto255_map(xmd);
    },
    hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
    },
};
// export const ristretto255_oprf: OPRF = createORPF({
//   name: 'ristretto255-SHA512',
//   Point: RistrettoPoint,
//   hash: sha512,
//   hashToGroup: ristretto255_hasher.hashToCurve,
//   hashToScalar: ristretto255_hasher.hashToScalar,
// });
/**
 * Weird / bogus points, useful for debugging.
 * All 8 ed25519 points of 8-torsion subgroup can be generated from the point
 * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.
 * ‚ü®T‚ü© = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }
 */
exports.ED25519_TORSION_SUBGROUP = [
    '0100000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
    '0000000000000000000000000000000000000000000000000000000000000080',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
    '0000000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
];
/** @deprecated use `ed25519.utils.toMontgomery` */
function edwardsToMontgomeryPub(edwardsPub) {
    return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)('pub', edwardsPub));
}
/** @deprecated use `ed25519.utils.toMontgomery` */
exports.edwardsToMontgomery = edwardsToMontgomeryPub;
/** @deprecated use `ed25519.utils.toMontgomerySecret` */
function edwardsToMontgomeryPriv(edwardsPriv) {
    return exports.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)('pub', edwardsPriv));
}
/** @deprecated use `ristretto255.Point` */
exports.RistrettoPoint = _RistrettoPoint;
/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */
exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */
exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
exports.hashToRistretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
exports.hash_to_ristretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
//# sourceMappingURL=ed25519.js.map

/***/ }),

/***/ 6379:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
/**
 * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).
 *
 * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism œà,
 * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __nccwpck_require__(8872);
const utils_js_1 = __nccwpck_require__(6161);
const _shortw_utils_ts_1 = __nccwpck_require__(7981);
const hash_to_curve_ts_1 = __nccwpck_require__(7281);
const modular_ts_1 = __nccwpck_require__(6557);
const weierstrass_ts_1 = __nccwpck_require__(7760);
const utils_ts_1 = __nccwpck_require__(8403);
// Seems like generator was produced from some seed:
// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`
// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n
const secp256k1_CURVE = {
    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),
};
const secp256k1_ENDO = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    basises: [
        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],
        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],
    ],
};
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
/**
 * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_ts_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_ts_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_ts_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_ts_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_ts_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_ts_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_ts_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_ts_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_ts_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_ts_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_ts_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_ts_1.pow2)(t2, _2n, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
/**
 * secp256k1 curve, ECDSA and ECDH methods.
 *
 * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`
 *
 * @example
 * ```js
 * import { secp256k1 } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = secp256k1.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = secp256k1.sign(msg, secretKey);
 * const isValid = secp256k1.verify(sig, msg, publicKey) === true;
 * ```
 */
exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toBytes(true).slice(1);
const Pointk1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
const hasEven = (y) => y % _2n === _0n;
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    const { Fn, BASE } = Pointk1;
    const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
    const p = BASE.multiply(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside
    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
    return { scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    const Fp = Fpk1;
    if (!Fp.isValidNot0(x))
        throw new Error('invalid x: Fail if x ‚â• p');
    const xx = Fp.create(x * x);
    const c = Fp.create(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.
    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().
    // Return the unique point P such that x(P) = x and
    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    if (!hasEven(y))
        y = Fp.neg(y);
    const p = Pointk1.fromAffine({ x, y });
    p.assertValidity();
    return p;
}
const num = utils_ts_1.bytesToNumberBE;
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(secretKey) {
    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
    const { Fn } = Pointk1;
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder
    const a = (0, utils_ts_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'‚ãÖG
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const { Fn, BASE } = Pointk1;
    const sig = (0, utils_ts_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const pub = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
            return false;
        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
            return false;
        // int(challenge(bytes(r)||bytes(P)||m))%n
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        // R = s‚ãÖG - e‚ãÖP, where -eP == (n-e)P
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.
        if (R.is0() || !hasEven(y) || x !== r)
            return false;
        return true;
    }
    catch (error) {
        return false;
    }
}
/**
 * Schnorr signatures over secp256k1.
 * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 * @example
 * ```js
 * import { schnorr } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = schnorr.keygen();
 * // const publicKey = schnorr.getPublicKey(secretKey);
 * const msg = new TextEncoder().encode('hello');
 * const sig = schnorr.sign(msg, secretKey);
 * const isValid = schnorr.verify(sig, msg, publicKey);
 * ```
 */
exports.schnorr = (() => {
    const size = 32;
    const seedLength = 48;
    const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
    };
    // TODO: remove
    exports.secp256k1.utils.randomSecretKey;
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
    }
    return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
            randomSecretKey: randomSecretKey,
            randomPrivateKey: randomSecretKey,
            taggedHash,
            // TODO: remove
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_ts_1.numberToBytesBE,
            bytesToNumberBE: utils_ts_1.bytesToNumberBE,
            mod: modular_ts_1.mod,
        },
        lengths: {
            secretKey: size,
            publicKey: size,
            publicKeyHasPrefix: false,
            signature: size * 2,
            seed: seedLength,
        },
    };
})();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fpk1.create(BigInt('-11')),
}))();
/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */
exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
    const { x, y } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha2_js_1.sha256,
}))();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */
exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */
exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
//# sourceMappingURL=secp256k1.js.map

/***/ }),

/***/ 8403:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
exports.abool = abool;
exports._abool2 = _abool2;
exports._abytes2 = _abytes2;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.equalBytes = equalBytes;
exports.copyBytes = copyBytes;
exports.asciiToBytes = asciiToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.isHash = isHash;
exports._validateObject = _validateObject;
exports.memoized = memoized;
/**
 * Hex, bytes and number utilities.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1 = __nccwpck_require__(6161);
var utils_js_2 = __nccwpck_require__(6161);
Object.defineProperty(exports, "abytes", ({ enumerable: true, get: function () { return utils_js_2.abytes; } }));
Object.defineProperty(exports, "anumber", ({ enumerable: true, get: function () { return utils_js_2.anumber; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return utils_js_2.bytesToHex; } }));
Object.defineProperty(exports, "bytesToUtf8", ({ enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_js_2.concatBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return utils_js_2.hexToBytes; } }));
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return utils_js_2.isBytes; } }));
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return utils_js_2.randomBytes; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } }));
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
    if (typeof value !== 'boolean')
        throw new Error(title + ' boolean expected, got ' + value);
}
// tmp name until v2
function _abool2(value, title = '') {
    if (typeof value !== 'boolean') {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + 'expected boolean, got type=' + typeof value);
    }
    return value;
}
// tmp name until v2
/** Asserts something is Uint8Array. */
function _abytes2(value, length, title = '') {
    const bytes = (0, utils_js_1.isBytes)(value);
    const len = value?.length;
    const needsLen = length !== undefined;
    if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : '';
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);
    }
    return value;
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
}
function bytesToNumberLE(bytes) {
    (0, utils_js_1.abytes)(bytes);
    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'secret key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = (0, utils_js_1.hexToBytes)(hex);
        }
        catch (e) {
            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
        }
    }
    else if ((0, utils_js_1.isBytes)(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(title + ' must be hex string or Uint8Array');
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,
 * and Buffer#slice creates mutable copy. Never use Buffers!
 */
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
/**
 * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols
 * Should be safe to use for things expected to be ASCII.
 * Returns exact same result as utf8ToBytes for ASCII or throws.
 */
function asciiToBytes(ascii) {
    return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
            throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        }
        return charCode;
    });
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len) => new Uint8Array(len); // creates Uint8Array
    const u8of = (byte) => Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0)) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
function isHash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object')
        throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined)
            return;
        const current = typeof val;
        if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
 * throws not implemented error
 */
const notImplemented = () => {
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 180:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */
const utils_ts_1 = __nccwpck_require__(6161);
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
    return (a & b) ^ (~a & c);
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
    return (a & b) ^ (a & c) ^ (b & c);
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */
exports.SHA256_IV = Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */
exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */
exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */
exports.SHA512_IV = Uint32Array.from([
    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,
]);
//# sourceMappingURL=_md.js.map

/***/ }),

/***/ 7155:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ 7843:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
/**
 * Internal webcrypto alias.
 * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.
 * Falls back to Node.js built-in crypto for Node.js <=v14.
 * See utils.ts for details.
 * @module
 */
// @ts-ignore
const nc = __nccwpck_require__(6005);
exports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc
    ? nc.webcrypto
    : nc && typeof nc === 'object' && 'randomBytes' in nc
        ? nc
        : undefined;
//# sourceMappingURL=cryptoNode.js.map

/***/ }),

/***/ 9149:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */
const utils_ts_1 = __nccwpck_require__(6161);
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ 7443:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
/**

SHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.
Don't use them in a new protocol. What "weak" means:

- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.
- No practical pre-image attacks (only theoretical, 2^123.4)
- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151
 * @module
 */
const _md_ts_1 = __nccwpck_require__(180);
const utils_ts_1 = __nccwpck_require__(6161);
/** Initial SHA1 state */
const SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,
]);
// Reusable temporary buffer
const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
/** SHA1 legacy hash class. */
class SHA1 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
            SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
            let F, K;
            if (i < 20) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                K = 0x5a827999;
            }
            else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            }
            else if (i < 60) {
                F = (0, _md_ts_1.Maj)(B, C, D);
                K = 0x8f1bbcdc;
            }
            else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;
            E = D;
            D = C;
            C = (0, utils_ts_1.rotl)(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA1 = SHA1;
/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */
exports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
/** Per-round constants */
const p32 = /* @__PURE__ */ Math.pow(2, 32);
const K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
/** md5 initial state: same as sha1, but 4 u32 instead of 5. */
const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
// Reusable temporary buffer
const MD5_W = /* @__PURE__ */ new Uint32Array(16);
/** MD5 legacy hash class. */
class MD5 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
    }
    get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
    }
    set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            MD5_W[i] = view.getUint32(offset, true);
        // Compression function main loop, 64 rounds
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
            let F, g, s;
            if (i < 16) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                g = i;
                s = [7, 12, 17, 22];
            }
            else if (i < 32) {
                F = (0, _md_ts_1.Chi)(D, B, C);
                g = (5 * i + 1) % 16;
                s = [5, 9, 14, 20];
            }
            else if (i < 48) {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
                s = [4, 11, 16, 23];
            }
            else {
                F = C ^ (B | ~D);
                g = (7 * i) % 16;
                s = [6, 10, 15, 21];
            }
            F = F + A + K[i] + MD5_W[g];
            A = D;
            D = C;
            C = B;
            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        this.set(A, B, C, D);
    }
    roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
    }
    destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.MD5 = MD5;
/**
 * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.
 * MD5 architecture is similar to SHA1, with some differences:
 * - Reduced output length: 16 bytes (128 bit) instead of 20
 * - 64 rounds, instead of 80
 * - Little-endian: could be faster, but will require more code
 * - Non-linear index selection: huge speed-up for unroll
 * - Per round constants: more memory accesses, additional speed-up for unroll
 */
exports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
// RIPEMD-160
const Rho160 = /* @__PURE__ */ Uint8Array.from([
    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
]);
const Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
const Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
const idxLR = /* @__PURE__ */ (() => {
    const L = [Id160];
    const R = [Pi160];
    const res = [L, R];
    for (let i = 0; i < 4; i++)
        for (let j of res)
            j.push(j[i].map((k) => Rho160[k]));
    return res;
})();
const idxL = /* @__PURE__ */ (() => idxLR[0])();
const idxR = /* @__PURE__ */ (() => idxLR[1])();
// const [idxL, idxR] = idxLR;
const shifts160 = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => Uint8Array.from(i));
const shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
const shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
const Kl160 = /* @__PURE__ */ Uint32Array.from([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr160 = /* @__PURE__ */ Uint32Array.from([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// It's called f() in spec.
function ripemd_f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    if (group === 1)
        return (x & y) | (~x & z);
    if (group === 2)
        return (x | ~y) ^ z;
    if (group === 3)
        return (x & z) | (y & ~z);
    return x ^ (y | ~z);
}
// Reusable temporary buffer
const BUF_160 = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF_160[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = ((0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = ((0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a legacy hash function from 1990s.
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 */
exports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());
//# sourceMappingURL=legacy.js.map

/***/ }),

/***/ 5058:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pbkdf2 = pbkdf2;
exports.pbkdf2Async = pbkdf2Async;
/**
 * PBKDF (RFC 2898). Can be used to create a key from password and salt.
 * @module
 */
const hmac_ts_1 = __nccwpck_require__(9149);
// prettier-ignore
const utils_ts_1 = __nccwpck_require__(6161);
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, utils_ts_1.ahash)(hash);
    const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, utils_ts_1.anumber)(c);
    (0, utils_ts_1.anumber)(dkLen);
    (0, utils_ts_1.anumber)(asyncTick);
    if (c < 1)
        throw new Error('iterations (c) should be >= 1');
    const password = (0, utils_ts_1.kdfInputToBytes)(_password);
    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_ts_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    (0, utils_ts_1.clean)(u);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 * @example
 * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });
 */
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ‚ãØ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ‚ãØ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc‚àí1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.
 * @example
 * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });
 */
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ‚ãØ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ‚ãØ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
            // Uc = PRF(Password, Uc‚àí1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
//# sourceMappingURL=pbkdf2.js.map

/***/ }),

/***/ 8872:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */
const _md_ts_1 = __nccwpck_require__(180);
const u64 = __nccwpck_require__(7155);
const utils_ts_1 = __nccwpck_require__(6161);
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */
// prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (() => u64.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */
/** SHA512/224 IV */
const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,
    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,
]);
/** SHA512/256 IV */
const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,
    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,
]);
class SHA512_224 extends SHA512 {
    constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */
exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
/** SHA2-224 hash function from RFC 4634 */
exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
/** SHA2-512 hash function from RFC 4634. */
exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
/** SHA2-384 hash function from RFC 4634. */
exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ 6161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __nccwpck_require__(7843);
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
exports.swap8IfBE = exports.isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE
    ? (u) => u
    : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */
class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 9891:
/***/ ((__unused_webpack_module, exports) => {


/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function isArrayOf(isString, arr) {
    if (!Array.isArray(arr))
        return false;
    if (arr.length === 0)
        return true;
    if (isString) {
        return arr.every((item) => typeof item === 'string');
    }
    else {
        return arr.every((item) => Number.isSafeInteger(item));
    }
}
// no abytes: seems to have 10% slowdown. Why?!
function afn(input) {
    if (typeof input !== 'function')
        throw new Error('function expected');
    return true;
}
function astr(label, input) {
    if (typeof input !== 'string')
        throw new Error(`${label}: string expected`);
    return true;
}
function anumber(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
    if (!Array.isArray(input))
        throw new Error('array expected');
}
function astrArr(label, input) {
    if (!isArrayOf(true, input))
        throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
    if (!isArrayOf(false, input))
        throw new Error(`${label}: array of numbers expected`);
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function chain(...args) {
    const id = (a) => a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b) => (c) => a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x) => x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x) => x.decode).reduce(wrap, id);
    return { encode, decode };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back.
 * Could also be array of strings.
 * @__NO_SIDE_EFFECTS__
 */
function alphabet(letters) {
    // mapping 1 to "b"
    const lettersA = typeof letters === 'string' ? letters.split('') : letters;
    const len = lettersA.length;
    astrArr('alphabet', lettersA);
    // mapping "b" to 1
    const indexes = new Map(lettersA.map((l, i) => [l, i]));
    return {
        encode: (digits) => {
            aArr(digits);
            return digits.map((i) => {
                if (!Number.isSafeInteger(i) || i < 0 || i >= len)
                    throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
                return lettersA[i];
            });
        },
        decode: (input) => {
            aArr(input);
            return input.map((letter) => {
                astr('alphabet.decode', letter);
                const i = indexes.get(letter);
                if (i === undefined)
                    throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                return i;
            });
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function join(separator = '') {
    astr('join', separator);
    return {
        encode: (from) => {
            astrArr('join.decode', from);
            return from.join(separator);
        },
        decode: (to) => {
            astr('join.decode', to);
            return to.split(separator);
        },
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */
function padding(bits, chr = '=') {
    anumber(bits);
    astr('padding', chr);
    return {
        encode(data) {
            astrArr('padding.encode', data);
            while ((data.length * bits) % 8)
                data.push(chr);
            return data;
        },
        decode(input) {
            astrArr('padding.decode', input);
            let end = input.length;
            if ((end * bits) % 8)
                throw new Error('padding: invalid, string should have whole number of bytes');
            for (; end > 0 && input[end - 1] === chr; end--) {
                const last = end - 1;
                const byte = last * bits;
                if (byte % 8 === 0)
                    throw new Error('padding: invalid, string has too much padding');
            }
            return input.slice(0, end);
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function normalize(fn) {
    afn(fn);
    return { encode: (from) => from, decode: (to) => fn(to) };
}
/**
 * Slow: O(n^2) time complexity
 */
function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2)
        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2)
        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length)
        return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d) => {
        anumber(d);
        if (d < 0 || d >= from)
            throw new Error(`invalid integer: ${d}`);
        return d;
    });
    const dlen = digits.length;
    while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < dlen; i++) {
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) ||
                fromCarry / from !== carry ||
                digitBase - digit !== fromCarry) {
                throw new Error('convertRadix: carry overflow');
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                throw new Error('convertRadix: carry overflow');
            if (!done)
                continue;
            else if (!rounded)
                pos = i;
            else
                done = false;
        }
        res.push(carry);
        if (done)
            break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
    return res.reverse();
}
const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
const powers = /* @__PURE__ */ (() => {
    let res = [];
    for (let i = 0; i < 40; i++)
        res.push(2 ** i);
    return res;
})();
/**
 * Implemented with numbers, because BigInt is 5x slower
 */
function convertRadix2(data, from, to, padding) {
    aArr(data);
    if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data) {
        anumber(n);
        if (n >= max)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
            res.push(((carry >> (pos - to)) & mask) >>> 0);
        const pow = powers[pos];
        if (pow === undefined)
            throw new Error('invalid carry');
        carry &= pow - 1; // clean carry, otherwise it will cause overflow
    }
    carry = (carry << (to - pos)) & mask;
    if (!padding && pos >= from)
        throw new Error('Excess padding');
    if (!padding && carry > 0)
        throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0)
        res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function radix(num) {
    anumber(num);
    const _256 = 2 ** 8;
    return {
        encode: (bytes) => {
            if (!isBytes(bytes))
                throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits) => {
            anumArr('radix.decode', digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
        },
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */
function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32)
        throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error('radix2: carry overflow');
    return {
        encode: (bytes) => {
            if (!isBytes(bytes))
                throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
            anumArr('radix2.decode', digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
    };
}
function unsafeWrapper(fn) {
    afn(fn);
    return function (...args) {
        try {
            return fn.apply(null, args);
        }
        catch (e) { }
    };
}
function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
        encode(data) {
            if (!isBytes(data))
                throw new Error('checksum.encode: input should be Uint8Array');
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
        },
        decode(data) {
            if (!isBytes(data))
                throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for (let i = 0; i < len; i++)
                if (newChecksum[i] !== oldChecksum[i])
                    throw new Error('Invalid checksum');
            return payload;
        },
    };
}
// prettier-ignore
exports.utils = {
    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,
};
// RFC 4648 aka RFC 3548
// ---------------------
/**
 * base16 encoding from RFC 4648.
 * @example
 * ```js
 * base16.encode(Uint8Array.from([0x12, 0xab]));
 * // => '12AB'
 * ```
 */
exports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
/**
 * base32 encoding from RFC 4648. Has padding.
 * Use `base32nopad` for unpadded version.
 * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
 * @example
 * ```js
 * base32.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'CKVQ===='
 * base32.decode('CKVQ====');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
/**
 * base32 encoding from RFC 4648. No padding.
 * Use `base32` for padded version.
 * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
 * @example
 * ```js
 * base32nopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'CKVQ'
 * base32nopad.decode('CKVQ');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
/**
 * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.
 * Use `base32hexnopad` for unpadded version.
 * @example
 * ```js
 * base32hex.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ALG===='
 * base32hex.decode('2ALG====');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
/**
 * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.
 * Use `base32hex` for padded version.
 * @example
 * ```js
 * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ALG'
 * base32hexnopad.decode('2ALG');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
/**
 * base32 encoding from RFC 4648. Doug Crockford's version.
 * https://www.crockford.com/base32.html
 * @example
 * ```js
 * base32crockford.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ANG'
 * base32crockford.decode('2ANG');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64
// prettier-ignore
const hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&
    typeof Uint8Array.fromBase64 === 'function')();
const decodeBase64Builtin = (s, isUrl) => {
    astr('base64', s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet = isUrl ? 'base64url' : 'base64';
    if (s.length > 0 && !re.test(s))
        throw new Error('invalid base64');
    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });
};
/**
 * base64 from RFC 4648. Padded.
 * Use `base64nopad` for unpadded version.
 * Also check out `base64url`, `base64urlnopad`.
 * Falls back to built-in function, when available.
 * @example
 * ```js
 * base64.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs='
 * base64.decode('Eqs=');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
// prettier-ignore
exports.base64 = hasBase64Builtin ? {
    encode(b) { abytes(b); return b.toBase64(); },
    decode(s) { return decodeBase64Builtin(s, false); },
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
/**
 * base64 from RFC 4648. No padding.
 * Use `base64` for padded version.
 * @example
 * ```js
 * base64nopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs'
 * base64nopad.decode('Eqs');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
/**
 * base64 from RFC 4648, using URL-safe alphabet. Padded.
 * Use `base64urlnopad` for unpadded version.
 * Falls back to built-in function, when available.
 * @example
 * ```js
 * base64url.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs='
 * base64url.decode('Eqs=');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
// prettier-ignore
exports.base64url = hasBase64Builtin ? {
    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },
    decode(s) { return decodeBase64Builtin(s, true); },
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
/**
 * base64 from RFC 4648, using URL-safe alphabet. No padding.
 * Use `base64url` for padded version.
 * @example
 * ```js
 * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs'
 * base64urlnopad.decode('Eqs');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));
/**
 * base58: base64 without ambigous characters +, /, 0, O, I, l.
 * Quadratic (O(n^2)) - so, can't be used on large inputs.
 * @example
 * ```js
 * base58.decode('01abcdef');
 * // => '3UhJW'
 * ```
 */
exports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
/**
 * base58: flickr version. Check out `base58`.
 */
exports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
/**
 * base58: XRP version. Check out `base58`.
 */
exports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
/**
 * base58: XMR version. Check out `base58`.
 * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
 * Block encoding significantly reduces quadratic complexity of base58.
 */
exports.base58xmr = {
    encode(data) {
        let res = '';
        for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
                if (block[j] !== 0)
                    throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    },
};
/**
 * Method, which creates base58check encoder.
 * Requires function, calculating sha256.
 */
const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
exports.createBase58check = createBase58check;
/**
 * Use `createBase58check` instead.
 * @deprecated
 */
exports.base58check = exports.createBase58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);
    for (let v of words)
        chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        astr('bech32.encode prefix', prefix);
        if (isBytes(words))
            words = Array.from(words);
        anumArr('bech32.encode', words);
        const plen = prefix.length;
        if (plen === 0)
            throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        astr('bech32.decode input', str);
        const slen = str.length;
        if (slen < 8 || (limit !== false && slen > limit))
            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6)
            throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
    }
    function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
    }
    return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords,
    };
}
/**
 * bech32 from BIP 173. Operates on words.
 * For high-level, check out scure-btc-signer:
 * https://github.com/paulmillr/scure-btc-signer.
 */
exports.bech32 = genBech32('bech32');
/**
 * bech32m from BIP 350. Operates on words.
 * It was to mitigate `bech32` weaknesses.
 * For high-level, check out scure-btc-signer:
 * https://github.com/paulmillr/scure-btc-signer.
 */
exports.bech32m = genBech32('bech32m');
/**
 * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.
 * @example
 * ```js
 * const b = utf8.decode("hey"); // => new Uint8Array([ 104, 101, 121 ])
 * const str = utf8.encode(b); // "hey"
 * ```
 */
exports.utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str),
};
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
// prettier-ignore
const hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&
    typeof Uint8Array.fromHex === 'function')();
// prettier-ignore
const hexBuiltin = {
    encode(data) { abytes(data); return data.toHex(); },
    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },
};
/**
 * hex string decoder. Uses built-in function, when available.
 * @example
 * ```js
 * const b = hex.decode("0102ff"); // => new Uint8Array([ 1, 2, 255 ])
 * const str = hex.encode(b); // "0102ff"
 * ```
 */
exports.hex = hasHexBuiltin
    ? hexBuiltin
    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {
        if (typeof s !== 'string' || s.length % 2 !== 0)
            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
        return s.toLowerCase();
    }));
// prettier-ignore
const CODERS = {
    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
/** @deprecated */
const bytesToString = (type, bytes) => {
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (!isBytes(bytes))
        throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
/** @deprecated */
exports.str = exports.bytesToString; // as in python, but for bytes only
/** @deprecated */
const stringToBytes = (type, str) => {
    if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (typeof str !== 'string')
        throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
/** @deprecated */
exports.bytes = exports.stringToBytes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2452:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HDKey = exports.HARDENED_OFFSET = void 0;
/**
 * @module BIP32 hierarchical deterministic (HD) wallets over secp256k1.
 * @example
 * ```js
 * import { HDKey } from "@scure/bip32";
 * const hdkey1 = HDKey.fromMasterSeed(seed);
 * const hdkey2 = HDKey.fromExtendedKey(base58key);
 * const hdkey3 = HDKey.fromJSON({ xpriv: string });
 *
 * // props
 * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];
 * console.log(hdkey2.privateKey, hdkey2.publicKey);
 * console.log(hdkey3.derive("m/0/2147483647'/1"));
 * const sig = hdkey3.sign(hash);
 * hdkey3.verify(hash, sig);
 * ```
 */
/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const modular_1 = __nccwpck_require__(6557);
const secp256k1_1 = __nccwpck_require__(6379);
const hmac_1 = __nccwpck_require__(9149);
const legacy_1 = __nccwpck_require__(7443);
const sha2_1 = __nccwpck_require__(8872);
const utils_1 = __nccwpck_require__(6161);
const base_1 = __nccwpck_require__(9891);
const Point = secp256k1_1.secp256k1.ProjectivePoint;
const base58check = (0, base_1.createBase58check)(sha2_1.sha256);
function bytesToNumber(bytes) {
    (0, utils_1.abytes)(bytes);
    const h = bytes.length === 0 ? '0' : (0, utils_1.bytesToHex)(bytes);
    return BigInt('0x' + h);
}
function numberToBytes(num) {
    if (typeof num !== 'bigint')
        throw new Error('bigint expected');
    return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, '0'));
}
const MASTER_SECRET = (0, utils_1.utf8ToBytes)('Bitcoin seed');
// Bitcoin hardcoded by default
const BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };
exports.HARDENED_OFFSET = 0x80000000;
const hash160 = (data) => (0, legacy_1.ripemd160)((0, sha2_1.sha256)(data));
const fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);
const toU32 = (n) => {
    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
        throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);
    }
    const buf = new Uint8Array(4);
    (0, utils_1.createView)(buf).setUint32(0, n, false);
    return buf;
};
class HDKey {
    get fingerprint() {
        if (!this.pubHash) {
            throw new Error('No publicKey set!');
        }
        return fromU32(this.pubHash);
    }
    get identifier() {
        return this.pubHash;
    }
    get pubKeyHash() {
        return this.pubHash;
    }
    get privateKey() {
        return this.privKeyBytes || null;
    }
    get publicKey() {
        return this.pubKey || null;
    }
    get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
            throw new Error('No private key');
        }
        return base58check.encode(this.serialize(this.versions.private, (0, utils_1.concatBytes)(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
        if (!this.pubKey) {
            throw new Error('No public key');
        }
        return base58check.encode(this.serialize(this.versions.public, this.pubKey));
    }
    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        (0, utils_1.abytes)(seed);
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
            throw new Error('HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +
                seed.length);
        }
        const I = (0, hmac_1.hmac)(sha2_1.sha512, MASTER_SECRET, seed);
        return new HDKey({
            versions,
            chainCode: I.slice(32),
            privateKey: I.slice(0, 32),
        });
    }
    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
        const keyBuffer = base58check.decode(base58key);
        const keyView = (0, utils_1.createView)(keyBuffer);
        const version = keyView.getUint32(0, false);
        const opt = {
            versions,
            depth: keyBuffer[4],
            parentFingerprint: keyView.getUint32(5, false),
            index: keyView.getUint32(9, false),
            chainCode: keyBuffer.slice(13, 45),
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version !== versions[isPriv ? 'private' : 'public']) {
            throw new Error('Version mismatch');
        }
        if (isPriv) {
            return new HDKey({ ...opt, privateKey: key.slice(1) });
        }
        else {
            return new HDKey({ ...opt, publicKey: key });
        }
    }
    static fromJSON(json) {
        return HDKey.fromExtendedKey(json.xpriv);
    }
    constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== 'object') {
            throw new Error('HDKey.constructor must not be called directly');
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode || null;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
            if (this.parentFingerprint || this.index) {
                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');
            }
        }
        if (opt.publicKey && opt.privateKey) {
            throw new Error('HDKey: publicKey and privateKey at same time.');
        }
        if (opt.privateKey) {
            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
                throw new Error('Invalid private key');
            }
            this.privKey =
                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);
            this.privKeyBytes = numberToBytes(this.privKey);
            this.pubKey = secp256k1_1.secp256k1.getPublicKey(opt.privateKey, true);
        }
        else if (opt.publicKey) {
            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point
        }
        else {
            throw new Error('HDKey: no public or private key provided');
        }
        this.pubHash = hash160(this.pubKey);
    }
    derive(path) {
        if (!/^[mM]'?/.test(path)) {
            throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
            return this;
        }
        const parts = path.replace(/^[mM]'?\//, '').split('/');
        // tslint:disable-next-line
        let child = this;
        for (const c of parts) {
            const m = /^(\d+)('?)$/.exec(c);
            const m1 = m && m[1];
            if (!m || m.length !== 3 || typeof m1 !== 'string')
                throw new Error('invalid child index: ' + c);
            let idx = +m1;
            if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) {
                throw new Error('Invalid index');
            }
            // hardened key
            if (m[2] === "'") {
                idx += exports.HARDENED_OFFSET;
            }
            child = child.deriveChild(idx);
        }
        return child;
    }
    deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
            throw new Error('No publicKey or chainCode set');
        }
        let data = toU32(index);
        if (index >= exports.HARDENED_OFFSET) {
            // Hardened
            const priv = this.privateKey;
            if (!priv) {
                throw new Error('Could not derive hardened child key');
            }
            // Hardened child: 0x00 || ser256(kpar) || ser32(index)
            data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);
        }
        else {
            // Normal child: serP(point(kpar)) || ser32(index)
            data = (0, utils_1.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha2_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) {
            throw new Error('Tweak bigger than curve order');
        }
        const opt = {
            versions: this.versions,
            chainCode,
            depth: this.depth + 1,
            parentFingerprint: this.fingerprint,
            index,
        };
        try {
            // Private parent key -> private child key
            if (this.privateKey) {
                const added = (0, modular_1.mod)(this.privKey + childTweak, secp256k1_1.secp256k1.CURVE.n);
                if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {
                    throw new Error('The tweak was out of range or the resulted private key is invalid');
                }
                opt.privateKey = added;
            }
            else {
                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
                // Cryptographically impossible: hmac-sha512 preimage would need to be found
                if (added.equals(Point.ZERO)) {
                    throw new Error('The tweak was equal to negative P, which made the result key invalid');
                }
                opt.publicKey = added.toRawBytes(true);
            }
            return new HDKey(opt);
        }
        catch (err) {
            return this.deriveChild(index + 1);
        }
    }
    sign(hash) {
        if (!this.privateKey) {
            throw new Error('No privateKey set!');
        }
        (0, utils_1.abytes)(hash, 32);
        return secp256k1_1.secp256k1.sign(hash, this.privKey).toCompactRawBytes();
    }
    verify(hash, signature) {
        (0, utils_1.abytes)(hash, 32);
        (0, utils_1.abytes)(signature, 64);
        if (!this.publicKey) {
            throw new Error('No publicKey set!');
        }
        let sig;
        try {
            sig = secp256k1_1.secp256k1.Signature.fromCompact(signature);
        }
        catch (error) {
            return false;
        }
        return secp256k1_1.secp256k1.verify(sig, hash, this.publicKey);
    }
    wipePrivateData() {
        this.privKey = undefined;
        if (this.privKeyBytes) {
            this.privKeyBytes.fill(0);
            this.privKeyBytes = undefined;
        }
        return this;
    }
    toJSON() {
        return {
            xpriv: this.privateExtendedKey,
            xpub: this.publicExtendedKey,
        };
    }
    serialize(version, key) {
        if (!this.chainCode) {
            throw new Error('No chainCode set');
        }
        (0, utils_1.abytes)(key, 33);
        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
        return (0, utils_1.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
}
exports.HDKey = HDKey;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5587:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


/**
 * Audited & minimal JS implementation of
 * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
 * @module
 * @example
```js
import * as bip39 from '@scure/bip39';
import { wordlist } from '@scure/bip39/wordlists/english';
const mn = bip39.generateMnemonic(wordlist);
console.log(mn);
const ent = bip39.mnemonicToEntropy(mn, wordlist)
bip39.entropyToMnemonic(ent, wordlist);
bip39.validateMnemonic(mn, wordlist);
await bip39.mnemonicToSeed(mn, 'password');
bip39.mnemonicToSeedSync(mn, 'password');

// Wordlists
import { wordlist as czech } from '@scure/bip39/wordlists/czech';
import { wordlist as english } from '@scure/bip39/wordlists/english';
import { wordlist as french } from '@scure/bip39/wordlists/french';
import { wordlist as italian } from '@scure/bip39/wordlists/italian';
import { wordlist as japanese } from '@scure/bip39/wordlists/japanese';
import { wordlist as korean } from '@scure/bip39/wordlists/korean';
import { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';
import { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';
import { wordlist as spanish } from '@scure/bip39/wordlists/spanish';
import { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';
```
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateMnemonic = generateMnemonic;
exports.mnemonicToEntropy = mnemonicToEntropy;
exports.entropyToMnemonic = entropyToMnemonic;
exports.validateMnemonic = validateMnemonic;
exports.mnemonicToSeed = mnemonicToSeed;
exports.mnemonicToSeedSync = mnemonicToSeedSync;
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const pbkdf2_1 = __nccwpck_require__(5058);
const sha2_1 = __nccwpck_require__(8872);
const utils_1 = __nccwpck_require__(6161);
const base_1 = __nccwpck_require__(9891);
// Japanese wordlist
const isJapanese = (wordlist) => wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093';
// Normalization replaces equivalent sequences of characters
// so that any two texts that are equivalent will be reduced
// to the same sequence of code points, called the normal form of the original text.
// https://tonsky.me/blog/unicode/#why-is-a----
function nfkd(str) {
    if (typeof str !== 'string')
        throw new TypeError('invalid mnemonic type: ' + typeof str);
    return str.normalize('NFKD');
}
function normalize(str) {
    const norm = nfkd(str);
    const words = norm.split(' ');
    if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error('Invalid mnemonic');
    return { nfkd: norm, words };
}
function aentropy(ent) {
    (0, utils_1.abytes)(ent, 16, 20, 24, 28, 32);
}
/**
 * Generate x random words. Uses Cryptographically-Secure Random Number Generator.
 * @param wordlist imported wordlist for specific language
 * @param strength mnemonic strength 128-256 bits
 * @example
 * generateMnemonic(wordlist, 128)
 * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
 */
function generateMnemonic(wordlist, strength = 128) {
    (0, utils_1.anumber)(strength);
    if (strength % 32 !== 0 || strength > 256)
        throw new TypeError('Invalid entropy');
    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
}
const calcChecksum = (entropy) => {
    // Checksum is ent.length/4 bits long
    const bitsLeft = 8 - entropy.length / 4;
    // Zero rightmost "bitsLeft" bits in byte
    // For example: bitsLeft=4 val=10111101 -> 10110000
    return new Uint8Array([((0, sha2_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);
};
function getCoder(wordlist) {
    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')
        throw new Error('Wordlist: expected array of 2048 strings');
    wordlist.forEach((i) => {
        if (typeof i !== 'string')
            throw new Error('wordlist: non-string element: ' + i);
    });
    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
}
/**
 * Reversible: Converts mnemonic string to raw entropy in form of byte array.
 * @param mnemonic 12-24 words
 * @param wordlist imported wordlist for specific language
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * mnemonicToEntropy(mnem, wordlist)
 * // Produces
 * new Uint8Array([
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
 * ])
 */
function mnemonicToEntropy(mnemonic, wordlist) {
    const { words } = normalize(mnemonic);
    const entropy = getCoder(wordlist).decode(words);
    aentropy(entropy);
    return entropy;
}
/**
 * Reversible: Converts raw entropy in form of byte array to mnemonic string.
 * @param entropy byte array
 * @param wordlist imported wordlist for specific language
 * @returns 12-24 words
 * @example
 * const ent = new Uint8Array([
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
 * ]);
 * entropyToMnemonic(ent, wordlist);
 * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
 */
function entropyToMnemonic(entropy, wordlist) {
    aentropy(entropy);
    const words = getCoder(wordlist).encode(entropy);
    return words.join(isJapanese(wordlist) ? '\u3000' : ' ');
}
/**
 * Validates mnemonic for being 12-24 words contained in `wordlist`.
 */
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
const psalt = (passphrase) => nfkd('mnemonic' + passphrase);
/**
 * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
 * @param mnemonic 12-24 words
 * @param passphrase string that will additionally protect the key
 * @returns 64 bytes of key data
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * await mnemonicToSeed(mnem, 'password');
 * // new Uint8Array([...64 bytes])
 */
function mnemonicToSeed(mnemonic, passphrase = '') {
    return (0, pbkdf2_1.pbkdf2Async)(sha2_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}
/**
 * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
 * @param mnemonic 12-24 words
 * @param passphrase string that will additionally protect the key
 * @returns 64 bytes of key data
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * mnemonicToSeedSync(mnem, 'password');
 * // new Uint8Array([...64 bytes])
 */
function mnemonicToSeedSync(mnemonic, passphrase = '') {
    return (0, pbkdf2_1.pbkdf2)(sha2_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}


/***/ }),

/***/ 2502:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wordlist = void 0;
exports.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split('\n');


/***/ }),

/***/ 651:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Normalize a string, number array, or Uint8Array to a string or Uint8Array.
 * Both node and noble lib functions accept these types.
 *
 * @param input - value to normalize
 */
function normalizeInput(input) {
    return Array.isArray(input) ? new Uint8Array(input) : input;
}
exports["default"] = normalizeInput;
//# sourceMappingURL=normalizeInput.js.map

/***/ }),

/***/ 9230:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const normalizeInput_1 = __importDefault(__nccwpck_require__(651));
/**
 * Wrap createHash from node to provide an interface that is isomorphic
 *
 * @param type - the hash name
 * @param fn - {createHash} the hash factory
 */
function wrapCryptoCreateHash(type, fn) {
    function hashFn(input) {
        return fn(type).update((0, normalizeInput_1.default)(input)).digest();
    }
    hashFn.create = () => {
        const hash = fn(type);
        return {
            update(input) {
                hash.update((0, normalizeInput_1.default)(input));
                return this;
            },
            digest() {
                return hash.digest();
            },
        };
    };
    return hashFn;
}
exports["default"] = wrapCryptoCreateHash;
//# sourceMappingURL=wrapCryptoCreateHash.js.map

/***/ }),

/***/ 8841:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = void 0;
const crypto_1 = __nccwpck_require__(6113);
const wrapCryptoCreateHash_1 = __importDefault(__nccwpck_require__(9230));
/**
 * Wrap node's native ripemd160 implementation in HashFn
 */
exports.ripemd160 = (0, wrapCryptoCreateHash_1.default)('ripemd160', crypto_1.createHash);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8093:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha256 = void 0;
const crypto_1 = __nccwpck_require__(6113);
const wrapCryptoCreateHash_1 = __importDefault(__nccwpck_require__(9230));
/**
 * Wrap node's native sha256 implementation in HashFn
 */
exports.sha256 = (0, wrapCryptoCreateHash_1.default)('sha256', crypto_1.createHash);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 65:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha512 = void 0;
const crypto_1 = __nccwpck_require__(6113);
const wrapCryptoCreateHash_1 = __importDefault(__nccwpck_require__(9230));
/**
 * Wrap node's native sha512 implementation in HashFn
 */
exports.sha512 = (0, wrapCryptoCreateHash_1.default)('sha512', crypto_1.createHash);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3617:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringToHex = exports.hexToString = exports.randomBytes = exports.hexToBytes = exports.bytesToHex = void 0;
const crypto_1 = __nccwpck_require__(6113);
const shared_1 = __nccwpck_require__(5565);
const OriginalBuffer = Symbol('OriginalBuffer');
/**
 * Converts a Node.js Buffer to a Uint8Array for uniform behavior with browser implementations.
 *
 * Choices:
 * 1. Directly returning the Buffer:
 *    - Operation: Return Buffer as is (a Buffer *IS* an instanceof Uint8Array).
 *    - Pros: Most memory and performance efficient.
 *    - Cons: Violates strict Uint8Array typing and may lead to issues where Buffer-specific features are [ab]used.
 *
 * 2. Using `new Uint8Array(buffer)` or `Uint8Array.from(buffer)`:
 *    - Operation: Copies the buffer's data into a new Uint8Array.
 *    - Pros: Ensures data isolation; memory-safe.
 *    - Cons: Less performant due to data duplication.
 *
 * 3. Using buf.buffer slice:
 *    - Operation: Shares memory between Buffer and Uint8Array.
 *    - Pros: Performant.
 *    - Cons: Risks with shared memory and potential for invalid references.
 *
 * 4. Using buf.buffer slice and keeping a Buffer reference for ownership semantics:
 *    - Operation: Shares memory and associates the original Buffer with the resulting Uint8Array.
 *    - Pros: Performant while ensuring the original Buffer isn't garbage collected.
 *    - Cons: Risks with shared memory but mitigates potential for invalid references.
 *
 * The chosen method (4) prioritizes performance by sharing memory while ensuring buffer ownership.
 *
 * @param {Buffer} buffer - The Node.js Buffer to convert.
 * @returns {Uint8Array} Resulting Uint8Array sharing the same memory as the Buffer and maintaining a reference to it.
 */
function toUint8Array(buffer) {
    const u8Array = new Uint8Array(buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength));
    u8Array[OriginalBuffer] = buffer;
    return u8Array;
}
/* eslint-disable func-style -- Typed to ensure uniformity between node and browser implementations and docs */
const bytesToHex = (bytes) => {
    const buf = Buffer.from(bytes);
    return buf.toString('hex').toUpperCase();
};
exports.bytesToHex = bytesToHex;
const hexToBytes = (hex) => {
    if (!shared_1.HEX_REGEX.test(hex)) {
        throw new Error('Invalid hex string');
    }
    return toUint8Array(Buffer.from(hex, 'hex'));
};
exports.hexToBytes = hexToBytes;
const randomBytes = (size) => {
    return toUint8Array((0, crypto_1.randomBytes)(size));
};
exports.randomBytes = randomBytes;
const hexToString = (hex, encoding = 'utf8') => {
    if (!shared_1.HEX_REGEX.test(hex)) {
        throw new Error('Invalid hex string');
    }
    return new TextDecoder(encoding).decode((0, exports.hexToBytes)(hex));
};
exports.hexToString = hexToString;
const stringToHex = (string) => {
    return (0, exports.bytesToHex)(new TextEncoder().encode(string));
};
exports.stringToHex = stringToHex;
/* eslint-enable func-style */
__exportStar(__nccwpck_require__(5565), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5565:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.equal = exports.concat = exports.HEX_REGEX = void 0;
const utils_1 = __nccwpck_require__(6161);
exports.HEX_REGEX = /^[A-F0-9]*$/iu;
function concat(views) {
    return (0, utils_1.concatBytes)(...views);
}
exports.concat = concat;
function equal(buf1, buf2) {
    if (buf1.byteLength !== buf2.byteLength) {
        return false;
    }
    const dv1 = new Int8Array(buf1);
    const dv2 = new Int8Array(buf2);
    for (let i = 0; i !== buf1.byteLength; i++) {
        if (dv1[i] !== dv2[i]) {
            return false;
        }
    }
    return true;
}
exports.equal = equal;
//# sourceMappingURL=shared.js.map

/***/ }),

/***/ 5634:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ws_1 = __importDefault(__nccwpck_require__(8867));
class Socket extends ws_1.default {
    constructor(...args) {
        super(args[0], args[1], args[2]);
        this.setMaxListeners(Infinity);
    }
}
exports["default"] = Socket;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7558:
/***/ (function(module) {

;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.3.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, -1);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, 1);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // The index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ¬±0 if x is ¬±0 or y is ¬±Infinity, or return ¬±Infinity as y is ¬±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne + (id === 2 && e > ne);
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    // If any number is NaN, return NaN.
    function maxOrMin(args, n) {
      var k, y,
        i = 1,
        x = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        y = new BigNumber(args[i]);
        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
          x = y;
        }
      }

      return x;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ¬±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = mathfloor(n / pows10[d - j - 1] % 10);
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ¬±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ¬±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ¬±Infinity, ¬±0 or ¬±1, or n is ¬±Infinity, NaN or ¬±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ¬±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ¬±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ¬±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ¬±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ¬±0, else return ¬±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ¬±Infinity or ¬±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ¬±Infinity if either is ¬±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ¬±0 if either is ¬±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ¬±Infinity if either ¬±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ¬±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if ( true && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);


/***/ }),

/***/ 7218:
/***/ ((module) => {



/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
const mask = (source, mask, output, offset, length) => {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
};

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
const unmask = (buffer, mask) => {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
};

module.exports = { mask, unmask };


/***/ }),

/***/ 3352:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



try {
  module.exports = __nccwpck_require__(4090)(__dirname);
} catch (e) {
  module.exports = __nccwpck_require__(7218);
}


/***/ }),

/***/ 1848:
/***/ ((module) => {



var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 4090:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const runtimeRequire =  true ? eval("require") : 0 // eslint-disable-line
if (typeof runtimeRequire.addon === 'function') { // if the platform supports native resolving prefer that
  module.exports = runtimeRequire.addon.bind(runtimeRequire)
} else { // else use the runtime version here
  module.exports = __nccwpck_require__(3403)
}


/***/ }),

/***/ 3403:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var fs = __nccwpck_require__(7147)
var path = __nccwpck_require__(1017)
var os = __nccwpck_require__(9563)

// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
var runtimeRequire =  true ? eval("require") : 0 // eslint-disable-line

var vars = (process.config && process.config.variables) || {}
var prebuildsOnly = !!process.env.PREBUILDS_ONLY
var abi = process.versions.modules // TODO: support old node where this is undef
var runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')

var arch = process.env.npm_config_arch || os.arch()
var platform = process.env.npm_config_platform || os.platform()
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''
var uv = (process.versions.uv || '').split('.')[0]

module.exports = load

function load (dir) {
  return runtimeRequire(load.resolve(dir))
}

load.resolve = load.path = function (dir) {
  dir = path.resolve(dir || '.')

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)
    if (release) return release

    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)
    if (debug) return debug
  }

  var prebuild = resolve(dir)
  if (prebuild) return prebuild

  var nearby = resolve(path.dirname(process.execPath))
  if (nearby) return nearby

  var target = [
    'platform=' + platform,
    'arch=' + arch,
    'runtime=' + runtime,
    'abi=' + abi,
    'uv=' + uv,
    armv ? 'armv=' + armv : '',
    'libc=' + libc,
    'node=' + process.versions.node,
    process.versions.electron ? 'electron=' + process.versions.electron : '',
     true ? 'webpack=true' : 0 // eslint-disable-line
  ].filter(Boolean).join(' ')

  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n')

  function resolve (dir) {
    // Find matching "prebuilds/<platform>-<arch>" directory
    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)
    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]
    if (!tuple) return

    // Find most specific flavor first
    var prebuilds = path.join(dir, 'prebuilds', tuple.name)
    var parsed = readdirSync(prebuilds).map(parseTags)
    var candidates = parsed.filter(matchTags(runtime, abi))
    var winner = candidates.sort(compareTags(runtime))[0]
    if (winner) return path.join(prebuilds, winner.file)
  }
}

function readdirSync (dir) {
  try {
    return fs.readdirSync(dir)
  } catch (err) {
    return []
  }
}

function getFirst (dir, filter) {
  var files = readdirSync(dir).filter(filter)
  return files[0] && path.join(dir, files[0])
}

function matchBuild (name) {
  return /\.node$/.test(name)
}

function parseTuple (name) {
  // Example: darwin-x64+arm64
  var arr = name.split('-')
  if (arr.length !== 2) return

  var platform = arr[0]
  var architectures = arr[1].split('+')

  if (!platform) return
  if (!architectures.length) return
  if (!architectures.every(Boolean)) return

  return { name, platform, architectures }
}

function matchTuple (platform, arch) {
  return function (tuple) {
    if (tuple == null) return false
    if (tuple.platform !== platform) return false
    return tuple.architectures.includes(arch)
  }
}

function compareTuples (a, b) {
  // Prefer single-arch prebuilds over multi-arch
  return a.architectures.length - b.architectures.length
}

function parseTags (file) {
  var arr = file.split('.')
  var extension = arr.pop()
  var tags = { file: file, specificity: 0 }

  if (extension !== 'node') return

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i]

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag
    } else if (tag === 'napi') {
      tags.napi = true
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3)
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2)
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4)
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag
    } else {
      continue
    }

    tags.specificity++
  }

  return tags
}

function matchTags (runtime, abi) {
  return function (tags) {
    if (tags == null) return false
    if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false
    if (tags.abi && tags.abi !== abi && !tags.napi) return false
    if (tags.uv && tags.uv !== uv) return false
    if (tags.armv && tags.armv !== armv) return false
    if (tags.libc && tags.libc !== libc) return false

    return true
  }
}

function runtimeAgnostic (tags) {
  return tags.runtime === 'node' && tags.napi
}

function compareTags (runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1
    } else {
      return 0
    }
  }
}

function isNwjs () {
  return !!(process.versions && process.versions.nw)
}

function isElectron () {
  if (process.versions && process.versions.electron) return true
  if (process.env.ELECTRON_RUN_AS_NODE) return true
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
}

function isAlpine (platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release')
}

// Exposed for unit tests
// TODO: move to lib
load.parseTags = parseTags
load.matchTags = matchTags
load.compareTags = compareTags
load.parseTuple = parseTuple
load.matchTuple = matchTuple
load.compareTuples = compareTuples


/***/ }),

/***/ 579:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
const utils_1 = __nccwpck_require__(3617);
const xrp_codec_1 = __nccwpck_require__(2303);
Object.defineProperty(exports, "codec", ({ enumerable: true, get: function () { return xrp_codec_1.codec; } }));
Object.defineProperty(exports, "encodeSeed", ({ enumerable: true, get: function () { return xrp_codec_1.encodeSeed; } }));
Object.defineProperty(exports, "decodeSeed", ({ enumerable: true, get: function () { return xrp_codec_1.decodeSeed; } }));
Object.defineProperty(exports, "encodeAccountID", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountID; } }));
Object.defineProperty(exports, "decodeAccountID", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountID; } }));
Object.defineProperty(exports, "encodeNodePublic", ({ enumerable: true, get: function () { return xrp_codec_1.encodeNodePublic; } }));
Object.defineProperty(exports, "decodeNodePublic", ({ enumerable: true, get: function () { return xrp_codec_1.decodeNodePublic; } }));
Object.defineProperty(exports, "encodeAccountPublic", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountPublic; } }));
Object.defineProperty(exports, "decodeAccountPublic", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountPublic; } }));
Object.defineProperty(exports, "isValidClassicAddress", ({ enumerable: true, get: function () { return xrp_codec_1.isValidClassicAddress; } }));
const PREFIX_BYTES = {
    // 5, 68
    main: Uint8Array.from([0x05, 0x44]),
    // 4, 147
    test: Uint8Array.from([0x04, 0x93]),
};
const MAX_32_BIT_UNSIGNED_INT = 4294967295;
function classicAddressToXAddress(classicAddress, tag, test) {
    const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);
    return encodeXAddress(accountId, tag, test);
}
exports.classicAddressToXAddress = classicAddressToXAddress;
function encodeXAddress(accountId, tag, test) {
    if (accountId.length !== 20) {
        // RIPEMD160 is 160 bits = 20 bytes
        throw new Error('Account ID must be 20 bytes');
    }
    if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {
        throw new Error('Invalid tag');
    }
    const theTag = tag || 0;
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake
    const flag = tag === false || tag == null ? 0 : 1;
    /* eslint-disable no-bitwise ---
     * need to use bitwise operations here */
    const bytes = (0, utils_1.concat)([
        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
        accountId,
        Uint8Array.from([
            // 0x00 if no tag, 0x01 if 32-bit tag
            flag,
            // first byte
            theTag & 0xff,
            // second byte
            (theTag >> 8) & 0xff,
            // third byte
            (theTag >> 16) & 0xff,
            // fourth byte
            (theTag >> 24) & 0xff,
            0,
            0,
            0,
            // four zero bytes (reserved for 64-bit tags)
            0,
        ]),
    ]);
    /* eslint-enable no-bitwise */
    return xrp_codec_1.codec.encodeChecked(bytes);
}
exports.encodeXAddress = encodeXAddress;
function xAddressToClassicAddress(xAddress) {
    /* eslint-disable @typescript-eslint/naming-convention --
     * TODO 'test' should be something like 'isTest', do this later
     */
    const { accountId, tag, test } = decodeXAddress(xAddress);
    /* eslint-enable @typescript-eslint/naming-convention */
    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);
    return {
        classicAddress,
        tag,
        test,
    };
}
exports.xAddressToClassicAddress = xAddressToClassicAddress;
function decodeXAddress(xAddress) {
    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
    /* eslint-disable @typescript-eslint/naming-convention --
     * TODO 'test' should be something like 'isTest', do this later
     */
    const test = isUint8ArrayForTestAddress(decoded);
    /* eslint-enable @typescript-eslint/naming-convention */
    const accountId = decoded.slice(2, 22);
    const tag = tagFromUint8Array(decoded);
    return {
        accountId,
        tag,
        test,
    };
}
exports.decodeXAddress = decodeXAddress;
function isUint8ArrayForTestAddress(buf) {
    const decodedPrefix = buf.slice(0, 2);
    if ((0, utils_1.equal)(PREFIX_BYTES.main, decodedPrefix)) {
        return false;
    }
    if ((0, utils_1.equal)(PREFIX_BYTES.test, decodedPrefix)) {
        return true;
    }
    throw new Error('Invalid X-address: bad prefix');
}
function tagFromUint8Array(buf) {
    const flag = buf[22];
    if (flag >= 2) {
        // No support for 64-bit tags at this time
        throw new Error('Unsupported X-address');
    }
    if (flag === 1) {
        // Little-endian to big-endian
        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;
    }
    if (flag !== 0) {
        throw new Error('flag must be zero to indicate no tag');
    }
    if (!(0, utils_1.equal)((0, utils_1.hexToBytes)('0000000000000000'), buf.slice(23, 23 + 8))) {
        throw new Error('remaining bytes must be zero');
    }
    return false;
}
function isValidXAddress(xAddress) {
    try {
        decodeXAddress(xAddress);
    }
    catch (_error) {
        return false;
    }
    return true;
}
exports.isValidXAddress = isValidXAddress;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6582:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concatArgs = exports.arrayEqual = void 0;
/**
 * Check whether two sequences (e.g. Arrays of numbers) are equal.
 *
 * @param arr1 - One of the arrays to compare.
 * @param arr2 - The other array to compare.
 */
function arrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    return arr1.every((value, index) => value === arr2[index]);
}
exports.arrayEqual = arrayEqual;
/**
 * Check whether a value is a scalar
 *
 * @param val - The value to check.
 */
function isScalar(val) {
    return typeof val === 'number';
}
/**
 * Concatenate all `arguments` into a single array. Each argument can be either
 * a single element or a sequence, which has a `length` property and supports
 * element retrieval via sequence[ix].
 *
 * > concatArgs(1, [2, 3], Uint8Array.from([4,5]), new Uint8Array([6, 7]));
 * [1,2,3,4,5,6,7]
 *
 * @param args - Concatenate of these args into a single array.
 * @returns Array of concatenated arguments
 */
function concatArgs(...args) {
    return args.flatMap((arg) => {
        return isScalar(arg) ? [arg] : Array.from(arg);
    });
}
exports.concatArgs = concatArgs;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 2303:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


/**
 * Codec class
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
const base_1 = __nccwpck_require__(9891);
const sha256_1 = __nccwpck_require__(8093);
const utils_1 = __nccwpck_require__(6582);
class Codec {
    constructor(options) {
        this._sha256 = options.sha256;
        this._codec = base_1.base58xrp;
    }
    /**
     * Encoder.
     *
     * @param bytes - Uint8Array of data to encode.
     * @param opts - Options object including the version bytes and the expected length of the data to encode.
     */
    encode(bytes, opts) {
        const versions = opts.versions;
        return this._encodeVersioned(bytes, versions, opts.expectedLength);
    }
    /**
     * Decoder.
     *
     * @param base58string - Base58Check-encoded string to decode.
     * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
     */
    /* eslint-disable max-lines-per-function --
     * TODO refactor */
    decode(base58string, opts) {
        var _a;
        const versions = opts.versions;
        const types = opts.versionTypes;
        const withoutSum = this.decodeChecked(base58string);
        if (versions.length > 1 && !opts.expectedLength) {
            throw new Error('expectedLength is required because there are >= 2 possible versions');
        }
        const versionLengthGuess = typeof versions[0] === 'number' ? 1 : versions[0].length;
        const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;
        const versionBytes = withoutSum.slice(0, -payloadLength);
        const payload = withoutSum.slice(-payloadLength);
        for (let i = 0; i < versions.length; i++) {
            /* eslint-disable @typescript-eslint/consistent-type-assertions --
             * TODO refactor */
            const version = Array.isArray(versions[i])
                ? versions[i]
                : [versions[i]];
            if ((0, utils_1.arrayEqual)(versionBytes, version)) {
                return {
                    version,
                    bytes: payload,
                    type: types ? types[i] : null,
                };
            }
            /* eslint-enable @typescript-eslint/consistent-type-assertions */
        }
        throw new Error('version_invalid: version bytes do not match any of the provided version(s)');
    }
    encodeChecked(bytes) {
        const check = this._sha256(this._sha256(bytes)).slice(0, 4);
        return this._encodeRaw(Uint8Array.from((0, utils_1.concatArgs)(bytes, check)));
    }
    decodeChecked(base58string) {
        const intArray = this._decodeRaw(base58string);
        if (intArray.byteLength < 5) {
            throw new Error('invalid_input_size: decoded data must have length >= 5');
        }
        if (!this._verifyCheckSum(intArray)) {
            throw new Error('checksum_invalid');
        }
        return intArray.slice(0, -4);
    }
    _encodeVersioned(bytes, versions, expectedLength) {
        if (!checkByteLength(bytes, expectedLength)) {
            throw new Error('unexpected_payload_length: bytes.length does not match expectedLength.' +
                ' Ensure that the bytes are a Uint8Array.');
        }
        return this.encodeChecked((0, utils_1.concatArgs)(versions, bytes));
    }
    _encodeRaw(bytes) {
        return this._codec.encode(Uint8Array.from(bytes));
    }
    /* eslint-enable max-lines-per-function */
    _decodeRaw(base58string) {
        return this._codec.decode(base58string);
    }
    _verifyCheckSum(bytes) {
        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);
        const checksum = bytes.slice(-4);
        return (0, utils_1.arrayEqual)(computed, checksum);
    }
}
/**
 * XRP codec
 */
// base58 encodings: https://xrpl.org/base58-encodings.html
// Account address (20 bytes)
const ACCOUNT_ID = 0;
// Account public key (33 bytes)
const ACCOUNT_PUBLIC_KEY = 0x23;
// 33; Seed value (for secret keys) (16 bytes)
const FAMILY_SEED = 0x21;
// 28; Validation public key (33 bytes)
const NODE_PUBLIC = 0x1c;
// [1, 225, 75]
const ED25519_SEED = [0x01, 0xe1, 0x4b];
const codecOptions = {
    sha256: sha256_1.sha256,
};
const codecWithXrpAlphabet = new Codec(codecOptions);
exports.codec = codecWithXrpAlphabet;
// entropy is a Uint8Array of size 16
// type is 'ed25519' or 'secp256k1'
function encodeSeed(entropy, type) {
    if (!checkByteLength(entropy, 16)) {
        throw new Error('entropy must have length 16');
    }
    const opts = {
        expectedLength: 16,
        // for secp256k1, use `FAMILY_SEED`
        versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],
    };
    // prefixes entropy with version bytes
    return codecWithXrpAlphabet.encode(entropy, opts);
}
exports.encodeSeed = encodeSeed;
function decodeSeed(seed, opts = {
    versionTypes: ['ed25519', 'secp256k1'],
    versions: [ED25519_SEED, FAMILY_SEED],
    expectedLength: 16,
}) {
    return codecWithXrpAlphabet.decode(seed, opts);
}
exports.decodeSeed = decodeSeed;
function encodeAccountID(bytes) {
    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeAccountID = encodeAccountID;
/* eslint-disable import/no-unused-modules ---
 * unclear why this is aliased but we should keep it in case someone else is
 * importing it with the aliased name */
exports.encodeAddress = encodeAccountID;
/* eslint-enable import/no-unused-modules */
function decodeAccountID(accountId) {
    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
    return codecWithXrpAlphabet.decode(accountId, opts).bytes;
}
exports.decodeAccountID = decodeAccountID;
/* eslint-disable import/no-unused-modules ---
 * unclear why this is aliased but we should keep it in case someone else is
 * importing it with the aliased name */
exports.decodeAddress = decodeAccountID;
/* eslint-enable import/no-unused-modules */
function decodeNodePublic(base58string) {
    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
}
exports.decodeNodePublic = decodeNodePublic;
function encodeNodePublic(bytes) {
    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeNodePublic = encodeNodePublic;
function encodeAccountPublic(bytes) {
    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeAccountPublic = encodeAccountPublic;
function decodeAccountPublic(base58string) {
    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
}
exports.decodeAccountPublic = decodeAccountPublic;
function isValidClassicAddress(address) {
    try {
        decodeAccountID(address);
    }
    catch (_error) {
        return false;
    }
    return true;
}
exports.isValidClassicAddress = isValidClassicAddress;
function checkByteLength(bytes, expectedLength) {
    return 'byteLength' in bytes
        ? bytes.byteLength === expectedLength
        : bytes.length === expectedLength;
}
//# sourceMappingURL=xrp-codec.js.map

/***/ }),

/***/ 1551:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;
const ripple_address_codec_1 = __nccwpck_require__(579);
Object.defineProperty(exports, "decodeSeed", ({ enumerable: true, get: function () { return ripple_address_codec_1.decodeSeed; } }));
const ripemd160_1 = __nccwpck_require__(8841);
const sha256_1 = __nccwpck_require__(8093);
const utils_1 = __nccwpck_require__(3617);
const utils_2 = __nccwpck_require__(9585);
const Sha512_1 = __importDefault(__nccwpck_require__(7853));
const assert_1 = __importDefault(__nccwpck_require__(4101));
const getAlgorithmFromKey_1 = __nccwpck_require__(408);
const secp256k1_1 = __importDefault(__nccwpck_require__(1071));
const ed25519_1 = __importDefault(__nccwpck_require__(409));
function getSigningScheme(algorithm) {
    const schemes = { 'ecdsa-secp256k1': secp256k1_1.default, ed25519: ed25519_1.default };
    return schemes[algorithm];
}
function generateSeed(options = {}) {
    assert_1.default.ok(!options.entropy || options.entropy.length >= 16, 'entropy too short');
    const entropy = options.entropy
        ? options.entropy.slice(0, 16)
        : (0, utils_1.randomBytes)(16);
    const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';
    return (0, ripple_address_codec_1.encodeSeed)(entropy, type);
}
exports.generateSeed = generateSeed;
function deriveKeypair(seed, options) {
    var _a;
    const decoded = (0, ripple_address_codec_1.decodeSeed)(seed);
    const proposedAlgorithm = (_a = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a !== void 0 ? _a : decoded.type;
    const algorithm = proposedAlgorithm === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';
    const scheme = getSigningScheme(algorithm);
    const keypair = scheme.deriveKeypair(decoded.bytes, options);
    const messageToVerify = Sha512_1.default.half('This test message should verify.');
    const signature = scheme.sign(messageToVerify, keypair.privateKey);
    /* istanbul ignore if */
    if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {
        throw new Error('derived keypair did not generate verifiable signature');
    }
    return keypair;
}
exports.deriveKeypair = deriveKeypair;
function sign(messageHex, privateKey) {
    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);
    return getSigningScheme(algorithm).sign((0, utils_1.hexToBytes)(messageHex), privateKey);
}
exports.sign = sign;
function verify(messageHex, signature, publicKey) {
    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);
    return getSigningScheme(algorithm).verify((0, utils_1.hexToBytes)(messageHex), signature, publicKey);
}
exports.verify = verify;
function computePublicKeyHash(publicKeyBytes) {
    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));
}
function deriveAddressFromBytes(publicKeyBytes) {
    return (0, ripple_address_codec_1.encodeAccountID)(computePublicKeyHash(publicKeyBytes));
}
function deriveAddress(publicKey) {
    return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));
}
exports.deriveAddress = deriveAddress;
function deriveNodeAddress(publicKey) {
    const generatorBytes = (0, ripple_address_codec_1.decodeNodePublic)(publicKey);
    const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(generatorBytes);
    return deriveAddressFromBytes(accountPublicBytes);
}
exports.deriveNodeAddress = deriveNodeAddress;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 409:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ed25519_1 = __nccwpck_require__(9038);
const utils_1 = __nccwpck_require__(3617);
const assert_1 = __importDefault(__nccwpck_require__(4101));
const Sha512_1 = __importDefault(__nccwpck_require__(7853));
const ED_PREFIX = 'ED';
const ed25519 = {
    deriveKeypair(entropy) {
        const rawPrivateKey = Sha512_1.default.half(entropy);
        const privateKey = ED_PREFIX + (0, utils_1.bytesToHex)(rawPrivateKey);
        const publicKey = ED_PREFIX + (0, utils_1.bytesToHex)(ed25519_1.ed25519.getPublicKey(rawPrivateKey));
        return { privateKey, publicKey };
    },
    sign(message, privateKey) {
        assert_1.default.ok(message instanceof Uint8Array, 'message must be array of octets');
        assert_1.default.ok(privateKey.length === 66, 'private key must be 33 bytes including prefix');
        return (0, utils_1.bytesToHex)(ed25519_1.ed25519.sign(message, privateKey.slice(2)));
    },
    verify(message, signature, publicKey) {
        // Unlikely to be triggered as these are internal and guarded by getAlgorithmFromKey
        assert_1.default.ok(publicKey.length === 66, 'public key must be 33 bytes including prefix');
        return ed25519_1.ed25519.verify(signature, message, 
        // Remove the 0xED prefix
        publicKey.slice(2), 
        // By default, set zip215 to false for compatibility reasons.
        // ZIP 215 is a stricter Ed25519 signature verification scheme.
        // However, setting it to false adheres to the more commonly used
        // RFC8032 / NIST186-5 standards, making it compatible with systems
        // like the XRP Ledger.
        { zip215: false });
    },
};
exports["default"] = ed25519;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1071:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __nccwpck_require__(2210);
const secp256k1_1 = __nccwpck_require__(6379);
const utils_2 = __nccwpck_require__(3617);
const utils_3 = __nccwpck_require__(9585);
const assert_1 = __importDefault(__nccwpck_require__(4101));
const Sha512_1 = __importDefault(__nccwpck_require__(7853));
const SECP256K1_PREFIX = '00';
const secp256k1 = {
    deriveKeypair(entropy, options) {
        const derived = (0, utils_3.derivePrivateKey)(entropy, options);
        const privateKey = SECP256K1_PREFIX + (0, utils_2.bytesToHex)((0, utils_1.numberToBytesBE)(derived, 32));
        const publicKey = (0, utils_2.bytesToHex)(secp256k1_1.secp256k1.getPublicKey(derived, true));
        return { privateKey, publicKey };
    },
    sign(message, privateKey) {
        // Some callers pass the privateKey with the prefix, others without.
        // @noble/curves will throw if the key is not exactly 32 bytes, so we
        // normalize it before passing to the sign method.
        assert_1.default.ok((privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX)) ||
            privateKey.length === 64);
        const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;
        return secp256k1_1.secp256k1
            .sign(Sha512_1.default.half(message), normedPrivateKey, {
            // "Canonical" signatures
            lowS: true,
            // Would fail tests if signatures aren't deterministic
            extraEntropy: undefined,
        })
            .toDERHex(true)
            .toUpperCase();
    },
    verify(message, signature, publicKey) {
        const decoded = secp256k1_1.secp256k1.Signature.fromDER(signature);
        return secp256k1_1.secp256k1.verify(decoded, Sha512_1.default.half(message), publicKey);
    },
};
exports["default"] = secp256k1;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9585:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;
const secp256k1_1 = __nccwpck_require__(6379);
const Sha512_1 = __importDefault(__nccwpck_require__(7853));
const ZERO = BigInt(0);
function deriveScalar(bytes, discrim) {
    const order = secp256k1_1.secp256k1.CURVE.n;
    for (let i = 0; i <= 4294967295; i++) {
        // We hash the bytes to find a 256-bit number, looping until we are sure it
        // is less than the order of the curve.
        const hasher = new Sha512_1.default().add(bytes);
        // If the optional discriminator index was passed in, update the hash.
        if (discrim !== undefined) {
            hasher.addU32(discrim);
        }
        hasher.addU32(i);
        const key = hasher.first256BigInt();
        /* istanbul ignore else */
        if (key > ZERO && key < order) {
            return key;
        }
    }
    // This error is practically impossible to reach.
    // The order of the curve describes the (finite) amount of points on the curve
    // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182
    // How often will an (essentially) random number generated by Sha512 be larger than that?
    // There's 2^32 chances (the for loop) to get a number smaller than the order,
    // and it's rare that you'll even get past the first loop iteration.
    // Note that in TypeScript we actually need the throw, otherwise the function signature would be bigint | undefined
    //
    /* istanbul ignore next */
    throw new Error('impossible unicorn ;)');
}
/**
 * @param seed - Bytes.
 * @param [opts] - Object.
 * @param [opts.accountIndex=0] - The account number to generate.
 * @param [opts.validator=false] - Generate root key-pair,
 *                                              as used by validators.
 * @returns {bigint} 256 bit scalar value.
 *
 */
function derivePrivateKey(seed, opts = {}) {
    const root = opts.validator;
    const order = secp256k1_1.secp256k1.CURVE.n;
    // This private generator represents the `root` private key, and is what's
    // used by validators for signing when a keypair is generated from a seed.
    const privateGen = deriveScalar(seed);
    if (root) {
        // As returned by validation_create for a given seed
        return privateGen;
    }
    const publicGen = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);
    // A seed can generate many keypairs as a function of the seed and a uint32.
    // Almost everyone just uses the first account, `0`.
    const accountIndex = opts.accountIndex || 0;
    return (deriveScalar(publicGen, accountIndex) + privateGen) % order;
}
exports.derivePrivateKey = derivePrivateKey;
function accountPublicFromPublicGenerator(publicGenBytes) {
    const rootPubPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicGenBytes);
    const scalar = deriveScalar(publicGenBytes, 0);
    const point = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(scalar);
    const offset = rootPubPoint.add(point);
    return offset.toRawBytes(true);
}
exports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 7853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const sha512_1 = __nccwpck_require__(65);
const utils_1 = __nccwpck_require__(2210);
class Sha512 {
    constructor() {
        // instantiate empty sha512 hash
        this.hash = sha512_1.sha512.create();
    }
    static half(input) {
        return new Sha512().add(input).first256();
    }
    add(bytes) {
        this.hash.update(bytes);
        return this;
    }
    addU32(i) {
        const buffer = new Uint8Array(4);
        new DataView(buffer.buffer).setUint32(0, i);
        return this.add(buffer);
    }
    finish() {
        return this.hash.digest();
    }
    first256() {
        return this.finish().slice(0, 32);
    }
    first256BigInt() {
        return (0, utils_1.bytesToNumberBE)(this.first256());
    }
}
exports["default"] = Sha512;
//# sourceMappingURL=Sha512.js.map

/***/ }),

/***/ 4101:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const assertHelper = {
    ok(cond, message) {
        if (!cond) {
            throw new Error(message);
        }
    },
};
exports["default"] = assertHelper;
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ 408:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;
var Prefix;
(function (Prefix) {
    Prefix[Prefix["NONE"] = -1] = "NONE";
    Prefix[Prefix["ED25519"] = 237] = "ED25519";
    Prefix[Prefix["SECP256K1_PUB_X"] = 2] = "SECP256K1_PUB_X";
    Prefix[Prefix["SECP256K1_PUB_X_ODD_Y"] = 3] = "SECP256K1_PUB_X_ODD_Y";
    Prefix[Prefix["SECP256K1_PUB_XY"] = 4] = "SECP256K1_PUB_XY";
    Prefix[Prefix["SECP256K1_PRIVATE"] = 0] = "SECP256K1_PRIVATE";
})(Prefix || (Prefix = {}));
/**
 * | Curve     | Type        | Prefix | Length | Description                                           | Algorithm       |
 * |-----------|-------------|:------:|:------:|-------------------------------------------------------|----------------:|
 * | ed25519   | Private     |  0xED  |   33   | prefix + Uint256LE (0 < n < order )                   |         ed25519 |
 * | ed25519   | Public      |  0xED  |   33   | prefix + 32 y-bytes                                   |         ed25519 |
 * | secp256k1 | Public (1)  |  0x02  |   33   | prefix + 32 x-bytes                                   | ecdsa-secp256k1 |
 * | secp256k1 | Public (2)  |  0x03  |   33   | prefix + 32 x-bytes (y is odd)                        | ecdsa-secp256k1 |
 * | secp256k1 | Public (3)  |  0x04  |   65   | prefix + 32 x-bytes + 32 y-bytes                      | ecdsa-secp256k1 |
 * | secp256k1 | Private (1) |  None  |   32   | Uint256BE (0 < n < order)                             | ecdsa-secp256k1 |
 * | secp256k1 | Private (2) |  0x00  |   33   | prefix + Uint256BE (0 < n < order)                    | ecdsa-secp256k1 |
 *
 * Note: The 0x00 prefix for secpk256k1 Private (2) essentially 0 pads the number
 *       and the interpreted number is the same as 32 bytes.
 */
const KEY_TYPES = {
    [`private_${Prefix.NONE}_32`]: 'ecdsa-secp256k1',
    [`private_${Prefix.SECP256K1_PRIVATE}_33`]: 'ecdsa-secp256k1',
    [`private_${Prefix.ED25519}_33`]: 'ed25519',
    [`public_${Prefix.ED25519}_33`]: 'ed25519',
    [`public_${Prefix.SECP256K1_PUB_X}_33`]: 'ecdsa-secp256k1',
    [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: 'ecdsa-secp256k1',
    [`public_${Prefix.SECP256K1_PUB_XY}_65`]: 'ecdsa-secp256k1',
};
function getKeyInfo(key) {
    return {
        prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),
        len: key.length / 2,
    };
}
function prefixRepr(prefix) {
    return prefix === Prefix.NONE
        ? 'None'
        : `0x${prefix.toString(16).padStart(2, '0')}`;
}
function getValidFormatsTable(type) {
    // No need overkill with renderTable method
    const padding = 2;
    const colWidth = {
        algorithm: 'ecdsa-secp256k1'.length + padding,
        prefix: '0x00'.length + padding,
    };
    return Object.entries(KEY_TYPES)
        .filter(([key]) => key.startsWith(type))
        .map(([key, algorithm]) => {
        const [, prefix, length] = key.split('_');
        const paddedAlgo = algorithm.padEnd(colWidth.algorithm);
        const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix);
        return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;
    })
        .join('\n');
}
function keyError({ key, type, prefix, len, }) {
    const validFormats = getValidFormatsTable(type);
    return `invalid_key:

Type: ${type}
Key: ${key}
Prefix: ${prefixRepr(prefix)} 
Length: ${len} bytes

Acceptable ${type} formats are:
${validFormats}
`;
}
/**
 * Determines the algorithm associated with a given key (public/private).
 *
 * @param key - hexadecimal string representation of the key.
 * @param type - whether expected key is public or private
 * @returns Algorithm algorithm for signing/verifying
 * @throws Error when key is invalid
 */
function getAlgorithmFromKey(key, type) {
    const { prefix, len } = getKeyInfo(key);
    // Special case back compat support for no prefix
    const usedPrefix = type === 'private' && len === 32 ? Prefix.NONE : prefix;
    const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`];
    if (!algorithm) {
        throw new Error(keyError({ key, type, len, prefix: usedPrefix }));
    }
    return algorithm;
}
exports.getAlgorithmFromKey = getAlgorithmFromKey;
function getAlgorithmFromPublicKey(key) {
    return getAlgorithmFromKey(key, 'public');
}
exports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;
function getAlgorithmFromPrivateKey(key) {
    return getAlgorithmFromKey(key, 'private');
}
exports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;
//# sourceMappingURL=getAlgorithmFromKey.js.map

/***/ }),

/***/ 2534:
/***/ ((module) => {



/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0  // overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = isValidUTF8;


/***/ }),

/***/ 5161:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



try {
  module.exports = require(__nccwpck_require__.ab + "prebuilds/linux-x64/node.napi.node");
} catch (e) {
  module.exports = __nccwpck_require__(2534);
}


/***/ }),

/***/ 8867:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



const WebSocket = __nccwpck_require__(1518);

WebSocket.createWebSocketStream = __nccwpck_require__(1658);
WebSocket.Server = __nccwpck_require__(8887);
WebSocket.Receiver = __nccwpck_require__(5066);
WebSocket.Sender = __nccwpck_require__(6947);

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ 9436:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



const { EMPTY_BUFFER } = __nccwpck_require__(5949);

const FastBuffer = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __nccwpck_require__(3352);

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 5949:
/***/ ((module) => {



const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
const hasBlob = typeof Blob !== 'undefined';

if (hasBlob) BINARY_TYPES.push('blob');

module.exports = {
  BINARY_TYPES,
  CLOSE_TIMEOUT: 30000,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  hasBlob,
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ 4561:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



const { kForOnEventAttribute, kListener } = __nccwpck_require__(5949);

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ 2035:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



const { tokenChars } = __nccwpck_require__(6279);

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 1356:
/***/ ((module) => {



const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 6684:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



const zlib = __nccwpck_require__(9796);

const bufferUtil = __nccwpck_require__(9436);
const Limiter = __nccwpck_require__(1356);
const { kStatusCode } = __nccwpck_require__(5949);

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);

  //
  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the
  // fact that in Node.js versions prior to 13.10.0, the callback for
  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing
  // `zlib.reset()` ensures that either the callback is invoked or an error is
  // emitted.
  //
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;

  if (this[kError]) {
    this[kCallback](this[kError]);
    return;
  }

  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 5066:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



const { Writable } = __nccwpck_require__(2781);

const PerMessageDeflate = __nccwpck_require__(6684);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __nccwpck_require__(5949);
const { concat, toArrayBuffer, unmask } = __nccwpck_require__(9436);
const { isValidStatusCode, isValidUTF8 } = __nccwpck_require__(6279);

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === 'blob') {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
}

module.exports = Receiver;


/***/ }),

/***/ 6947:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */



const { Duplex } = __nccwpck_require__(2781);
const { randomFillSync } = __nccwpck_require__(6113);

const PerMessageDeflate = __nccwpck_require__(6684);
const { EMPTY_BUFFER, kWebSocket, NOOP } = __nccwpck_require__(5949);
const { isBlob, isValidStatusCode } = __nccwpck_require__(6279);
const { mask: applyMask, toBuffer } = __nccwpck_require__(9436);

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP;
    this[kWebSocket] = undefined;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    const opts = {
      [kByteLength]: byteLength,
      fin: options.fin,
      generateMask: this._generateMask,
      mask: options.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }

  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options, cb) {
    this._bufferedBytes += options[kByteLength];
    this._state = GET_BLOB_DATA;

    blob
      .arrayBuffer()
      .then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            'The socket was closed while the blob was being read'
          );

          //
          // `callCallbacks` is called in the next tick to ensure that errors
          // that might be thrown in the callbacks behave like errors thrown
          // outside the promise chain.
          //
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }

        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);

        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      })
      .catch((err) => {
        //
        // `onError` is called in the next tick for the same reason that
        // `callCallbacks` above is.
        //
        process.nextTick(onError, this, err, cb);
      });
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        callCallbacks(this, err, cb);
        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._state = DEFAULT;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {(Buffer | String)[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Calls queued callbacks with an error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error to call the callbacks with
 * @param {Function} [cb] The first callback
 * @private
 */
function callCallbacks(sender, err, cb) {
  if (typeof cb === 'function') cb(err);

  for (let i = 0; i < sender._queue.length; i++) {
    const params = sender._queue[i];
    const callback = params[params.length - 1];

    if (typeof callback === 'function') callback(err);
  }
}

/**
 * Handles a `Sender` error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error
 * @param {Function} [cb] The first pending callback
 * @private
 */
function onError(sender, err, cb) {
  callCallbacks(sender, err, cb);
  sender.onerror(err);
}


/***/ }),

/***/ 1658:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^WebSocket$" }] */


const WebSocket = __nccwpck_require__(1518);
const { Duplex } = __nccwpck_require__(2781);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 6668:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



const { tokenChars } = __nccwpck_require__(6279);

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ 6279:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



const { isUtf8 } = __nccwpck_require__(4300);

const { hasBlob } = __nccwpck_require__(5949);

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

/**
 * Determines whether a value is a `Blob`.
 *
 * @param {*} value The value to be tested
 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
 * @private
 */
function isBlob(value) {
  return (
    hasBlob &&
    typeof value === 'object' &&
    typeof value.arrayBuffer === 'function' &&
    typeof value.type === 'string' &&
    typeof value.stream === 'function' &&
    (value[Symbol.toStringTag] === 'Blob' ||
      value[Symbol.toStringTag] === 'File')
  );
}

module.exports = {
  isBlob,
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

if (isUtf8) {
  module.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __nccwpck_require__(5161);

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 8887:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */



const EventEmitter = __nccwpck_require__(2361);
const http = __nccwpck_require__(3685);
const { Duplex } = __nccwpck_require__(2781);
const { createHash } = __nccwpck_require__(6113);

const extension = __nccwpck_require__(2035);
const PerMessageDeflate = __nccwpck_require__(6684);
const subprotocol = __nccwpck_require__(6668);
const WebSocket = __nccwpck_require__(1518);
const { CLOSE_TIMEOUT, GUID, kWebSocket } = __nccwpck_require__(5949);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Number} [options.closeTimeout=30000] Duration in milliseconds to
   *     wait for the closing handshake to finish after `websocket.close()` is
   *     called
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      closeTimeout: CLOSE_TIMEOUT,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 13 && version !== 8) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
        'Sec-WebSocket-Version': '13, 8'
      });
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @param {Object} [headers] The HTTP response headers
 * @private
 */
function abortHandshakeOrEmitwsClientError(
  server,
  req,
  socket,
  code,
  message,
  headers
) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message, headers);
  }
}


/***/ }),

/***/ 1518:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */



const EventEmitter = __nccwpck_require__(2361);
const https = __nccwpck_require__(5687);
const http = __nccwpck_require__(3685);
const net = __nccwpck_require__(1808);
const tls = __nccwpck_require__(4404);
const { randomBytes, createHash } = __nccwpck_require__(6113);
const { Duplex, Readable } = __nccwpck_require__(2781);
const { URL } = __nccwpck_require__(7310);

const PerMessageDeflate = __nccwpck_require__(6684);
const Receiver = __nccwpck_require__(5066);
const Sender = __nccwpck_require__(6947);
const { isBlob } = __nccwpck_require__(6279);

const {
  BINARY_TYPES,
  CLOSE_TIMEOUT,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __nccwpck_require__(5949);
const {
  EventTarget: { addEventListener, removeEventListener }
} = __nccwpck_require__(4561);
const { format, parse } = __nccwpck_require__(2035);
const { toBuffer } = __nccwpck_require__(9436);

const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._closeTimeout = options.closeTimeout;
      this._isServer = true;
    }
  }

  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    const sender = new Sender(socket, this._extensions, options.generateMask);

    this._receiver = receiver;
    this._sender = sender;
    this._socket = socket;

    receiver[kWebSocket] = this;
    sender[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    sender.onerror = senderOnError;

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    setCloseTimer(this);
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Number} [options.closeTimeout=30000] Duration in milliseconds to wait
 *     for the closing handshake to finish after `websocket.close()` is called
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    closeTimeout: CLOSE_TIMEOUT,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;
  websocket._closeTimeout = opts.closeTimeout;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https:", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  //
  // The following assignment is practically useless and is done only for
  // consistency.
  //
  websocket._errorEmitted = true;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The `Sender` error event handler.
 *
 * @param {Error} The error
 * @private
 */
function senderOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket.readyState === WebSocket.CLOSED) return;
  if (websocket.readyState === WebSocket.OPEN) {
    websocket._readyState = WebSocket.CLOSING;
    setCloseTimer(websocket);
  }

  //
  // `socket.end()` is used instead of `socket.destroy()` to allow the other
  // peer to finish sending queued data. There is no need to set a timer here
  // because `CLOSING` means that it is already set or not needed.
  //
  this._socket.end();

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * Set a timer to destroy the underlying raw socket of a WebSocket.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @private
 */
function setCloseTimer(websocket) {
  websocket._closeTimer = setTimeout(
    websocket._socket.destroy.bind(websocket._socket),
    websocket._closeTimeout
  );
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written. If instead, the
  // socket is paused, any possible buffered data will be read as a single
  // chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    this._readableState.length !== 0
  ) {
    const chunk = this.read(this._readableState.length);

    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 647:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
const utils_1 = __nccwpck_require__(3617);
const xah_codec_1 = __nccwpck_require__(8539);
Object.defineProperty(exports, "codec", ({ enumerable: true, get: function () { return xah_codec_1.codec; } }));
Object.defineProperty(exports, "encodeSeed", ({ enumerable: true, get: function () { return xah_codec_1.encodeSeed; } }));
Object.defineProperty(exports, "decodeSeed", ({ enumerable: true, get: function () { return xah_codec_1.decodeSeed; } }));
Object.defineProperty(exports, "encodeAccountID", ({ enumerable: true, get: function () { return xah_codec_1.encodeAccountID; } }));
Object.defineProperty(exports, "decodeAccountID", ({ enumerable: true, get: function () { return xah_codec_1.decodeAccountID; } }));
Object.defineProperty(exports, "encodeNodePublic", ({ enumerable: true, get: function () { return xah_codec_1.encodeNodePublic; } }));
Object.defineProperty(exports, "decodeNodePublic", ({ enumerable: true, get: function () { return xah_codec_1.decodeNodePublic; } }));
Object.defineProperty(exports, "encodeAccountPublic", ({ enumerable: true, get: function () { return xah_codec_1.encodeAccountPublic; } }));
Object.defineProperty(exports, "decodeAccountPublic", ({ enumerable: true, get: function () { return xah_codec_1.decodeAccountPublic; } }));
Object.defineProperty(exports, "isValidClassicAddress", ({ enumerable: true, get: function () { return xah_codec_1.isValidClassicAddress; } }));
const PREFIX_BYTES = {
    // 5, 68
    main: Uint8Array.from([0x05, 0x44]),
    // 4, 147
    test: Uint8Array.from([0x04, 0x93]),
};
const MAX_32_BIT_UNSIGNED_INT = 4294967295;
function classicAddressToXAddress(classicAddress, tag, test) {
    const accountId = (0, xah_codec_1.decodeAccountID)(classicAddress);
    return encodeXAddress(accountId, tag, test);
}
exports.classicAddressToXAddress = classicAddressToXAddress;
function encodeXAddress(accountId, tag, test) {
    if (accountId.length !== 20) {
        // RIPEMD160 is 160 bits = 20 bytes
        throw new Error('Account ID must be 20 bytes');
    }
    if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {
        throw new Error('Invalid tag');
    }
    const theTag = tag || 0;
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake
    const flag = tag === false || tag == null ? 0 : 1;
    /* eslint-disable no-bitwise ---
     * need to use bitwise operations here */
    const bytes = (0, utils_1.concat)([
        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
        accountId,
        Uint8Array.from([
            // 0x00 if no tag, 0x01 if 32-bit tag
            flag,
            // first byte
            theTag & 0xff,
            // second byte
            (theTag >> 8) & 0xff,
            // third byte
            (theTag >> 16) & 0xff,
            // fourth byte
            (theTag >> 24) & 0xff,
            0,
            0,
            0,
            // four zero bytes (reserved for 64-bit tags)
            0,
        ]),
    ]);
    /* eslint-enable no-bitwise */
    return xah_codec_1.codec.encodeChecked(bytes);
}
exports.encodeXAddress = encodeXAddress;
function xAddressToClassicAddress(xAddress) {
    /* eslint-disable @typescript-eslint/naming-convention --
     * TODO 'test' should be something like 'isTest', do this later
     */
    const { accountId, tag, test } = decodeXAddress(xAddress);
    /* eslint-enable @typescript-eslint/naming-convention */
    const classicAddress = (0, xah_codec_1.encodeAccountID)(accountId);
    return {
        classicAddress,
        tag,
        test,
    };
}
exports.xAddressToClassicAddress = xAddressToClassicAddress;
function decodeXAddress(xAddress) {
    const decoded = xah_codec_1.codec.decodeChecked(xAddress);
    /* eslint-disable @typescript-eslint/naming-convention --
     * TODO 'test' should be something like 'isTest', do this later
     */
    const test = isUint8ArrayForTestAddress(decoded);
    /* eslint-enable @typescript-eslint/naming-convention */
    const accountId = decoded.slice(2, 22);
    const tag = tagFromUint8Array(decoded);
    return {
        accountId,
        tag,
        test,
    };
}
exports.decodeXAddress = decodeXAddress;
function isUint8ArrayForTestAddress(buf) {
    const decodedPrefix = buf.slice(0, 2);
    if ((0, utils_1.equal)(PREFIX_BYTES.main, decodedPrefix)) {
        return false;
    }
    if ((0, utils_1.equal)(PREFIX_BYTES.test, decodedPrefix)) {
        return true;
    }
    throw new Error('Invalid X-address: bad prefix');
}
function tagFromUint8Array(buf) {
    const flag = buf[22];
    if (flag >= 2) {
        // No support for 64-bit tags at this time
        throw new Error('Unsupported X-address');
    }
    if (flag === 1) {
        // Little-endian to big-endian
        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;
    }
    if (flag !== 0) {
        throw new Error('flag must be zero to indicate no tag');
    }
    if (!(0, utils_1.equal)((0, utils_1.hexToBytes)('0000000000000000'), buf.slice(23, 23 + 8))) {
        throw new Error('remaining bytes must be zero');
    }
    return false;
}
function isValidXAddress(xAddress) {
    try {
        decodeXAddress(xAddress);
    }
    catch (_error) {
        return false;
    }
    return true;
}
exports.isValidXAddress = isValidXAddress;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7404:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concatArgs = exports.arrayEqual = void 0;
/**
 * Check whether two sequences (e.g. Arrays of numbers) are equal.
 *
 * @param arr1 - One of the arrays to compare.
 * @param arr2 - The other array to compare.
 */
function arrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    return arr1.every((value, index) => value === arr2[index]);
}
exports.arrayEqual = arrayEqual;
/**
 * Check whether a value is a scalar
 *
 * @param val - The value to check.
 */
function isScalar(val) {
    return typeof val === 'number';
}
/**
 * Concatenate all `arguments` into a single array. Each argument can be either
 * a single element or a sequence, which has a `length` property and supports
 * element retrieval via sequence[ix].
 *
 * > concatArgs(1, [2, 3], Uint8Array.from([4,5]), new Uint8Array([6, 7]));
 * [1,2,3,4,5,6,7]
 *
 * @param args - Concatenate of these args into a single array.
 * @returns Array of concatenated arguments
 */
function concatArgs(...args) {
    return args.flatMap((arg) => {
        return isScalar(arg) ? [arg] : Array.from(arg);
    });
}
exports.concatArgs = concatArgs;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 8539:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


/**
 * Codec class
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
const base_1 = __nccwpck_require__(9891);
const sha256_1 = __nccwpck_require__(8093);
const utils_1 = __nccwpck_require__(7404);
class Codec {
    constructor(options) {
        this._sha256 = options.sha256;
        this._codec = base_1.base58xrp;
    }
    /**
     * Encoder.
     *
     * @param bytes - Uint8Array of data to encode.
     * @param opts - Options object including the version bytes and the expected length of the data to encode.
     */
    encode(bytes, opts) {
        const versions = opts.versions;
        return this._encodeVersioned(bytes, versions, opts.expectedLength);
    }
    /**
     * Decoder.
     *
     * @param base58string - Base58Check-encoded string to decode.
     * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
     */
    /* eslint-disable max-lines-per-function --
     * TODO refactor */
    decode(base58string, opts) {
        var _a;
        const versions = opts.versions;
        const types = opts.versionTypes;
        const withoutSum = this.decodeChecked(base58string);
        if (versions.length > 1 && !opts.expectedLength) {
            throw new Error('expectedLength is required because there are >= 2 possible versions');
        }
        const versionLengthGuess = typeof versions[0] === 'number' ? 1 : versions[0].length;
        const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;
        const versionBytes = withoutSum.slice(0, -payloadLength);
        const payload = withoutSum.slice(-payloadLength);
        for (let i = 0; i < versions.length; i++) {
            /* eslint-disable @typescript-eslint/consistent-type-assertions --
             * TODO refactor */
            const version = Array.isArray(versions[i])
                ? versions[i]
                : [versions[i]];
            if ((0, utils_1.arrayEqual)(versionBytes, version)) {
                return {
                    version,
                    bytes: payload,
                    type: types ? types[i] : null,
                };
            }
            /* eslint-enable @typescript-eslint/consistent-type-assertions */
        }
        throw new Error('version_invalid: version bytes do not match any of the provided version(s)');
    }
    encodeChecked(bytes) {
        const check = this._sha256(this._sha256(bytes)).slice(0, 4);
        return this._encodeRaw(Uint8Array.from((0, utils_1.concatArgs)(bytes, check)));
    }
    decodeChecked(base58string) {
        const intArray = this._decodeRaw(base58string);
        if (intArray.byteLength < 5) {
            throw new Error('invalid_input_size: decoded data must have length >= 5');
        }
        if (!this._verifyCheckSum(intArray)) {
            throw new Error('checksum_invalid');
        }
        return intArray.slice(0, -4);
    }
    _encodeVersioned(bytes, versions, expectedLength) {
        if (!checkByteLength(bytes, expectedLength)) {
            throw new Error('unexpected_payload_length: bytes.length does not match expectedLength.' +
                ' Ensure that the bytes are a Uint8Array.');
        }
        return this.encodeChecked((0, utils_1.concatArgs)(versions, bytes));
    }
    _encodeRaw(bytes) {
        return this._codec.encode(Uint8Array.from(bytes));
    }
    /* eslint-enable max-lines-per-function */
    _decodeRaw(base58string) {
        return this._codec.decode(base58string);
    }
    _verifyCheckSum(bytes) {
        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);
        const checksum = bytes.slice(-4);
        return (0, utils_1.arrayEqual)(computed, checksum);
    }
}
/**
 * XAH codec
 */
// base58 encodings: https://xrpl.org/base58-encodings.html
// Account address (20 bytes)
const ACCOUNT_ID = 0;
// Account public key (33 bytes)
const ACCOUNT_PUBLIC_KEY = 0x23;
// 33; Seed value (for secret keys) (16 bytes)
const FAMILY_SEED = 0x21;
// 28; Validation public key (33 bytes)
const NODE_PUBLIC = 0x1c;
// [1, 225, 75]
const ED25519_SEED = [0x01, 0xe1, 0x4b];
const codecOptions = {
    sha256: sha256_1.sha256,
};
const codecWithXrpAlphabet = new Codec(codecOptions);
exports.codec = codecWithXrpAlphabet;
// entropy is a Uint8Array of size 16
// type is 'ed25519' or 'secp256k1'
function encodeSeed(entropy, type) {
    if (!checkByteLength(entropy, 16)) {
        throw new Error('entropy must have length 16');
    }
    const opts = {
        expectedLength: 16,
        // for secp256k1, use `FAMILY_SEED`
        versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],
    };
    // prefixes entropy with version bytes
    return codecWithXrpAlphabet.encode(entropy, opts);
}
exports.encodeSeed = encodeSeed;
function decodeSeed(seed, opts = {
    versionTypes: ['ed25519', 'secp256k1'],
    versions: [ED25519_SEED, FAMILY_SEED],
    expectedLength: 16,
}) {
    return codecWithXrpAlphabet.decode(seed, opts);
}
exports.decodeSeed = decodeSeed;
function encodeAccountID(bytes) {
    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeAccountID = encodeAccountID;
/* eslint-disable import/no-unused-modules ---
 * unclear why this is aliased but we should keep it in case someone else is
 * importing it with the aliased name */
exports.encodeAddress = encodeAccountID;
/* eslint-enable import/no-unused-modules */
function decodeAccountID(accountId) {
    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
    return codecWithXrpAlphabet.decode(accountId, opts).bytes;
}
exports.decodeAccountID = decodeAccountID;
/* eslint-disable import/no-unused-modules ---
 * unclear why this is aliased but we should keep it in case someone else is
 * importing it with the aliased name */
exports.decodeAddress = decodeAccountID;
/* eslint-enable import/no-unused-modules */
function decodeNodePublic(base58string) {
    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
}
exports.decodeNodePublic = decodeNodePublic;
function encodeNodePublic(bytes) {
    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeNodePublic = encodeNodePublic;
function encodeAccountPublic(bytes) {
    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeAccountPublic = encodeAccountPublic;
function decodeAccountPublic(base58string) {
    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
}
exports.decodeAccountPublic = decodeAccountPublic;
function isValidClassicAddress(address) {
    try {
        decodeAccountID(address);
    }
    catch (_error) {
        return false;
    }
    return true;
}
exports.isValidClassicAddress = isValidClassicAddress;
function checkByteLength(bytes, expectedLength) {
    return 'byteLength' in bytes
        ? bytes.byteLength === expectedLength
        : bytes.length === expectedLength;
}
//# sourceMappingURL=xah-codec.js.map

/***/ }),

/***/ 3529:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


/* eslint-disable func-style */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
const utils_1 = __nccwpck_require__(3617);
const types_1 = __nccwpck_require__(3659);
const binary_parser_1 = __nccwpck_require__(5956);
Object.defineProperty(exports, "BinaryParser", ({ enumerable: true, get: function () { return binary_parser_1.BinaryParser; } }));
const hash_prefixes_1 = __nccwpck_require__(525);
const binary_serializer_1 = __nccwpck_require__(2412);
Object.defineProperty(exports, "BinarySerializer", ({ enumerable: true, get: function () { return binary_serializer_1.BinarySerializer; } }));
Object.defineProperty(exports, "BytesList", ({ enumerable: true, get: function () { return binary_serializer_1.BytesList; } }));
const hashes_1 = __nccwpck_require__(2179);
Object.defineProperty(exports, "sha512Half", ({ enumerable: true, get: function () { return hashes_1.sha512Half; } }));
Object.defineProperty(exports, "transactionID", ({ enumerable: true, get: function () { return hashes_1.transactionID; } }));
const enums_1 = __nccwpck_require__(8039);
/**
 * Construct a BinaryParser
 *
 * @param bytes hex-string or Uint8Array to construct BinaryParser from
 * @param definitions xahaud definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns BinaryParser
 */
const makeParser = (bytes, definitions) => new binary_parser_1.BinaryParser(bytes instanceof Uint8Array ? (0, utils_1.bytesToHex)(bytes) : bytes, definitions);
exports.makeParser = makeParser;
/**
 * Parse BinaryParser into JSON
 *
 * @param parser BinaryParser object
 * @param definitions xahaud definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns JSON for the bytes in the BinaryParser
 */
const readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS) => parser.readType(types_1.coreTypes.STObject).toJSON(definitions);
exports.readJSON = readJSON;
/**
 * Parse a hex-string into its JSON interpretation
 *
 * @param bytes hex-string to parse into JSON
 * @param definitions xahaud definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns JSON
 */
const binaryToJSON = (bytes, definitions) => readJSON(makeParser(bytes, definitions), definitions);
exports.binaryToJSON = binaryToJSON;
/**
 * Function to serialize JSON object representing a transaction
 *
 * @param object JSON object to serialize
 * @param opts options for serializing, including optional prefix, suffix, signingFieldOnly, and definitions
 * @returns A Uint8Array containing the serialized object
 */
function serializeObject(object, opts = {}) {
    const { prefix, suffix, signingFieldsOnly = false, definitions } = opts;
    const bytesList = new binary_serializer_1.BytesList();
    if (prefix) {
        bytesList.put(prefix);
    }
    const filter = signingFieldsOnly
        ? (f) => f.isSigningField
        : undefined;
    types_1.coreTypes.STObject
        .from(object, filter, definitions)
        .toBytesSink(bytesList);
    if (suffix) {
        bytesList.put(suffix);
    }
    return bytesList.toBytes();
}
exports.serializeObject = serializeObject;
/**
 * Serialize an object for signing
 *
 * @param transaction Transaction to serialize
 * @param prefix Prefix bytes to put before the serialized object
 * @param opts.definitions Custom xahaud types to use instead of the default. Used for sidechains and amendments.
 * @returns A Uint8Array with the serialized object
 */
function signingData(transaction, prefix = hash_prefixes_1.HashPrefix.transactionSig, opts = {}) {
    return serializeObject(transaction, {
        prefix,
        signingFieldsOnly: true,
        definitions: opts.definitions,
    });
}
exports.signingData = signingData;
/**
 * Serialize a signingClaim
 *
 * @param claim A claim object to serialize
 * @param opts.definitions Custom xahaud types to use instead of the default. Used for sidechains and amendments.
 * @returns the serialized object with appropriate prefix
 */
function signingClaimData(claim) {
    const prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;
    const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();
    const bytesList = new binary_serializer_1.BytesList();
    bytesList.put(prefix);
    bytesList.put(channel);
    if (typeof claim.amount === 'string') {
        const num = BigInt(String(claim.amount));
        const amount = types_1.coreTypes.UInt64.from(num).toBytes();
        bytesList.put(amount);
    }
    else {
        const amount = types_1.coreTypes.Amount.from(claim.amount).toBytes();
        bytesList.put(amount);
    }
    return bytesList.toBytes();
}
exports.signingClaimData = signingClaimData;
/**
 * Serialize a transaction object for multiSigning
 *
 * @param transaction transaction to serialize
 * @param signingAccount Account to sign the transaction with
 * @param opts.definitions Custom xahaud types to use instead of the default. Used for sidechains and amendments.
 * @returns serialized transaction with appropriate prefix and suffix
 */
function multiSigningData(transaction, signingAccount, opts = {
    definitions: enums_1.DEFAULT_DEFINITIONS,
}) {
    const prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;
    const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();
    return serializeObject(transaction, {
        prefix,
        suffix,
        signingFieldsOnly: true,
        definitions: opts.definitions,
    });
}
exports.multiSigningData = multiSigningData;
//# sourceMappingURL=binary.js.map

/***/ }),

/***/ 1956:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
const enums_1 = __nccwpck_require__(8039);
Object.defineProperty(exports, "DEFAULT_DEFINITIONS", ({ enumerable: true, get: function () { return enums_1.DEFAULT_DEFINITIONS; } }));
Object.defineProperty(exports, "Field", ({ enumerable: true, get: function () { return enums_1.Field; } }));
Object.defineProperty(exports, "TransactionType", ({ enumerable: true, get: function () { return enums_1.TransactionType; } }));
Object.defineProperty(exports, "LedgerEntryType", ({ enumerable: true, get: function () { return enums_1.LedgerEntryType; } }));
Object.defineProperty(exports, "Type", ({ enumerable: true, get: function () { return enums_1.Type; } }));
Object.defineProperty(exports, "TransactionResult", ({ enumerable: true, get: function () { return enums_1.TransactionResult; } }));
const types = __importStar(__nccwpck_require__(3659));
exports.types = types;
const binary = __importStar(__nccwpck_require__(3529));
exports.binary = binary;
const shamap_1 = __nccwpck_require__(1661);
Object.defineProperty(exports, "ShaMap", ({ enumerable: true, get: function () { return shamap_1.ShaMap; } }));
const ledgerHashes = __importStar(__nccwpck_require__(831));
exports.ledgerHashes = ledgerHashes;
const hashes = __importStar(__nccwpck_require__(2179));
exports.hashes = hashes;
const quality_1 = __nccwpck_require__(4088);
Object.defineProperty(exports, "quality", ({ enumerable: true, get: function () { return quality_1.quality; } }));
const hash_prefixes_1 = __nccwpck_require__(525);
Object.defineProperty(exports, "HashPrefix", ({ enumerable: true, get: function () { return hash_prefixes_1.HashPrefix; } }));
//# sourceMappingURL=coretypes.js.map

/***/ }),

/***/ 1492:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BytesLookup = exports.Bytes = void 0;
/*
 * @brief: Bytes, name, and ordinal representing one type, ledger_type, transaction type, or result
 */
class Bytes {
    constructor(name, ordinal, ordinalWidth) {
        this.name = name;
        this.ordinal = ordinal;
        this.ordinalWidth = ordinalWidth;
        this.bytes = new Uint8Array(ordinalWidth);
        for (let i = 0; i < ordinalWidth; i++) {
            this.bytes[ordinalWidth - i - 1] = (ordinal >>> (i * 8)) & 0xff;
        }
    }
    toJSON() {
        return this.name;
    }
    toBytesSink(sink) {
        sink.put(this.bytes);
    }
    toBytes() {
        return this.bytes;
    }
}
exports.Bytes = Bytes;
/*
 * @brief: Collection of Bytes objects, mapping bidirectionally
 */
class BytesLookup {
    constructor(types, ordinalWidth) {
        this.ordinalWidth = ordinalWidth;
        Object.entries(types).forEach(([k, v]) => {
            this.add(k, v);
        });
    }
    /**
     * Add a new name value pair to the BytesLookup.
     *
     * @param name - A human readable name for the field.
     * @param value - The numeric value for the field.
     * @throws if the name or value already exist in the lookup because it's unclear how to decode.
     */
    add(name, value) {
        if (this[name]) {
            throw new SyntaxError(`Attempted to add a value with a duplicate name "${name}". This is not allowed because it is unclear how to decode.`);
        }
        if (this[value.toString()]) {
            throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name}" and previous name: "${this[value.toString()]}. This is not allowed because it is unclear how to decode.\nGiven value: ${value.toString()}`);
        }
        this[name] = new Bytes(name, value, this.ordinalWidth);
        this[value.toString()] = this[name];
    }
    from(value) {
        return value instanceof Bytes ? value : this[value];
    }
    fromParser(parser) {
        return this.from(parser.readUIntN(this.ordinalWidth).toString());
    }
}
exports.BytesLookup = BytesLookup;
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ 3052:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TRANSACTION_RESULT_WIDTH = exports.TRANSACTION_TYPE_WIDTH = exports.LEDGER_ENTRY_WIDTH = exports.TYPE_WIDTH = void 0;
exports.TYPE_WIDTH = 2;
exports.LEDGER_ENTRY_WIDTH = 2;
exports.TRANSACTION_TYPE_WIDTH = 2;
exports.TRANSACTION_RESULT_WIDTH = 1;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 8798:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldLookup = void 0;
const bytes_1 = __nccwpck_require__(1492);
const serialized_type_1 = __nccwpck_require__(1375);
const constants_1 = __nccwpck_require__(3052);
/*
 * @brief: Serialize a field based on type_code and Field.nth
 */
function fieldHeader(type, nth) {
    const header = [];
    if (type < 16) {
        if (nth < 16) {
            header.push((type << 4) | nth);
        }
        else {
            header.push(type << 4, nth);
        }
    }
    else if (nth < 16) {
        header.push(nth, type);
    }
    else {
        header.push(0, type, nth);
    }
    return Uint8Array.from(header);
}
function buildField([name, info], typeOrdinal) {
    const field = fieldHeader(typeOrdinal, info.nth);
    return {
        name: name,
        nth: info.nth,
        isVariableLengthEncoded: info.isVLEncoded,
        isSerialized: info.isSerialized,
        isSigningField: info.isSigningField,
        ordinal: (typeOrdinal << 16) | info.nth,
        type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),
        header: field,
        associatedType: serialized_type_1.SerializedType, // For later assignment in ./types/index.js or Definitions.updateAll(...)
    };
}
/*
 * @brief: The collection of all fields as defined in definitions.json
 */
class FieldLookup {
    constructor(fields, types) {
        fields.forEach(([name, field_info]) => {
            const typeOrdinal = types[field_info.type];
            this[name] = buildField([name, field_info], typeOrdinal);
            this[this[name].ordinal.toString()] = this[name];
        });
    }
    fromString(value) {
        return this[value];
    }
}
exports.FieldLookup = FieldLookup;
//# sourceMappingURL=field.js.map

/***/ }),

/***/ 8039:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TRANSACTION_TYPE_MAP = exports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;
const definitions_json_1 = __importDefault(__nccwpck_require__(3892));
const xahau_definitions_base_1 = __nccwpck_require__(1303);
Object.defineProperty(exports, "XrplDefinitionsBase", ({ enumerable: true, get: function () { return xahau_definitions_base_1.XrplDefinitionsBase; } }));
Object.defineProperty(exports, "Bytes", ({ enumerable: true, get: function () { return xahau_definitions_base_1.Bytes; } }));
/**
 * By default, coreTypes from the `types` folder is where known type definitions are initialized to avoid import cycles.
 */
const DEFAULT_DEFINITIONS = new xahau_definitions_base_1.XrplDefinitionsBase(definitions_json_1.default, {});
exports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
const Type = DEFAULT_DEFINITIONS.type;
exports.Type = Type;
const LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
exports.LedgerEntryType = LedgerEntryType;
const TransactionType = DEFAULT_DEFINITIONS.transactionType;
exports.TransactionType = TransactionType;
const TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
exports.TransactionResult = TransactionResult;
const Field = DEFAULT_DEFINITIONS.field;
exports.Field = Field;
/*
 * @brief: All valid transaction types
 */
const TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;
exports.TRANSACTION_TYPES = TRANSACTION_TYPES;
const TRANSACTION_TYPE_MAP = DEFAULT_DEFINITIONS.transactionMap;
exports.TRANSACTION_TYPE_MAP = TRANSACTION_TYPE_MAP;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1303:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;
const bytes_1 = __nccwpck_require__(1492);
Object.defineProperty(exports, "Bytes", ({ enumerable: true, get: function () { return bytes_1.Bytes; } }));
Object.defineProperty(exports, "BytesLookup", ({ enumerable: true, get: function () { return bytes_1.BytesLookup; } }));
const field_1 = __nccwpck_require__(8798);
Object.defineProperty(exports, "FieldLookup", ({ enumerable: true, get: function () { return field_1.FieldLookup; } }));
const constants_1 = __nccwpck_require__(3052);
/**
 * Stores the various types and fields for xahaud to be used to encode/decode information later on.
 * XrplDefinitions should be instantiated instead of this class.
 */
class XrplDefinitionsBase {
    /**
     * Present xahaud types in a typed and updatable format.
     * For an example of the input format see `definitions.json`
     * To generate a new definitions file from xahaud source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
     *
     * See the definitions.test.js file for examples of how to create your own updated definitions.json.
     *
     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
     * @param types - A list of type objects with the same name as the fields defined.
     *              You can use the coreTypes object if you are not adding new types.
     */
    constructor(enums, types) {
        this.type = new bytes_1.BytesLookup(enums.TYPES, constants_1.TYPE_WIDTH);
        this.ledgerEntryType = new bytes_1.BytesLookup(enums.LEDGER_ENTRY_TYPES, constants_1.LEDGER_ENTRY_WIDTH);
        this.transactionType = new bytes_1.BytesLookup(enums.TRANSACTION_TYPES, constants_1.TRANSACTION_TYPE_WIDTH);
        this.transactionResult = new bytes_1.BytesLookup(enums.TRANSACTION_RESULTS, constants_1.TRANSACTION_RESULT_WIDTH);
        this.field = new field_1.FieldLookup(enums.FIELDS, enums.TYPES);
        this.transactionNames = Object.entries(enums.TRANSACTION_TYPES)
            .filter(([_key, value]) => value >= 0)
            .map(([key, _value]) => key);
        const ignoreList = [
            'EnableAmendment',
            'SetFee',
            'UNLModify',
            'EmitFailure',
            'Cron',
        ];
        this.transactionMap = Object.assign({}, ...Object.entries(enums.TRANSACTION_TYPES)
            .filter(([_key, _value]) => _value >= 0 || ignoreList.includes(_key))
            .map(([key, value]) => ({ [key]: value })));
        this.dataTypes = {}; // Filled in via associateTypes
        this.associateTypes(types);
    }
    /**
     * Associates each Field to a corresponding class that TypeScript can recognize.
     *
     * @param types a list of type objects with the same name as the fields defined.
     *              Defaults to xahau.js's core type definitions.
     */
    associateTypes(types) {
        // Overwrite any existing type definitions with the given types
        this.dataTypes = Object.assign({}, this.dataTypes, types);
        Object.values(this.field).forEach((field) => {
            field.associatedType = this.dataTypes[field.type.name];
        });
        this.field['TransactionType'].associatedType = this.transactionType;
        this.field['TransactionResult'].associatedType = this.transactionResult;
        this.field['LedgerEntryType'].associatedType = this.ledgerEntryType;
    }
    getAssociatedTypes() {
        return this.dataTypes;
    }
}
exports.XrplDefinitionsBase = XrplDefinitionsBase;
//# sourceMappingURL=xahau-definitions-base.js.map

/***/ }),

/***/ 8925:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XrplDefinitions = void 0;
const xahau_definitions_base_1 = __nccwpck_require__(1303);
const types_1 = __nccwpck_require__(3659);
/**
 * Stores the various types and fields for xahaud to be used to encode/decode information later on.
 * Should be used instead of XrplDefinitionsBase since this defines default `types` for serializing/deserializing
 * ledger data.
 */
class XrplDefinitions extends xahau_definitions_base_1.XrplDefinitionsBase {
    /**
     * Present xahaud types in a typed and updatable format.
     * For an example of the input format see `definitions.json`
     * To generate a new definitions file from xahaud source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
     *
     * See the definitions.test.js file for examples of how to create your own updated definitions.json.
     *
     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
     * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
     *              These types will be included in addition to the coreTypes used on mainnet.
     */
    constructor(enums, additionalTypes) {
        const types = Object.assign({}, types_1.coreTypes, additionalTypes);
        super(enums, types);
    }
}
exports.XrplDefinitions = XrplDefinitions;
//# sourceMappingURL=xahau-definitions.js.map

/***/ }),

/***/ 525:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HashPrefix = void 0;
const utils_1 = __nccwpck_require__(2758);
/**
 * Write a 32 bit integer to a Uint8Array
 *
 * @param uint32 32 bit integer to write to Uint8Array
 * @returns a Uint8Array with the bytes representation of uint32
 */
function bytes(uint32) {
    const result = new Uint8Array(4);
    (0, utils_1.writeUInt32BE)(result, uint32, 0);
    return result;
}
/**
 * Maps HashPrefix names to their byte representation
 */
const HashPrefix = {
    transactionID: bytes(0x54584e00),
    // transaction plus metadata
    transaction: bytes(0x534e4400),
    // account state
    accountStateEntry: bytes(0x4d4c4e00),
    // inner node in tree
    innerNode: bytes(0x4d494e00),
    // ledger master data for signing
    ledgerHeader: bytes(0x4c575200),
    // inner transaction to sign
    transactionSig: bytes(0x53545800),
    // inner transaction to sign
    transactionMultiSig: bytes(0x534d5400),
    // validation for signing
    validation: bytes(0x56414c00),
    // proposal for signing
    proposal: bytes(0x50525000),
    // payment channel claim
    paymentChannelClaim: bytes(0x434c4d00),
};
exports.HashPrefix = HashPrefix;
//# sourceMappingURL=hash-prefixes.js.map

/***/ }),

/***/ 2179:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
const hash_prefixes_1 = __nccwpck_require__(525);
const types_1 = __nccwpck_require__(3659);
const binary_serializer_1 = __nccwpck_require__(2412);
const sha512_1 = __nccwpck_require__(65);
/**
 * Class for hashing with SHA512
 * @extends BytesList So SerializedTypes can write bytes to a Sha512Half
 */
class Sha512Half extends binary_serializer_1.BytesList {
    constructor() {
        super(...arguments);
        this.hash = sha512_1.sha512.create();
    }
    /**
     * Construct a new Sha512Hash and write bytes this.hash
     *
     * @param bytes bytes to write to this.hash
     * @returns the new Sha512Hash object
     */
    static put(bytes) {
        return new Sha512Half().put(bytes);
    }
    /**
     * Write bytes to an existing Sha512Hash
     *
     * @param bytes bytes to write to object
     * @returns the Sha512 object
     */
    put(bytes) {
        this.hash.update(bytes);
        return this;
    }
    /**
     * Compute SHA512 hash and slice in half
     *
     * @returns half of a SHA512 hash
     */
    finish256() {
        return Uint8Array.from(this.hash.digest().slice(0, 32));
    }
    /**
     * Constructs a Hash256 from the Sha512Half object
     *
     * @returns a Hash256 object
     */
    finish() {
        return new types_1.Hash256(this.finish256());
    }
}
exports.Sha512Half = Sha512Half;
/**
 * compute SHA512 hash of a list of bytes
 *
 * @param args zero or more arguments to hash
 * @returns the sha512half hash of the arguments.
 */
function sha512Half(...args) {
    const hash = new Sha512Half();
    args.forEach((a) => hash.put(a));
    return hash.finish256();
}
exports.sha512Half = sha512Half;
/**
 * Construct a transactionID from a Serialized Transaction
 *
 * @param serialized bytes to hash
 * @returns a Hash256 object
 */
function transactionID(serialized) {
    return new types_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));
}
exports.transactionID = transactionID;
//# sourceMappingURL=hashes.js.map

/***/ }),

/***/ 67:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPE_MAP = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;
const coretypes_1 = __nccwpck_require__(1956);
const ledger_hashes_1 = __nccwpck_require__(831);
Object.defineProperty(exports, "decodeLedgerData", ({ enumerable: true, get: function () { return ledger_hashes_1.decodeLedgerData; } }));
const enums_1 = __nccwpck_require__(8039);
Object.defineProperty(exports, "XrplDefinitionsBase", ({ enumerable: true, get: function () { return enums_1.XrplDefinitionsBase; } }));
Object.defineProperty(exports, "TRANSACTION_TYPES", ({ enumerable: true, get: function () { return enums_1.TRANSACTION_TYPES; } }));
Object.defineProperty(exports, "TRANSACTION_TYPE_MAP", ({ enumerable: true, get: function () { return enums_1.TRANSACTION_TYPE_MAP; } }));
Object.defineProperty(exports, "DEFAULT_DEFINITIONS", ({ enumerable: true, get: function () { return enums_1.DEFAULT_DEFINITIONS; } }));
const xahau_definitions_1 = __nccwpck_require__(8925);
Object.defineProperty(exports, "XrplDefinitions", ({ enumerable: true, get: function () { return xahau_definitions_1.XrplDefinitions; } }));
const types_1 = __nccwpck_require__(3659);
Object.defineProperty(exports, "coreTypes", ({ enumerable: true, get: function () { return types_1.coreTypes; } }));
const utils_1 = __nccwpck_require__(3617);
const { signingData, signingClaimData, multiSigningData, binaryToJSON, serializeObject, } = coretypes_1.binary;
/**
 * Decode a transaction
 *
 * @param binary hex-string of the encoded transaction
 * @param definitions Custom xahaud types to use instead of the default. Used for sidechains and amendments.
 * @returns the JSON representation of the transaction
 */
function decode(binary, definitions) {
    if (typeof binary !== 'string') {
        throw new Error('binary must be a hex string');
    }
    return binaryToJSON(binary, definitions);
}
exports.decode = decode;
/**
 * Encode a transaction
 *
 * @param json The JSON representation of a transaction
 * @param definitions Custom xahaud types to use instead of the default. Used for sidechains and amendments.
 *
 * @returns A hex-string of the encoded transaction
 */
function encode(json, definitions) {
    if (typeof json !== 'object') {
        throw new Error();
    }
    return (0, utils_1.bytesToHex)(serializeObject(json, { definitions }));
}
exports.encode = encode;
/**
 * Encode a transaction and prepare for signing
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @param definitions Custom xahaud types to use instead of the default. Used for sidechains and amendments.
 * @returns a hex string of the encoded transaction
 */
function encodeForSigning(json, definitions) {
    if (typeof json !== 'object') {
        throw new Error();
    }
    return (0, utils_1.bytesToHex)(signingData(json, coretypes_1.HashPrefix.transactionSig, {
        definitions,
    }));
}
exports.encodeForSigning = encodeForSigning;
/**
 * Encode a transaction and prepare for signing with a claim
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @param definitions Custom xahaud types to use instead of the default. Used for sidechains and amendments.
 * @returns a hex string of the encoded transaction
 */
function encodeForSigningClaim(json) {
    if (typeof json !== 'object') {
        throw new Error();
    }
    return (0, utils_1.bytesToHex)(signingClaimData(json));
}
exports.encodeForSigningClaim = encodeForSigningClaim;
/**
 * Encode a transaction and prepare for multi-signing
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @param definitions Custom xahaud types to use instead of the default. Used for sidechains and amendments.
 * @returns a hex string of the encoded transaction
 */
function encodeForMultisigning(json, signer, definitions) {
    if (typeof json !== 'object') {
        throw new Error();
    }
    if (json['SigningPubKey'] !== '') {
        throw new Error();
    }
    const definitionsOpt = definitions ? { definitions } : undefined;
    return (0, utils_1.bytesToHex)(multiSigningData(json, signer, definitionsOpt));
}
exports.encodeForMultisigning = encodeForMultisigning;
/**
 * Encode a quality value
 *
 * @param value string representation of a number
 * @returns a hex-string representing the quality
 */
function encodeQuality(value) {
    if (typeof value !== 'string') {
        throw new Error();
    }
    return (0, utils_1.bytesToHex)(coretypes_1.quality.encode(value));
}
exports.encodeQuality = encodeQuality;
/**
 * Decode a quality value
 *
 * @param value hex-string of a quality
 * @returns a string representing the quality
 */
function decodeQuality(value) {
    if (typeof value !== 'string') {
        throw new Error();
    }
    return coretypes_1.quality.decode(value).toString();
}
exports.decodeQuality = decodeQuality;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 831:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;
const shamap_1 = __nccwpck_require__(1661);
const hash_prefixes_1 = __nccwpck_require__(525);
const hashes_1 = __nccwpck_require__(2179);
const binary_1 = __nccwpck_require__(3529);
const hash_256_1 = __nccwpck_require__(9755);
const st_object_1 = __nccwpck_require__(3057);
const uint_64_1 = __nccwpck_require__(8930);
const uint_32_1 = __nccwpck_require__(3996);
const uint_8_1 = __nccwpck_require__(5426);
const binary_parser_1 = __nccwpck_require__(5956);
/**
 * Computes the hash of a list of objects
 *
 * @param itemizer Converts an item into a format that can be added to SHAMap
 * @param itemsJson Array of items to add to a SHAMap
 * @returns the hash of the SHAMap
 */
function computeHash(itemizer, itemsJson) {
    const map = new shamap_1.ShaMap();
    itemsJson.forEach((item) => map.addItem(...itemizer(item)));
    return map.hash();
}
/**
 * Convert a transaction into an index and an item
 *
 * @param json transaction with metadata
 * @returns a tuple of index and item to be added to SHAMap
 */
function transactionItemizer(json) {
    if (!json.hash) {
        throw new Error();
    }
    const index = hash_256_1.Hash256.from(json.hash);
    const item = {
        hashPrefix() {
            return hash_prefixes_1.HashPrefix.transaction;
        },
        toBytesSink(sink) {
            const serializer = new binary_1.BinarySerializer(sink);
            serializer.writeLengthEncoded(st_object_1.STObject.from(json));
            serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
        },
    };
    return [index, item, undefined];
}
/**
 * Convert an entry to a pair Hash256 and ShaMapNode
 *
 * @param json JSON describing a ledger entry item
 * @returns a tuple of index and item to be added to SHAMap
 */
function entryItemizer(json) {
    const index = hash_256_1.Hash256.from(json.index);
    const bytes = (0, binary_1.serializeObject)(json);
    const item = {
        hashPrefix() {
            return hash_prefixes_1.HashPrefix.accountStateEntry;
        },
        toBytesSink(sink) {
            sink.put(bytes);
        },
    };
    return [index, item, undefined];
}
/**
 * Function computing the hash of a transaction tree
 *
 * @param param An array of transaction objects to hash
 * @returns A Hash256 object
 */
function transactionTreeHash(param) {
    const itemizer = transactionItemizer;
    return computeHash(itemizer, param);
}
exports.transactionTreeHash = transactionTreeHash;
/**
 * Function computing the hash of accountState
 *
 * @param param A list of accountStates hash
 * @returns A Hash256 object
 */
function accountStateHash(param) {
    const itemizer = entryItemizer;
    return computeHash(itemizer, param);
}
exports.accountStateHash = accountStateHash;
/**
 * Serialize and hash a ledger header
 *
 * @param header a ledger header
 * @returns the hash of header
 */
function ledgerHash(header) {
    const hash = new hashes_1.Sha512Half();
    hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);
    if (header.parent_close_time === undefined ||
        header.close_flags === undefined) {
        throw new Error();
    }
    uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);
    uint_64_1.UInt64.from(BigInt(String(header.total_coins))).toBytesSink(hash);
    hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);
    hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);
    hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);
    uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);
    uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);
    uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);
    uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);
    return hash.finish();
}
exports.ledgerHash = ledgerHash;
/**
 * Decodes a serialized ledger header
 *
 * @param binary A serialized ledger header
 * @param definitions Type definitions to parse the ledger objects.
 *      Used if there are non-default ledger objects to decode.
 * @returns A JSON object describing a ledger header
 */
function decodeLedgerData(binary, definitions) {
    if (typeof binary !== 'string') {
        throw new Error('binary must be a hex string');
    }
    const parser = new binary_parser_1.BinaryParser(binary, definitions);
    return {
        ledger_index: parser.readUInt32(),
        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
        account_hash: parser.readType(hash_256_1.Hash256).toHex(),
        parent_close_time: parser.readUInt32(),
        close_time: parser.readUInt32(),
        close_time_resolution: parser.readUInt8(),
        close_flags: parser.readUInt8(),
    };
}
exports.decodeLedgerData = decodeLedgerData;
//# sourceMappingURL=ledger-hashes.js.map

/***/ }),

/***/ 4088:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.quality = void 0;
const types_1 = __nccwpck_require__(3659);
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const utils_1 = __nccwpck_require__(3617);
/**
 * class for encoding and decoding quality
 */
class quality {
    /**
     * Encode quality amount
     *
     * @param arg string representation of an amount
     * @returns Serialized quality
     */
    static encode(quality) {
        const decimal = (0, bignumber_js_1.default)(quality);
        const exponent = ((decimal === null || decimal === void 0 ? void 0 : decimal.e) || 0) - 15;
        const qualityString = decimal.times(`1e${-exponent}`).abs().toString();
        const bytes = types_1.coreTypes.UInt64.from(BigInt(qualityString)).toBytes();
        bytes[0] = exponent + 100;
        return bytes;
    }
    /**
     * Decode quality amount
     *
     * @param arg hex-string denoting serialized quality
     * @returns deserialized quality
     */
    static decode(quality) {
        const bytes = (0, utils_1.hexToBytes)(quality).slice(-8);
        const exponent = bytes[0] - 100;
        const mantissa = new bignumber_js_1.default(`0x${(0, utils_1.bytesToHex)(bytes.slice(1))}`);
        return mantissa.times(`1e${exponent}`);
    }
}
exports.quality = quality;
//# sourceMappingURL=quality.js.map

/***/ }),

/***/ 5956:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BinaryParser = void 0;
const enums_1 = __nccwpck_require__(8039);
const utils_1 = __nccwpck_require__(3617);
/**
 * BinaryParser is used to compute fields and values from a HexString
 */
class BinaryParser {
    /**
     * Initialize bytes to a hex string
     *
     * @param hexBytes a hex string
     * @param definitions Rippled definitions used to parse the values of transaction types and such.
     *                          Can be customized for sidechains and amendments.
     */
    constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {
        this.bytes = (0, utils_1.hexToBytes)(hexBytes);
        this.definitions = definitions;
    }
    /**
     * Peek the first byte of the BinaryParser
     *
     * @returns The first byte of the BinaryParser
     */
    peek() {
        if (this.bytes.byteLength === 0) {
            throw new Error();
        }
        return this.bytes[0];
    }
    /**
     * Consume the first n bytes of the BinaryParser
     *
     * @param n the number of bytes to skip
     */
    skip(n) {
        if (n > this.bytes.byteLength) {
            throw new Error();
        }
        this.bytes = this.bytes.slice(n);
    }
    /**
     * read the first n bytes from the BinaryParser
     *
     * @param n The number of bytes to read
     * @return The bytes
     */
    read(n) {
        if (n > this.bytes.byteLength) {
            throw new Error();
        }
        const slice = this.bytes.slice(0, n);
        this.skip(n);
        return slice;
    }
    /**
     * Read an integer of given size
     *
     * @param n The number of bytes to read
     * @return The number represented by those bytes
     */
    readUIntN(n) {
        if (0 >= n || n > 4) {
            throw new Error('invalid n');
        }
        return this.read(n).reduce((a, b) => (a << 8) | b) >>> 0;
    }
    readUInt8() {
        return this.readUIntN(1);
    }
    readUInt16() {
        return this.readUIntN(2);
    }
    readUInt32() {
        return this.readUIntN(4);
    }
    size() {
        return this.bytes.byteLength;
    }
    end(customEnd) {
        const length = this.bytes.byteLength;
        return length === 0 || (customEnd !== undefined && length <= customEnd);
    }
    /**
     * Reads variable length encoded bytes
     *
     * @return The variable length bytes
     */
    readVariableLength() {
        return this.read(this.readVariableLengthLength());
    }
    /**
     * Reads the length of the variable length encoded bytes
     *
     * @return The length of the variable length encoded bytes
     */
    readVariableLengthLength() {
        const b1 = this.readUInt8();
        if (b1 <= 192) {
            return b1;
        }
        else if (b1 <= 240) {
            const b2 = this.readUInt8();
            return 193 + (b1 - 193) * 256 + b2;
        }
        else if (b1 <= 254) {
            const b2 = this.readUInt8();
            const b3 = this.readUInt8();
            return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
        }
        throw new Error('Invalid variable length indicator');
    }
    /**
     * Reads the field ordinal from the BinaryParser
     *
     * @return Field ordinal
     */
    readFieldOrdinal() {
        let type = this.readUInt8();
        let nth = type & 15;
        type >>= 4;
        if (type === 0) {
            type = this.readUInt8();
            if (type === 0 || type < 16) {
                throw new Error(`Cannot read FieldOrdinal, type_code ${type} out of range`);
            }
        }
        if (nth === 0) {
            nth = this.readUInt8();
            if (nth === 0 || nth < 16) {
                throw new Error(`Cannot read FieldOrdinal, field_code ${nth} out of range`);
            }
        }
        return (type << 16) | nth;
    }
    /**
     * Read the field from the BinaryParser
     *
     * @return The field represented by the bytes at the head of the BinaryParser
     */
    readField() {
        return this.definitions.field.fromString(this.readFieldOrdinal().toString());
    }
    /**
     * Read a given type from the BinaryParser
     *
     * @param type The type that you want to read from the BinaryParser
     * @return The instance of that type read from the BinaryParser
     */
    readType(type) {
        return type.fromParser(this);
    }
    /**
     * Get the type associated with a given field
     *
     * @param field The field that you wan to get the type of
     * @return The type associated with the given field
     */
    typeForField(field) {
        return field.associatedType;
    }
    /**
     * Read value of the type specified by field from the BinaryParser
     *
     * @param field The field that you want to get the associated value for
     * @return The value associated with the given field
     */
    readFieldValue(field) {
        const type = this.typeForField(field);
        if (!type) {
            throw new Error(`unsupported: (${field.name}, ${field.type.name})`);
        }
        const sizeHint = field.isVariableLengthEncoded
            ? this.readVariableLengthLength()
            : undefined;
        const value = type.fromParser(this, sizeHint);
        if (value === undefined) {
            throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);
        }
        return value;
    }
    /**
     * Get the next field and value from the BinaryParser
     *
     * @return The field and value
     */
    readFieldAndValue() {
        const field = this.readField();
        return [field, this.readFieldValue(field)];
    }
}
exports.BinaryParser = BinaryParser;
//# sourceMappingURL=binary-parser.js.map

/***/ }),

/***/ 2412:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BinarySerializer = exports.BytesList = void 0;
const utils_1 = __nccwpck_require__(3617);
/**
 * Bytes list is a collection of Uint8Array objects
 */
class BytesList {
    constructor() {
        this.bytesArray = [];
    }
    /**
     * Get the total number of bytes in the BytesList
     *
     * @return the number of bytes
     */
    getLength() {
        return (0, utils_1.concat)(this.bytesArray).byteLength;
    }
    /**
     * Put bytes in the BytesList
     *
     * @param bytesArg A Uint8Array
     * @return this BytesList
     */
    put(bytesArg) {
        const bytes = Uint8Array.from(bytesArg); // Temporary, to catch instances of Uint8Array being passed in
        this.bytesArray.push(bytes);
        return this;
    }
    /**
     * Write this BytesList to the back of another bytes list
     *
     *  @param list The BytesList to write to
     */
    toBytesSink(list) {
        list.put(this.toBytes());
    }
    toBytes() {
        return (0, utils_1.concat)(this.bytesArray);
    }
    toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
    }
}
exports.BytesList = BytesList;
/**
 * BinarySerializer is used to write fields and values to Uint8Arrays
 */
class BinarySerializer {
    constructor(sink) {
        this.sink = new BytesList();
        this.sink = sink;
    }
    /**
     * Write a value to this BinarySerializer
     *
     * @param value a SerializedType value
     */
    write(value) {
        value.toBytesSink(this.sink);
    }
    /**
     * Write bytes to this BinarySerializer
     *
     * @param bytes the bytes to write
     */
    put(bytes) {
        this.sink.put(bytes);
    }
    /**
     * Write a value of a given type to this BinarySerializer
     *
     * @param type the type to write
     * @param value a value of that type
     */
    writeType(type, value) {
        this.write(type.from(value));
    }
    /**
     * Write BytesList to this BinarySerializer
     *
     * @param bl BytesList to write to BinarySerializer
     */
    writeBytesList(bl) {
        bl.toBytesSink(this.sink);
    }
    /**
     * Calculate the header of Variable Length encoded bytes
     *
     * @param length the length of the bytes
     */
    encodeVariableLength(length) {
        const lenBytes = new Uint8Array(3);
        if (length <= 192) {
            lenBytes[0] = length;
            return lenBytes.slice(0, 1);
        }
        else if (length <= 12480) {
            length -= 193;
            lenBytes[0] = 193 + (length >>> 8);
            lenBytes[1] = length & 0xff;
            return lenBytes.slice(0, 2);
        }
        else if (length <= 918744) {
            length -= 12481;
            lenBytes[0] = 241 + (length >>> 16);
            lenBytes[1] = (length >> 8) & 0xff;
            lenBytes[2] = length & 0xff;
            return lenBytes.slice(0, 3);
        }
        throw new Error('Overflow error');
    }
    /**
     * Write field and value to BinarySerializer
     *
     * @param field field to write to BinarySerializer
     * @param value value to write to BinarySerializer
     */
    writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {
        const associatedValue = field.associatedType.from(value);
        if (associatedValue.toBytesSink === undefined || field.name === undefined) {
            throw new Error();
        }
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
            this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        }
        else {
            associatedValue.toBytesSink(this.sink);
        }
    }
    /**
     * Write a variable length encoded value to the BinarySerializer
     *
     * @param value length encoded value to write to BytesList
     */
    writeLengthEncoded(value, isUnlModifyWorkaround = false) {
        const bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
            // this part doesn't happen for the Account field in a UNLModify transaction
            value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
    }
}
exports.BinarySerializer = BinarySerializer;
//# sourceMappingURL=binary-serializer.js.map

/***/ }),

/***/ 1661:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;
const types_1 = __nccwpck_require__(3659);
const hash_prefixes_1 = __nccwpck_require__(525);
const hashes_1 = __nccwpck_require__(2179);
/**
 * Abstract class describing a SHAMapNode
 */
class ShaMapNode {
}
exports.ShaMapNode = ShaMapNode;
/**
 * Class describing a Leaf of SHAMap
 */
class ShaMapLeaf extends ShaMapNode {
    constructor(index, item) {
        super();
        this.index = index;
        this.item = item;
    }
    /**
     * @returns true as ShaMapLeaf is a leaf node
     */
    isLeaf() {
        return true;
    }
    /**
     * @returns false as ShaMapLeaf is not an inner node
     */
    isInner() {
        return false;
    }
    /**
     * Get the prefix of the this.item
     *
     * @returns The hash prefix, unless this.item is undefined, then it returns an empty Uint8Array
     */
    hashPrefix() {
        return this.item === undefined ? new Uint8Array(0) : this.item.hashPrefix();
    }
    /**
     * Hash the bytes representation of this
     *
     * @returns hash of this.item concatenated with this.index
     */
    hash() {
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
    }
    /**
     * Write the bytes representation of this to a BytesList
     * @param list BytesList to write bytes to
     */
    toBytesSink(list) {
        if (this.item !== undefined) {
            this.item.toBytesSink(list);
        }
        this.index.toBytesSink(list);
    }
}
exports.ShaMapLeaf = ShaMapLeaf;
/**
 * Class defining an Inner Node of a SHAMap
 */
class ShaMapInner extends ShaMapNode {
    constructor(depth = 0) {
        super();
        this.depth = depth;
        this.slotBits = 0;
        this.branches = Array(16);
    }
    /**
     * @returns true as ShaMapInner is an inner node
     */
    isInner() {
        return true;
    }
    /**
     * @returns false as ShaMapInner is not a leaf node
     */
    isLeaf() {
        return false;
    }
    /**
     * Get the hash prefix for this node
     *
     * @returns hash prefix describing an inner node
     */
    hashPrefix() {
        return hash_prefixes_1.HashPrefix.innerNode;
    }
    /**
     * Set a branch of this node to be another node
     *
     * @param slot Slot to add branch to this.branches
     * @param branch Branch to add
     */
    setBranch(slot, branch) {
        this.slotBits = this.slotBits | (1 << slot);
        this.branches[slot] = branch;
    }
    /**
     * @returns true if node is empty
     */
    empty() {
        return this.slotBits === 0;
    }
    /**
     * Compute the hash of this node
     *
     * @returns The hash of this node
     */
    hash() {
        if (this.empty()) {
            return types_1.coreTypes.Hash256.ZERO_256;
        }
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
    }
    /**
     * Writes the bytes representation of this node to a BytesList
     *
     * @param list BytesList to write bytes to
     */
    toBytesSink(list) {
        for (let i = 0; i < this.branches.length; i++) {
            const branch = this.branches[i];
            const hash = branch
                ? branch.hash()
                : types_1.coreTypes.Hash256.ZERO_256;
            hash.toBytesSink(list);
        }
    }
    /**
     * Add item to the SHAMap
     *
     * @param index Hash of the index of the item being inserted
     * @param item Item to insert in the map
     * @param leaf Leaf node to insert when branch doesn't exist
     */
    addItem(index, item, leaf) {
        if (index === undefined) {
            throw new Error();
        }
        if (index !== undefined) {
            const nibble = index.nibblet(this.depth);
            const existing = this.branches[nibble];
            if (existing === undefined) {
                this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
            }
            else if (existing instanceof ShaMapLeaf) {
                const newInner = new ShaMapInner(this.depth + 1);
                newInner.addItem(existing.index, undefined, existing);
                newInner.addItem(index, item, leaf);
                this.setBranch(nibble, newInner);
            }
            else if (existing instanceof ShaMapInner) {
                existing.addItem(index, item, leaf);
            }
            else {
                throw new Error('invalid ShaMap.addItem call');
            }
        }
    }
}
class ShaMap extends ShaMapInner {
}
exports.ShaMap = ShaMap;
//# sourceMappingURL=shamap.js.map

/***/ }),

/***/ 1601:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountID = void 0;
const xahau_address_codec_1 = __nccwpck_require__(647);
const hash_160_1 = __nccwpck_require__(1981);
const utils_1 = __nccwpck_require__(3617);
const HEX_REGEX = /^[A-F0-9]{40}$/;
/**
 * Class defining how to encode and decode an AccountID
 */
class AccountID extends hash_160_1.Hash160 {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : AccountID.defaultAccountID.bytes);
    }
    /**
     * Defines how to construct an AccountID
     *
     * @param value either an existing AccountID, a hex-string, or a base58 r-Address
     * @returns an AccountID object
     */
    static from(value) {
        if (value instanceof AccountID) {
            return value;
        }
        if (typeof value === 'string') {
            if (value === '') {
                return new AccountID();
            }
            return HEX_REGEX.test(value)
                ? new AccountID((0, utils_1.hexToBytes)(value))
                : this.fromBase58(value);
        }
        throw new Error('Cannot construct AccountID from value given');
    }
    /**
     * Defines how to build an AccountID from a base58 r-Address
     *
     * @param value a base58 r-Address
     * @returns an AccountID object
     */
    static fromBase58(value) {
        if ((0, xahau_address_codec_1.isValidXAddress)(value)) {
            const classic = (0, xahau_address_codec_1.xAddressToClassicAddress)(value);
            if (classic.tag !== false)
                throw new Error('Only allowed to have tag on Account or Destination');
            value = classic.classicAddress;
        }
        return new AccountID(Uint8Array.from((0, xahau_address_codec_1.decodeAccountID)(value)));
    }
    /**
     * Overload of toJSON
     *
     * @returns the base58 string for this AccountID
     */
    toJSON() {
        return this.toBase58();
    }
    /**
     * Defines how to encode AccountID into a base58 address
     *
     * @returns the base58 string defined by this.bytes
     */
    toBase58() {
        return (0, xahau_address_codec_1.encodeAccountID)(this.bytes);
    }
}
exports.AccountID = AccountID;
AccountID.defaultAccountID = new AccountID(new Uint8Array(20));
//# sourceMappingURL=account-id.js.map

/***/ }),

/***/ 3936:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Amount = void 0;
const binary_parser_1 = __nccwpck_require__(5956);
const account_id_1 = __nccwpck_require__(1601);
const currency_1 = __nccwpck_require__(195);
const serialized_type_1 = __nccwpck_require__(1375);
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const utils_1 = __nccwpck_require__(3617);
const utils_2 = __nccwpck_require__(2758);
/**
 * Constants for validating amounts
 */
const MIN_IOU_EXPONENT = -96;
const MAX_IOU_EXPONENT = 80;
const MAX_IOU_PRECISION = 16;
const MAX_DROPS = new bignumber_js_1.default('1e17');
const MIN_XAH = new bignumber_js_1.default('1e-6');
const mask = BigInt(0x00000000ffffffff);
/**
 * BigNumber configuration for Amount IOUs
 */
bignumber_js_1.default.config({
    EXPONENTIAL_AT: [
        MIN_IOU_EXPONENT - MAX_IOU_PRECISION,
        MAX_IOU_EXPONENT + MAX_IOU_PRECISION,
    ],
});
/**
 * Type guard for AmountObject
 */
function isAmountObject(arg) {
    const keys = Object.keys(arg).sort();
    return (keys.length === 3 &&
        keys[0] === 'currency' &&
        keys[1] === 'issuer' &&
        keys[2] === 'value');
}
/**
 * Class for serializing/Deserializing Amounts
 */
class Amount extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : Amount.defaultAmount.bytes);
    }
    /**
     * Construct an amount from an IOU or string amount
     *
     * @param value An Amount, object representing an IOU, or a string
     *     representing an integer amount
     * @returns An Amount object
     */
    static from(value) {
        if (value instanceof Amount) {
            return value;
        }
        let amount = new Uint8Array(8);
        if (typeof value === 'string') {
            Amount.assertXrpIsValid(value);
            const number = BigInt(value);
            const intBuf = [new Uint8Array(4), new Uint8Array(4)];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);
            amount = (0, utils_1.concat)(intBuf);
            amount[0] |= 0x40;
            return new Amount(amount);
        }
        if (isAmountObject(value)) {
            const number = new bignumber_js_1.default(value.value);
            Amount.assertIouIsValid(number);
            if (number.isZero()) {
                amount[0] |= 0x80;
            }
            else {
                const integerNumberString = number
                    .times(`1e${-((number.e || 0) - 15)}`)
                    .abs()
                    .toString();
                const num = BigInt(integerNumberString);
                const intBuf = [new Uint8Array(4), new Uint8Array(4)];
                (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
                (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);
                amount = (0, utils_1.concat)(intBuf);
                amount[0] |= 0x80;
                if (number.gt(new bignumber_js_1.default(0))) {
                    amount[0] |= 0x40;
                }
                const exponent = (number.e || 0) - 15;
                const exponentByte = 97 + exponent;
                amount[0] |= exponentByte >>> 2;
                amount[1] |= (exponentByte & 0x03) << 6;
            }
            const currency = currency_1.Currency.from(value.currency).toBytes();
            const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
            return new Amount((0, utils_1.concat)([amount, currency, issuer]));
        }
        throw new Error('Invalid type to construct an Amount');
    }
    /**
     * Read an amount from a BinaryParser
     *
     * @param parser BinaryParser to read the Amount from
     * @returns An Amount object
     */
    static fromParser(parser) {
        const isXAH = parser.peek() & 0x80;
        const numBytes = isXAH ? 48 : 8;
        return new Amount(parser.read(numBytes));
    }
    /**
     * Get the JSON representation of this Amount
     *
     * @returns the JSON interpretation of this.bytes
     */
    toJSON() {
        if (this.isNative()) {
            const bytes = this.bytes;
            const isPositive = bytes[0] & 0x40;
            const sign = isPositive ? '' : '-';
            bytes[0] &= 0x3f;
            const msb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(0, 4), 0));
            const lsb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(4), 0));
            const num = (msb << BigInt(32)) | lsb;
            return `${sign}${num.toString()}`;
        }
        else {
            const parser = new binary_parser_1.BinaryParser(this.toString());
            const mantissa = parser.read(8);
            const currency = currency_1.Currency.fromParser(parser);
            const issuer = account_id_1.AccountID.fromParser(parser);
            const b1 = mantissa[0];
            const b2 = mantissa[1];
            const isPositive = b1 & 0x40;
            const sign = isPositive ? '' : '-';
            const exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97;
            mantissa[0] = 0;
            mantissa[1] &= 0x3f;
            const value = new bignumber_js_1.default(`${sign}0x${(0, utils_1.bytesToHex)(mantissa)}`).times(`1e${exponent}`);
            Amount.assertIouIsValid(value);
            return {
                value: value.toString(),
                currency: currency.toJSON(),
                issuer: issuer.toJSON(),
            };
        }
    }
    /**
     * Validate XAH amount
     *
     * @param amount String representing XAH amount
     * @returns void, but will throw if invalid amount
     */
    static assertXrpIsValid(amount) {
        if (amount.indexOf('.') !== -1) {
            throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
            if (decimal.lt(MIN_XAH) || decimal.gt(MAX_DROPS)) {
                throw new Error(`${amount.toString()} is an illegal amount`);
            }
        }
    }
    /**
     * Validate IOU.value amount
     *
     * @param decimal BigNumber object representing IOU.value
     * @returns void, but will throw if invalid amount
     */
    static assertIouIsValid(decimal) {
        if (!decimal.isZero()) {
            const p = decimal.precision();
            const e = (decimal.e || 0) - 15;
            if (p > MAX_IOU_PRECISION ||
                e > MAX_IOU_EXPONENT ||
                e < MIN_IOU_EXPONENT) {
                throw new Error('Decimal precision out of range');
            }
            this.verifyNoDecimal(decimal);
        }
    }
    /**
     * Ensure that the value after being multiplied by the exponent does not
     * contain a decimal.
     *
     * @param decimal a Decimal object
     * @returns a string of the object without a decimal
     */
    static verifyNoDecimal(decimal) {
        const integerNumberString = decimal
            .times(`1e${-((decimal.e || 0) - 15)}`)
            .abs()
            .toString();
        if (integerNumberString.indexOf('.') !== -1) {
            throw new Error('Decimal place found in integerNumberString');
        }
    }
    /**
     * Test if this amount is in units of Native Currency(XAH)
     *
     * @returns true if Native (XAH)
     */
    isNative() {
        return (this.bytes[0] & 0x80) === 0;
    }
}
exports.Amount = Amount;
Amount.defaultAmount = new Amount((0, utils_1.hexToBytes)('4000000000000000'));
//# sourceMappingURL=amount.js.map

/***/ }),

/***/ 2320:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Blob = void 0;
const serialized_type_1 = __nccwpck_require__(1375);
const utils_1 = __nccwpck_require__(3617);
/**
 * Variable length encoded type
 */
class Blob extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes);
    }
    /**
     * Defines how to read a Blob from a BinaryParser
     *
     * @param parser The binary parser to read the Blob from
     * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
     * @returns A Blob object
     */
    static fromParser(parser, hint) {
        return new Blob(parser.read(hint));
    }
    /**
     * Create a Blob object from a hex-string
     *
     * @param value existing Blob object or a hex-string
     * @returns A Blob object
     */
    static from(value) {
        if (value instanceof Blob) {
            return value;
        }
        if (typeof value === 'string') {
            if (!/^[A-F0-9]*$/iu.test(value)) {
                throw new Error('Cannot construct Blob from a non-hex string');
            }
            return new Blob((0, utils_1.hexToBytes)(value));
        }
        throw new Error('Cannot construct Blob from value given');
    }
}
exports.Blob = Blob;
//# sourceMappingURL=blob.js.map

/***/ }),

/***/ 195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Currency = void 0;
const hash_160_1 = __nccwpck_require__(1981);
const utils_1 = __nccwpck_require__(3617);
const XAH_HEX_REGEX = /^0{40}$/;
const ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
const HEX_REGEX = /^[A-F0-9]{40}$/;
// eslint-disable-next-line no-control-regex
const STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
/**
 * Convert an ISO code to a currency bytes representation
 */
function isoToBytes(iso) {
    const bytes = new Uint8Array(20);
    if (iso !== 'XAH') {
        const isoBytes = iso.split('').map((c) => c.charCodeAt(0));
        bytes.set(isoBytes, 12);
    }
    return bytes;
}
/**
 * Tests if ISO is a valid iso code
 */
function isIsoCode(iso) {
    return ISO_REGEX.test(iso);
}
function isoCodeFromHex(code) {
    const iso = (0, utils_1.hexToString)((0, utils_1.bytesToHex)(code));
    if (iso === 'XAH') {
        return null;
    }
    if (isIsoCode(iso)) {
        return iso;
    }
    return null;
}
/**
 * Tests if hex is a valid hex-string
 */
function isHex(hex) {
    return HEX_REGEX.test(hex);
}
/**
 * Tests if a string is a valid representation of a currency
 */
function isStringRepresentation(input) {
    return input.length === 3 || isHex(input);
}
/**
 * Tests if a Uint8Array is a valid representation of a currency
 */
function isBytesArray(bytes) {
    return bytes.byteLength === 20;
}
/**
 * Ensures that a value is a valid representation of a currency
 */
function isValidRepresentation(input) {
    return input instanceof Uint8Array
        ? isBytesArray(input)
        : isStringRepresentation(input);
}
/**
 * Generate bytes from a string or UInt8Array representation of a currency
 */
function bytesFromRepresentation(input) {
    if (!isValidRepresentation(input)) {
        throw new Error(`Unsupported Currency representation: ${input}`);
    }
    return input.length === 3 ? isoToBytes(input) : (0, utils_1.hexToBytes)(input);
}
/**
 * Class defining how to encode and decode Currencies
 */
class Currency extends hash_160_1.Hash160 {
    constructor(byteBuf) {
        super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : Currency.XAH.bytes);
        const hex = (0, utils_1.bytesToHex)(this.bytes);
        if (XAH_HEX_REGEX.test(hex)) {
            this._iso = 'XAH';
        }
        else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {
            this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
        }
        else {
            this._iso = null;
        }
    }
    /**
     * Return the ISO code of this currency
     *
     * @returns ISO code if it exists, else null
     */
    iso() {
        return this._iso;
    }
    /**
     * Constructs a Currency object
     *
     * @param val Currency object or a string representation of a currency
     */
    static from(value) {
        if (value instanceof Currency) {
            return value;
        }
        if (typeof value === 'string') {
            return new Currency(bytesFromRepresentation(value));
        }
        throw new Error('Cannot construct Currency from value given');
    }
    /**
     * Gets the JSON representation of a currency
     *
     * @returns JSON representation
     */
    toJSON() {
        const iso = this.iso();
        if (iso !== null) {
            return iso;
        }
        return (0, utils_1.bytesToHex)(this.bytes);
    }
}
exports.Currency = Currency;
Currency.XAH = new Currency(new Uint8Array(20));
//# sourceMappingURL=currency.js.map

/***/ }),

/***/ 6908:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash128 = void 0;
const hash_1 = __nccwpck_require__(8756);
const utils_1 = __nccwpck_require__(3617);
/**
 * Hash with a width of 128 bits
 */
class Hash128 extends hash_1.Hash {
    constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
            bytes = Hash128.ZERO_128.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : Hash128.ZERO_128.bytes);
    }
    /**
     * Get the hex representation of a hash-128 bytes, allowing unset
     *
     * @returns hex String of this.bytes
     */
    toHex() {
        const hex = (0, utils_1.bytesToHex)(this.toBytes());
        if (/^0+$/.exec(hex)) {
            return '';
        }
        return hex;
    }
}
exports.Hash128 = Hash128;
Hash128.width = 16;
Hash128.ZERO_128 = new Hash128(new Uint8Array(Hash128.width));
//# sourceMappingURL=hash-128.js.map

/***/ }),

/***/ 1981:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash160 = void 0;
const hash_1 = __nccwpck_require__(8756);
/**
 * Hash with a width of 160 bits
 */
class Hash160 extends hash_1.Hash {
    constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
            bytes = Hash160.ZERO_160.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : Hash160.ZERO_160.bytes);
    }
}
exports.Hash160 = Hash160;
Hash160.width = 20;
Hash160.ZERO_160 = new Hash160(new Uint8Array(Hash160.width));
//# sourceMappingURL=hash-160.js.map

/***/ }),

/***/ 9755:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash256 = void 0;
const hash_1 = __nccwpck_require__(8756);
/**
 * Hash with a width of 256 bits
 */
class Hash256 extends hash_1.Hash {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : Hash256.ZERO_256.bytes);
    }
}
exports.Hash256 = Hash256;
Hash256.width = 32;
Hash256.ZERO_256 = new Hash256(new Uint8Array(Hash256.width));
//# sourceMappingURL=hash-256.js.map

/***/ }),

/***/ 8756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash = void 0;
const serialized_type_1 = __nccwpck_require__(1375);
const utils_1 = __nccwpck_require__(3617);
const utils_2 = __nccwpck_require__(2758);
/**
 * Base class defining how to encode and decode hashes
 */
class Hash extends serialized_type_1.Comparable {
    constructor(bytes) {
        super(bytes);
        if (this.bytes.length !== this.constructor.width) {
            throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
        }
    }
    /**
     * Construct a Hash object from an existing Hash object or a hex-string
     *
     * @param value A hash object or hex-string of a hash
     */
    static from(value) {
        if (value instanceof this) {
            return value;
        }
        if (typeof value === 'string') {
            return new this((0, utils_1.hexToBytes)(value));
        }
        throw new Error('Cannot construct Hash from given value');
    }
    /**
     * Read a Hash object from a BinaryParser
     *
     * @param parser BinaryParser to read the hash from
     * @param hint length of the bytes to read, optional
     */
    static fromParser(parser, hint) {
        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
    }
    /**
     * Overloaded operator for comparing two hash objects
     *
     * @param other The Hash to compare this to
     */
    compareTo(other) {
        return (0, utils_2.compare)(this.bytes, this.constructor.from(other).bytes);
    }
    /**
     * @returns the hex-string representation of this Hash
     */
    toString() {
        return this.toHex();
    }
    /**
     * Returns four bits at the specified depth within a hash
     *
     * @param depth The depth of the four bits
     * @returns The number represented by the four bits
     */
    nibblet(depth) {
        const byteIx = depth > 0 ? (depth / 2) | 0 : 0;
        let b = this.bytes[byteIx];
        if (depth % 2 === 0) {
            b = (b & 0xf0) >>> 4;
        }
        else {
            b = b & 0x0f;
        }
        return b;
    }
}
exports.Hash = Hash;
//# sourceMappingURL=hash.js.map

/***/ }),

/***/ 3659:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;
const account_id_1 = __nccwpck_require__(1601);
Object.defineProperty(exports, "AccountID", ({ enumerable: true, get: function () { return account_id_1.AccountID; } }));
const amount_1 = __nccwpck_require__(3936);
Object.defineProperty(exports, "Amount", ({ enumerable: true, get: function () { return amount_1.Amount; } }));
const blob_1 = __nccwpck_require__(2320);
Object.defineProperty(exports, "Blob", ({ enumerable: true, get: function () { return blob_1.Blob; } }));
const currency_1 = __nccwpck_require__(195);
Object.defineProperty(exports, "Currency", ({ enumerable: true, get: function () { return currency_1.Currency; } }));
const hash_128_1 = __nccwpck_require__(6908);
Object.defineProperty(exports, "Hash128", ({ enumerable: true, get: function () { return hash_128_1.Hash128; } }));
const hash_160_1 = __nccwpck_require__(1981);
Object.defineProperty(exports, "Hash160", ({ enumerable: true, get: function () { return hash_160_1.Hash160; } }));
const hash_256_1 = __nccwpck_require__(9755);
Object.defineProperty(exports, "Hash256", ({ enumerable: true, get: function () { return hash_256_1.Hash256; } }));
const issue_1 = __nccwpck_require__(4271);
const path_set_1 = __nccwpck_require__(6099);
Object.defineProperty(exports, "PathSet", ({ enumerable: true, get: function () { return path_set_1.PathSet; } }));
const st_array_1 = __nccwpck_require__(6695);
Object.defineProperty(exports, "STArray", ({ enumerable: true, get: function () { return st_array_1.STArray; } }));
const st_object_1 = __nccwpck_require__(3057);
Object.defineProperty(exports, "STObject", ({ enumerable: true, get: function () { return st_object_1.STObject; } }));
const uint_16_1 = __nccwpck_require__(8615);
Object.defineProperty(exports, "UInt16", ({ enumerable: true, get: function () { return uint_16_1.UInt16; } }));
const uint_32_1 = __nccwpck_require__(3996);
Object.defineProperty(exports, "UInt32", ({ enumerable: true, get: function () { return uint_32_1.UInt32; } }));
const uint_64_1 = __nccwpck_require__(8930);
Object.defineProperty(exports, "UInt64", ({ enumerable: true, get: function () { return uint_64_1.UInt64; } }));
const uint_8_1 = __nccwpck_require__(5426);
Object.defineProperty(exports, "UInt8", ({ enumerable: true, get: function () { return uint_8_1.UInt8; } }));
const vector_256_1 = __nccwpck_require__(1987);
Object.defineProperty(exports, "Vector256", ({ enumerable: true, get: function () { return vector_256_1.Vector256; } }));
const xchain_bridge_1 = __nccwpck_require__(6146);
const enums_1 = __nccwpck_require__(8039);
const coreTypes = {
    AccountID: account_id_1.AccountID,
    Amount: amount_1.Amount,
    Blob: blob_1.Blob,
    Currency: currency_1.Currency,
    Hash128: hash_128_1.Hash128,
    Hash160: hash_160_1.Hash160,
    Hash256: hash_256_1.Hash256,
    Issue: issue_1.Issue,
    PathSet: path_set_1.PathSet,
    STArray: st_array_1.STArray,
    STObject: st_object_1.STObject,
    UInt8: uint_8_1.UInt8,
    UInt16: uint_16_1.UInt16,
    UInt32: uint_32_1.UInt32,
    UInt64: uint_64_1.UInt64,
    Vector256: vector_256_1.Vector256,
    XChainBridge: xchain_bridge_1.XChainBridge,
};
exports.coreTypes = coreTypes;
// Ensures that the DEFAULT_DEFINITIONS object connects these types to fields for serializing/deserializing
// This is done here instead of in enums/index.ts to avoid a circular dependency
// because some of the above types depend on BinarySerializer which depends on enums/index.ts.
enums_1.DEFAULT_DEFINITIONS.associateTypes(coreTypes);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4271:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Issue = void 0;
const utils_1 = __nccwpck_require__(3617);
const binary_parser_1 = __nccwpck_require__(5956);
const account_id_1 = __nccwpck_require__(1601);
const currency_1 = __nccwpck_require__(195);
const serialized_type_1 = __nccwpck_require__(1375);
/**
 * Type guard for AmountObject
 */
function isIssueObject(arg) {
    const keys = Object.keys(arg).sort();
    if (keys.length === 1) {
        return keys[0] === 'currency';
    }
    return keys.length === 2 && keys[0] === 'currency' && keys[1] === 'issuer';
}
/**
 * Class for serializing/Deserializing Amounts
 */
class Issue extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : Issue.ZERO_ISSUED_CURRENCY.bytes);
    }
    /**
     * Construct an amount from an IOU or string amount
     *
     * @param value An Amount, object representing an IOU, or a string
     *     representing an integer amount
     * @returns An Amount object
     */
    static from(value) {
        if (value instanceof Issue) {
            return value;
        }
        if (isIssueObject(value)) {
            const currency = currency_1.Currency.from(value.currency).toBytes();
            if (value.issuer == null) {
                return new Issue(currency);
            }
            const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
            return new Issue((0, utils_1.concat)([currency, issuer]));
        }
        throw new Error('Invalid type to construct an Amount');
    }
    /**
     * Read an amount from a BinaryParser
     *
     * @param parser BinaryParser to read the Amount from
     * @returns An Amount object
     */
    static fromParser(parser) {
        const currency = parser.read(20);
        if (new currency_1.Currency(currency).toJSON() === 'XAH') {
            return new Issue(currency);
        }
        const currencyAndIssuer = [currency, parser.read(20)];
        return new Issue((0, utils_1.concat)(currencyAndIssuer));
    }
    /**
     * Get the JSON representation of this Amount
     *
     * @returns the JSON interpretation of this.bytes
     */
    toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const currency = currency_1.Currency.fromParser(parser);
        if (currency.toJSON() === 'XAH') {
            return { currency: currency.toJSON() };
        }
        const issuer = account_id_1.AccountID.fromParser(parser);
        return {
            currency: currency.toJSON(),
            issuer: issuer.toJSON(),
        };
    }
}
exports.Issue = Issue;
Issue.ZERO_ISSUED_CURRENCY = new Issue(new Uint8Array(20));
//# sourceMappingURL=issue.js.map

/***/ }),

/***/ 6099:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PathSet = void 0;
const account_id_1 = __nccwpck_require__(1601);
const currency_1 = __nccwpck_require__(195);
const binary_parser_1 = __nccwpck_require__(5956);
const serialized_type_1 = __nccwpck_require__(1375);
const utils_1 = __nccwpck_require__(3617);
/**
 * Constants for separating Paths in a PathSet
 */
const PATHSET_END_BYTE = 0x00;
const PATH_SEPARATOR_BYTE = 0xff;
/**
 * Constant for masking types of a Hop
 */
const TYPE_ACCOUNT = 0x01;
const TYPE_CURRENCY = 0x10;
const TYPE_ISSUER = 0x20;
/**
 * TypeGuard for HopObject
 */
function isHopObject(arg) {
    return (arg.issuer !== undefined ||
        arg.account !== undefined ||
        arg.currency !== undefined);
}
/**
 * TypeGuard for PathSet
 */
function isPathSet(arg) {
    return ((Array.isArray(arg) && arg.length === 0) ||
        (Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0) ||
        (Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0])));
}
/**
 * Serialize and Deserialize a Hop
 */
class Hop extends serialized_type_1.SerializedType {
    /**
     * Create a Hop from a HopObject
     *
     * @param value Either a hop or HopObject to create a hop with
     * @returns a Hop
     */
    static from(value) {
        if (value instanceof Hop) {
            return value;
        }
        const bytes = [Uint8Array.from([0])];
        if (value.account) {
            bytes.push(account_id_1.AccountID.from(value.account).toBytes());
            bytes[0][0] |= TYPE_ACCOUNT;
        }
        if (value.currency) {
            bytes.push(currency_1.Currency.from(value.currency).toBytes());
            bytes[0][0] |= TYPE_CURRENCY;
        }
        if (value.issuer) {
            bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());
            bytes[0][0] |= TYPE_ISSUER;
        }
        return new Hop((0, utils_1.concat)(bytes));
    }
    /**
     * Construct a Hop from a BinaryParser
     *
     * @param parser BinaryParser to read the Hop from
     * @returns a Hop
     */
    static fromParser(parser) {
        const type = parser.readUInt8();
        const bytes = [Uint8Array.from([type])];
        if (type & TYPE_ACCOUNT) {
            bytes.push(parser.read(account_id_1.AccountID.width));
        }
        if (type & TYPE_CURRENCY) {
            bytes.push(parser.read(currency_1.Currency.width));
        }
        if (type & TYPE_ISSUER) {
            bytes.push(parser.read(account_id_1.AccountID.width));
        }
        return new Hop((0, utils_1.concat)(bytes));
    }
    /**
     * Get the JSON interpretation of this hop
     *
     * @returns a HopObject, an JS object with optional account, issuer, and currency
     */
    toJSON() {
        const hopParser = new binary_parser_1.BinaryParser((0, utils_1.bytesToHex)(this.bytes));
        const type = hopParser.readUInt8();
        let account, currency, issuer;
        if (type & TYPE_ACCOUNT) {
            account = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_CURRENCY) {
            currency = currency_1.Currency.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_ISSUER) {
            issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        const result = {};
        if (account) {
            result.account = account;
        }
        if (issuer) {
            result.issuer = issuer;
        }
        if (currency) {
            result.currency = currency;
        }
        return result;
    }
    /**
     * get a number representing the type of this hop
     *
     * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
     */
    type() {
        return this.bytes[0];
    }
}
/**
 * Class for serializing/deserializing Paths
 */
class Path extends serialized_type_1.SerializedType {
    /**
     * construct a Path from an array of Hops
     *
     * @param value Path or array of HopObjects to construct a Path
     * @returns the Path
     */
    static from(value) {
        if (value instanceof Path) {
            return value;
        }
        const bytes = [];
        value.forEach((hop) => {
            bytes.push(Hop.from(hop).toBytes());
        });
        return new Path((0, utils_1.concat)(bytes));
    }
    /**
     * Read a Path from a BinaryParser
     *
     * @param parser BinaryParser to read Path from
     * @returns the Path represented by the bytes read from the BinaryParser
     */
    static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
            bytes.push(Hop.fromParser(parser).toBytes());
            if (parser.peek() === PATHSET_END_BYTE ||
                parser.peek() === PATH_SEPARATOR_BYTE) {
                break;
            }
        }
        return new Path((0, utils_1.concat)(bytes));
    }
    /**
     * Get the JSON representation of this Path
     *
     * @returns an Array of HopObject constructed from this.bytes
     */
    toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
            json.push(Hop.fromParser(pathParser).toJSON());
        }
        return json;
    }
}
/**
 * Deserialize and Serialize the PathSet type
 */
class PathSet extends serialized_type_1.SerializedType {
    /**
     * Construct a PathSet from an Array of Arrays representing paths
     *
     * @param value A PathSet or Array of Array of HopObjects
     * @returns the PathSet constructed from value
     */
    static from(value) {
        if (value instanceof PathSet) {
            return value;
        }
        if (isPathSet(value)) {
            const bytes = [];
            value.forEach((path) => {
                bytes.push(Path.from(path).toBytes());
                bytes.push(Uint8Array.from([PATH_SEPARATOR_BYTE]));
            });
            bytes[bytes.length - 1] = Uint8Array.from([PATHSET_END_BYTE]);
            return new PathSet((0, utils_1.concat)(bytes));
        }
        throw new Error('Cannot construct PathSet from given value');
    }
    /**
     * Construct a PathSet from a BinaryParser
     *
     * @param parser A BinaryParser to read PathSet from
     * @returns the PathSet read from parser
     */
    static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
            bytes.push(Path.fromParser(parser).toBytes());
            bytes.push(parser.read(1));
            if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {
                break;
            }
        }
        return new PathSet((0, utils_1.concat)(bytes));
    }
    /**
     * Get the JSON representation of this PathSet
     *
     * @returns an Array of Array of HopObjects, representing this PathSet
     */
    toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
            json.push(Path.fromParser(pathParser).toJSON());
            pathParser.skip(1);
        }
        return json;
    }
}
exports.PathSet = PathSet;
//# sourceMappingURL=path-set.js.map

/***/ }),

/***/ 1375:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Comparable = exports.SerializedType = void 0;
const binary_serializer_1 = __nccwpck_require__(2412);
const utils_1 = __nccwpck_require__(3617);
/**
 * The base class for all binary-codec types
 */
class SerializedType {
    constructor(bytes) {
        this.bytes = new Uint8Array(0);
        this.bytes = bytes !== null && bytes !== void 0 ? bytes : new Uint8Array(0);
    }
    static fromParser(parser, hint) {
        throw new Error('fromParser not implemented');
        return this.fromParser(parser, hint);
    }
    static from(value) {
        throw new Error('from not implemented');
        return this.from(value);
    }
    /**
     * Write the bytes representation of a SerializedType to a BytesList
     *
     * @param list The BytesList to write SerializedType bytes to
     */
    toBytesSink(list) {
        list.put(this.bytes);
    }
    /**
     * Get the hex representation of a SerializedType's bytes
     *
     * @returns hex String of this.bytes
     */
    toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
    }
    /**
     * Get the bytes representation of a SerializedType
     *
     * @returns A Uint8Array of the bytes
     */
    toBytes() {
        if (this.bytes) {
            return this.bytes;
        }
        const bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
    }
    /**
     * Return the JSON representation of a SerializedType
     *
     * @param _definitions xahaud definitions used to parse the values of transaction types and such.
     *                          Unused in default, but used in STObject, STArray
     *                          Can be customized for sidechains and amendments.
     * @returns any type, if not overloaded returns hexString representation of bytes
     */
    toJSON(_definitions) {
        return this.toHex();
    }
    /**
     * @returns hexString representation of this.bytes
     */
    toString() {
        return this.toHex();
    }
}
exports.SerializedType = SerializedType;
/**
 * Base class for SerializedTypes that are comparable.
 *
 * @template T - What types you want to allow comparisons between. You must specify all types. Primarily used to allow
 * comparisons between built-in types (like `string`) and SerializedType subclasses (like `Hash`).
 *
 * Ex. `class Hash extends Comparable<Hash | string>`
 */
class Comparable extends SerializedType {
    lt(other) {
        return this.compareTo(other) < 0;
    }
    eq(other) {
        return this.compareTo(other) === 0;
    }
    gt(other) {
        return this.compareTo(other) > 0;
    }
    gte(other) {
        return this.compareTo(other) > -1;
    }
    lte(other) {
        return this.compareTo(other) < 1;
    }
    /**
     * Overload this method to define how two Comparable SerializedTypes are compared
     *
     * @param other The comparable object to compare this to
     * @returns A number denoting the relationship of this and other
     */
    compareTo(other) {
        throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);
    }
}
exports.Comparable = Comparable;
//# sourceMappingURL=serialized-type.js.map

/***/ }),

/***/ 6695:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STArray = void 0;
const enums_1 = __nccwpck_require__(8039);
const serialized_type_1 = __nccwpck_require__(1375);
const st_object_1 = __nccwpck_require__(3057);
const binary_parser_1 = __nccwpck_require__(5956);
const utils_1 = __nccwpck_require__(3617);
const ARRAY_END_MARKER = Uint8Array.from([0xf1]);
const ARRAY_END_MARKER_NAME = 'ArrayEndMarker';
const OBJECT_END_MARKER = Uint8Array.from([0xe1]);
/**
 * TypeGuard for Array<JsonObject>
 */
function isObjects(args) {
    return (Array.isArray(args) &&
        args.every((arg) => typeof arg === 'object' &&
            Object.keys(arg).length === 1 &&
            typeof Object.values(arg)[0] === 'object'));
}
/**
 * Class for serializing and deserializing Arrays of Objects
 */
class STArray extends serialized_type_1.SerializedType {
    /**
     * Construct an STArray from a BinaryParser
     *
     * @param parser BinaryParser to parse an STArray from
     * @returns An STArray Object
     */
    static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
            const field = parser.readField();
            if (field.name === ARRAY_END_MARKER_NAME) {
                break;
            }
            bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);
        }
        bytes.push(ARRAY_END_MARKER);
        return new STArray((0, utils_1.concat)(bytes));
    }
    /**
     * Construct an STArray from an Array of JSON Objects
     *
     * @param value STArray or Array of Objects to parse into an STArray
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns An STArray object
     */
    static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof STArray) {
            return value;
        }
        if (isObjects(value)) {
            const bytes = [];
            value.forEach((obj) => {
                bytes.push(st_object_1.STObject.from(obj, undefined, definitions).toBytes());
            });
            bytes.push(ARRAY_END_MARKER);
            return new STArray((0, utils_1.concat)(bytes));
        }
        throw new Error('Cannot construct STArray from value given');
    }
    /**
     * Return the JSON representation of this.bytes
     *
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns An Array of JSON objects
     */
    toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {
        const result = [];
        const arrayParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        while (!arrayParser.end()) {
            const field = arrayParser.readField();
            if (field.name === ARRAY_END_MARKER_NAME) {
                break;
            }
            const outer = {};
            outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);
            result.push(outer);
        }
        return result;
    }
}
exports.STArray = STArray;
//# sourceMappingURL=st-array.js.map

/***/ }),

/***/ 3057:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STObject = void 0;
const enums_1 = __nccwpck_require__(8039);
const serialized_type_1 = __nccwpck_require__(1375);
const xahau_address_codec_1 = __nccwpck_require__(647);
const binary_parser_1 = __nccwpck_require__(5956);
const binary_serializer_1 = __nccwpck_require__(2412);
const st_array_1 = __nccwpck_require__(6695);
const OBJECT_END_MARKER_BYTE = Uint8Array.from([0xe1]);
const OBJECT_END_MARKER = 'ObjectEndMarker';
const ST_OBJECT = 'STObject';
const DESTINATION = 'Destination';
const ACCOUNT = 'Account';
const SOURCE_TAG = 'SourceTag';
const DEST_TAG = 'DestinationTag';
/**
 * Break down an X-Address into an account and a tag
 *
 * @param field Name of field
 * @param xAddress X-Address corresponding to the field
 */
function handleXAddress(field, xAddress) {
    const decoded = (0, xahau_address_codec_1.xAddressToClassicAddress)(xAddress);
    let tagName;
    if (field === DESTINATION)
        tagName = DEST_TAG;
    else if (field === ACCOUNT)
        tagName = SOURCE_TAG;
    else if (decoded.tag !== false)
        throw new Error(`${field} cannot have an associated tag`);
    return decoded.tag !== false
        ? { [field]: decoded.classicAddress, [tagName]: decoded.tag }
        : { [field]: decoded.classicAddress };
}
/**
 * Validate that two objects don't both have the same tag fields
 *
 * @param obj1 First object to check for tags
 * @param obj2 Second object to check for tags
 * @throws When both objects have SourceTag or DestinationTag
 */
function checkForDuplicateTags(obj1, obj2) {
    if (!(obj1[SOURCE_TAG] === undefined || obj2[SOURCE_TAG] === undefined))
        throw new Error('Cannot have Account X-Address and SourceTag');
    if (!(obj1[DEST_TAG] === undefined || obj2[DEST_TAG] === undefined))
        throw new Error('Cannot have Destination X-Address and DestinationTag');
}
/**
 * Class for Serializing/Deserializing objects
 */
class STObject extends serialized_type_1.SerializedType {
    /**
     * Construct a STObject from a BinaryParser
     *
     * @param parser BinaryParser to read STObject from
     * @returns A STObject object
     */
    static fromParser(parser) {
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        while (!parser.end()) {
            const field = parser.readField();
            if (field.name === OBJECT_END_MARKER) {
                break;
            }
            const associatedValue = parser.readFieldValue(field);
            bytes.writeFieldAndValue(field, associatedValue);
            if (field.type.name === ST_OBJECT) {
                bytes.put(OBJECT_END_MARKER_BYTE);
            }
        }
        return new STObject(list.toBytes());
    }
    /**
     * Construct a STObject from a JSON object
     *
     * @param value An object to include
     * @param filter optional, denote which field to include in serialized object
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns a STObject object
     */
    static from(value, filter, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof STObject) {
            return value;
        }
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        let isUnlModify = false;
        const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {
            let handled = undefined;
            if (val && (0, xahau_address_codec_1.isValidXAddress)(val.toString())) {
                handled = handleXAddress(key, val.toString());
                checkForDuplicateTags(handled, value);
            }
            return Object.assign(acc, handled !== null && handled !== void 0 ? handled : { [key]: val });
        }, {});
        let sorted = Object.keys(xAddressDecoded)
            .map((f) => definitions.field[f])
            .filter((f) => f !== undefined &&
            xAddressDecoded[f.name] !== undefined &&
            f.isSerialized)
            .sort((a, b) => {
            return a.ordinal - b.ordinal;
        });
        if (filter !== undefined) {
            sorted = sorted.filter(filter);
        }
        sorted.forEach((field) => {
            const associatedValue = field.type.name === ST_OBJECT
                ? this.from(xAddressDecoded[field.name], undefined, definitions)
                : field.type.name === 'STArray'
                    ? st_array_1.STArray.from(xAddressDecoded[field.name], definitions)
                    : field.associatedType.from(xAddressDecoded[field.name]);
            if (associatedValue == undefined) {
                throw new TypeError(`Unable to interpret "${field.name}: ${xAddressDecoded[field.name]}".`);
            }
            if (associatedValue.name === 'UNLModify') {
                // triggered when the TransactionType field has a value of 'UNLModify'
                isUnlModify = true;
            }
            // true when in the UNLModify pseudotransaction (after the transaction type has been processed) and working with the
            // Account field
            // The Account field must not be a part of the UNLModify pseudotransaction encoding, due to a bug in xahaud
            const isUnlModifyWorkaround = field.name == 'Account' && isUnlModify;
            bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);
            if (field.type.name === ST_OBJECT) {
                bytes.put(OBJECT_END_MARKER_BYTE);
            }
        });
        return new STObject(list.toBytes());
    }
    /**
     * Get the JSON interpretation of this.bytes
     * @param definitions xahaud definitions used to parse the values of transaction types and such.
     *                          Can be customized for sidechains and amendments.
     * @returns a JSON object
     */
    toJSON(definitions) {
        const objectParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        const accumulator = {};
        while (!objectParser.end()) {
            const field = objectParser.readField();
            if (field.name === OBJECT_END_MARKER) {
                break;
            }
            accumulator[field.name] = objectParser
                .readFieldValue(field)
                .toJSON(definitions);
        }
        return accumulator;
    }
}
exports.STObject = STObject;
//# sourceMappingURL=st-object.js.map

/***/ }),

/***/ 8615:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt16 = void 0;
const uint_1 = __nccwpck_require__(8853);
const utils_1 = __nccwpck_require__(2758);
/**
 * Derived UInt class for serializing/deserializing 16 bit UInt
 */
class UInt16 extends uint_1.UInt {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : UInt16.defaultUInt16.bytes);
    }
    static fromParser(parser) {
        return new UInt16(parser.read(UInt16.width));
    }
    /**
     * Construct a UInt16 object from a number
     *
     * @param val UInt16 object or number
     */
    static from(val) {
        if (val instanceof UInt16) {
            return val;
        }
        if (typeof val === 'number') {
            UInt16.checkUintRange(val, 0, 0xffff);
            const buf = new Uint8Array(UInt16.width);
            (0, utils_1.writeUInt16BE)(buf, val, 0);
            return new UInt16(buf);
        }
        throw new Error('Can not construct UInt16 with given value');
    }
    /**
     * get the value of a UInt16 object
     *
     * @returns the number represented by this.bytes
     */
    valueOf() {
        return parseInt((0, utils_1.readUInt16BE)(this.bytes, 0));
    }
}
exports.UInt16 = UInt16;
UInt16.width = 16 / 8; // 2
UInt16.defaultUInt16 = new UInt16(new Uint8Array(UInt16.width));
//# sourceMappingURL=uint-16.js.map

/***/ }),

/***/ 3996:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt32 = void 0;
const uint_1 = __nccwpck_require__(8853);
const utils_1 = __nccwpck_require__(2758);
/**
 * Derived UInt class for serializing/deserializing 32 bit UInt
 */
class UInt32 extends uint_1.UInt {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : UInt32.defaultUInt32.bytes);
    }
    static fromParser(parser) {
        return new UInt32(parser.read(UInt32.width));
    }
    /**
     * Construct a UInt32 object from a number
     *
     * @param val UInt32 object or number
     */
    static from(val) {
        if (val instanceof UInt32) {
            return val;
        }
        const buf = new Uint8Array(UInt32.width);
        if (typeof val === 'string') {
            const num = Number.parseInt(val);
            (0, utils_1.writeUInt32BE)(buf, num, 0);
            return new UInt32(buf);
        }
        if (typeof val === 'number') {
            UInt32.checkUintRange(val, 0, 0xffffffff);
            (0, utils_1.writeUInt32BE)(buf, val, 0);
            return new UInt32(buf);
        }
        throw new Error('Cannot construct UInt32 from given value');
    }
    /**
     * get the value of a UInt32 object
     *
     * @returns the number represented by this.bytes
     */
    valueOf() {
        return parseInt((0, utils_1.readUInt32BE)(this.bytes, 0), 10);
    }
}
exports.UInt32 = UInt32;
UInt32.width = 32 / 8; // 4
UInt32.defaultUInt32 = new UInt32(new Uint8Array(UInt32.width));
//# sourceMappingURL=uint-32.js.map

/***/ }),

/***/ 8930:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt64 = void 0;
const uint_1 = __nccwpck_require__(8853);
const utils_1 = __nccwpck_require__(3617);
const utils_2 = __nccwpck_require__(2758);
const HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
const mask = BigInt(0x00000000ffffffff);
/**
 * Derived UInt class for serializing/deserializing 64 bit UInt
 */
class UInt64 extends uint_1.UInt {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : UInt64.defaultUInt64.bytes);
    }
    static fromParser(parser) {
        return new UInt64(parser.read(UInt64.width));
    }
    /**
     * Construct a UInt64 object
     *
     * @param val A UInt64, hex-string, bigInt, or number
     * @returns A UInt64 object
     */
    static from(val) {
        if (val instanceof UInt64) {
            return val;
        }
        let buf = new Uint8Array(UInt64.width);
        if (typeof val === 'number') {
            if (val < 0) {
                throw new Error('value must be an unsigned integer');
            }
            const number = BigInt(val);
            const intBuf = [new Uint8Array(4), new Uint8Array(4)];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);
            return new UInt64((0, utils_1.concat)(intBuf));
        }
        if (typeof val === 'string') {
            if (!HEX_REGEX.test(val)) {
                throw new Error(`${val} is not a valid hex-string`);
            }
            const strBuf = val.padStart(16, '0');
            buf = (0, utils_1.hexToBytes)(strBuf);
            return new UInt64(buf);
        }
        if (typeof val === 'bigint') {
            const intBuf = [new Uint8Array(4), new Uint8Array(4)];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(Number(val >> BigInt(32))), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(val & BigInt(mask)), 0);
            return new UInt64((0, utils_1.concat)(intBuf));
        }
        throw new Error('Cannot construct UInt64 from given value');
    }
    /**
     * The JSON representation of a UInt64 object
     *
     * @returns a hex-string
     */
    toJSON() {
        return (0, utils_1.bytesToHex)(this.bytes);
    }
    /**
     * Get the value of the UInt64
     *
     * @returns the number represented buy this.bytes
     */
    valueOf() {
        const msb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(0, 4), 0));
        const lsb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(4), 0));
        return (msb << BigInt(32)) | lsb;
    }
    /**
     * Get the bytes representation of the UInt64 object
     *
     * @returns 8 bytes representing the UInt64
     */
    toBytes() {
        return this.bytes;
    }
}
exports.UInt64 = UInt64;
UInt64.width = 64 / 8; // 8
UInt64.defaultUInt64 = new UInt64(new Uint8Array(UInt64.width));
//# sourceMappingURL=uint-64.js.map

/***/ }),

/***/ 5426:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt8 = void 0;
const uint_1 = __nccwpck_require__(8853);
const utils_1 = __nccwpck_require__(3617);
const utils_2 = __nccwpck_require__(2758);
/**
 * Derived UInt class for serializing/deserializing 8 bit UInt
 */
class UInt8 extends uint_1.UInt {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : UInt8.defaultUInt8.bytes);
    }
    static fromParser(parser) {
        return new UInt8(parser.read(UInt8.width));
    }
    /**
     * Construct a UInt8 object from a number
     *
     * @param val UInt8 object or number
     */
    static from(val) {
        if (val instanceof UInt8) {
            return val;
        }
        if (typeof val === 'number') {
            UInt8.checkUintRange(val, 0, 0xff);
            const buf = new Uint8Array(UInt8.width);
            (0, utils_2.writeUInt8)(buf, val, 0);
            return new UInt8(buf);
        }
        throw new Error('Cannot construct UInt8 from given value');
    }
    /**
     * get the value of a UInt8 object
     *
     * @returns the number represented by this.bytes
     */
    valueOf() {
        return parseInt((0, utils_1.bytesToHex)(this.bytes), 16);
    }
}
exports.UInt8 = UInt8;
UInt8.width = 8 / 8; // 1
UInt8.defaultUInt8 = new UInt8(new Uint8Array(UInt8.width));
//# sourceMappingURL=uint-8.js.map

/***/ }),

/***/ 8853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt = void 0;
const serialized_type_1 = __nccwpck_require__(1375);
/**
 * Compare numbers and bigInts n1 and n2
 *
 * @param n1 First object to compare
 * @param n2 Second object to compare
 * @returns -1, 0, or 1, depending on how the two objects compare
 */
function compare(n1, n2) {
    return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
}
/**
 * Base class for serializing and deserializing unsigned integers.
 */
class UInt extends serialized_type_1.Comparable {
    constructor(bytes) {
        super(bytes);
    }
    /**
     * Overload of compareTo for Comparable
     *
     * @param other other UInt to compare this to
     * @returns -1, 0, or 1 depending on how the objects relate to each other
     */
    compareTo(other) {
        return compare(this.valueOf(), other.valueOf());
    }
    /**
     * Convert a UInt object to JSON
     *
     * @returns number or string represented by this.bytes
     */
    toJSON() {
        const val = this.valueOf();
        return typeof val === 'number' ? val : val.toString();
    }
    static checkUintRange(val, min, max) {
        if (val < min || val > max) {
            throw new Error(`Invalid ${this.constructor.name}: ${val} must be >= ${min} and <= ${max}`);
        }
    }
}
exports.UInt = UInt;
//# sourceMappingURL=uint.js.map

/***/ }),

/***/ 1987:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vector256 = void 0;
const serialized_type_1 = __nccwpck_require__(1375);
const hash_256_1 = __nccwpck_require__(9755);
const binary_serializer_1 = __nccwpck_require__(2412);
const utils_1 = __nccwpck_require__(3617);
/**
 * TypeGuard for Array<string>
 */
function isStrings(arg) {
    return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === 'string');
}
/**
 * Class for serializing and deserializing vectors of Hash256
 */
class Vector256 extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes);
    }
    /**
     * Construct a Vector256 from a BinaryParser
     *
     * @param parser BinaryParser to
     * @param hint length of the vector, in bytes, optional
     * @returns a Vector256 object
     */
    static fromParser(parser, hint) {
        const bytesList = new binary_serializer_1.BytesList();
        const bytes = hint !== null && hint !== void 0 ? hint : parser.size();
        const hashes = bytes / 32;
        for (let i = 0; i < hashes; i++) {
            hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);
        }
        return new Vector256(bytesList.toBytes());
    }
    /**
     * Construct a Vector256 object from an array of hashes
     *
     * @param value A Vector256 object or array of hex-strings representing Hash256's
     * @returns a Vector256 object
     */
    static from(value) {
        if (value instanceof Vector256) {
            return value;
        }
        if (isStrings(value)) {
            const bytesList = new binary_serializer_1.BytesList();
            value.forEach((hash) => {
                hash_256_1.Hash256.from(hash).toBytesSink(bytesList);
            });
            return new Vector256(bytesList.toBytes());
        }
        throw new Error('Cannot construct Vector256 from given value');
    }
    /**
     * Return an Array of hex-strings represented by this.bytes
     *
     * @returns An Array of strings representing the Hash256 objects
     */
    toJSON() {
        if (this.bytes.byteLength % 32 !== 0) {
            throw new Error('Invalid bytes for Vector256');
        }
        const result = [];
        for (let i = 0; i < this.bytes.byteLength; i += 32) {
            result.push((0, utils_1.bytesToHex)(this.bytes.slice(i, i + 32)));
        }
        return result;
    }
}
exports.Vector256 = Vector256;
//# sourceMappingURL=vector-256.js.map

/***/ }),

/***/ 6146:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XChainBridge = void 0;
const binary_parser_1 = __nccwpck_require__(5956);
const account_id_1 = __nccwpck_require__(1601);
const serialized_type_1 = __nccwpck_require__(1375);
const issue_1 = __nccwpck_require__(4271);
const utils_1 = __nccwpck_require__(3617);
/**
 * Type guard for XChainBridgeObject
 */
function isXChainBridgeObject(arg) {
    const keys = Object.keys(arg).sort();
    return (keys.length === 4 &&
        keys[0] === 'IssuingChainDoor' &&
        keys[1] === 'IssuingChainIssue' &&
        keys[2] === 'LockingChainDoor' &&
        keys[3] === 'LockingChainIssue');
}
/**
 * Class for serializing/deserializing XChainBridges
 */
class XChainBridge extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);
    }
    /**
     * Construct a cross-chain bridge from a JSON
     *
     * @param value XChainBridge or JSON to parse into an XChainBridge
     * @returns An XChainBridge object
     */
    static from(value) {
        if (value instanceof XChainBridge) {
            return value;
        }
        if (!isXChainBridgeObject(value)) {
            throw new Error('Invalid type to construct an XChainBridge');
        }
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
            const { name, type } = item;
            if (type === account_id_1.AccountID) {
                bytes.push(Uint8Array.from([0x14]));
            }
            const object = type.from(value[name]);
            bytes.push(object.toBytes());
        });
        return new XChainBridge((0, utils_1.concat)(bytes));
    }
    /**
     * Read an XChainBridge from a BinaryParser
     *
     * @param parser BinaryParser to read the XChainBridge from
     * @returns An XChainBridge object
     */
    static fromParser(parser) {
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
            const { type } = item;
            if (type === account_id_1.AccountID) {
                parser.skip(1);
                bytes.push(Uint8Array.from([0x14]));
            }
            const object = type.fromParser(parser);
            bytes.push(object.toBytes());
        });
        return new XChainBridge((0, utils_1.concat)(bytes));
    }
    /**
     * Get the JSON representation of this XChainBridge
     *
     * @returns the JSON interpretation of this.bytes
     */
    toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const json = {};
        XChainBridge.TYPE_ORDER.forEach((item) => {
            const { name, type } = item;
            if (type === account_id_1.AccountID) {
                parser.skip(1);
            }
            const object = type.fromParser(parser).toJSON();
            json[name] = object;
        });
        return json;
    }
}
exports.XChainBridge = XChainBridge;
XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge((0, utils_1.concat)([
    Uint8Array.from([0x14]),
    new Uint8Array(40),
    Uint8Array.from([0x14]),
    new Uint8Array(40),
]));
XChainBridge.TYPE_ORDER = [
    { name: 'LockingChainDoor', type: account_id_1.AccountID },
    { name: 'LockingChainIssue', type: issue_1.Issue },
    { name: 'IssuingChainDoor', type: account_id_1.AccountID },
    { name: 'IssuingChainIssue', type: issue_1.Issue },
];
//# sourceMappingURL=xchain-bridge.js.map

/***/ }),

/***/ 2758:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compare = exports.equal = exports.readUInt32BE = exports.readUInt16BE = exports.writeUInt32BE = exports.writeUInt16BE = exports.writeUInt8 = void 0;
/**
 * Writes value to array at the specified offset. The value must be a valid unsigned 8-bit integer.
 * @param array Uint8Array to be written to
 * @param value Number to be written to array.
 * @param offset plus the number of bytes written.
 */
function writeUInt8(array, value, offset) {
    value = Number(value);
    array[offset] = value;
}
exports.writeUInt8 = writeUInt8;
/**
 * Writes value to array at the specified offset as big-endian. The value must be a valid unsigned 16-bit integer.
 * @param array Uint8Array to be written to
 * @param value Number to be written to array.
 * @param offset plus the number of bytes written.
 */
function writeUInt16BE(array, value, offset) {
    value = Number(value);
    array[offset] = value >>> 8;
    array[offset + 1] = value;
}
exports.writeUInt16BE = writeUInt16BE;
/**
 * Writes value to array at the specified offset as big-endian. The value must be a valid unsigned 32-bit integer.
 * @param array Uint8Array to be written to
 * @param value Number to be written to array.
 * @param offset plus the number of bytes written.
 */
function writeUInt32BE(array, value, offset) {
    array[offset] = (value >>> 24) & 0xff;
    array[offset + 1] = (value >>> 16) & 0xff;
    array[offset + 2] = (value >>> 8) & 0xff;
    array[offset + 3] = value & 0xff;
}
exports.writeUInt32BE = writeUInt32BE;
/**
 * Reads an unsigned, big-endian 16-bit integer from the array at the specified offset.
 * @param array Uint8Array to read
 * @param offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2
 */
function readUInt16BE(array, offset) {
    return new DataView(array.buffer).getUint16(offset, false).toString(10);
}
exports.readUInt16BE = readUInt16BE;
/**
 * Reads an unsigned, big-endian 16-bit integer from the array at the specified offset.
 * @param array Uint8Array to read
 * @param offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 */
function readUInt32BE(array, offset) {
    return new DataView(array.buffer).getUint32(offset, false).toString(10);
}
exports.readUInt32BE = readUInt32BE;
/**
 * Compares two Uint8Array or ArrayBuffers
 * @param a first array to compare
 * @param b second array to compare
 */
function equal(a, b) {
    const aUInt = a instanceof ArrayBuffer ? new Uint8Array(a, 0) : a;
    const bUInt = b instanceof ArrayBuffer ? new Uint8Array(b, 0) : b;
    if (aUInt.byteLength != bUInt.byteLength)
        return false;
    if (aligned32(aUInt) && aligned32(bUInt))
        return compare32(aUInt, bUInt) === 0;
    if (aligned16(aUInt) && aligned16(bUInt))
        return compare16(aUInt, bUInt) === 0;
    return compare8(aUInt, bUInt) === 0;
}
exports.equal = equal;
/**
 * Compares two 8 bit aligned arrays
 * @param a first array to compare
 * @param b second array to compare
 */
function compare8(a, b) {
    const ua = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    const ub = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
    return compare(ua, ub);
}
/**
 * Compares two 16 bit aligned arrays
 * @param a first array to compare
 * @param b second array to compare
 */
function compare16(a, b) {
    const ua = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const ub = new Uint16Array(b.buffer, b.byteOffset, b.byteLength / 2);
    return compare(ua, ub);
}
/**
 * Compares two 32 bit aligned arrays
 * @param a first array to compare
 * @param b second array to compare
 */
function compare32(a, b) {
    const ua = new Uint32Array(a.buffer, a.byteOffset, a.byteLength / 4);
    const ub = new Uint32Array(b.buffer, b.byteOffset, b.byteLength / 4);
    return compare(ua, ub);
}
/**
 * Compare two TypedArrays
 * @param a first array to compare
 * @param b second array to compare
 */
function compare(a, b) {
    if (a.byteLength !== b.byteLength) {
        throw new Error('Cannot compare arrays of different length');
    }
    for (let i = 0; i < a.length - 1; i += 1) {
        if (a[i] > b[i])
            return 1;
        if (a[i] < b[i])
            return -1;
    }
    return 0;
}
exports.compare = compare;
/**
 * Determine if TypedArray is 16 bit aligned
 * @param array The array to check
 */
function aligned16(array) {
    return array.byteOffset % 2 === 0 && array.byteLength % 2 === 0;
}
/**
 * Determine if TypedArray is 32 bit aligned
 * @param array The array to check
 */
function aligned32(array) {
    return array.byteOffset % 4 === 0 && array.byteLength % 4 === 0;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 4095:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;
const xahau_address_codec_1 = __nccwpck_require__(647);
Object.defineProperty(exports, "decodeSeed", ({ enumerable: true, get: function () { return xahau_address_codec_1.decodeSeed; } }));
const ripemd160_1 = __nccwpck_require__(8841);
const sha256_1 = __nccwpck_require__(8093);
const utils_1 = __nccwpck_require__(3617);
const utils_2 = __nccwpck_require__(1951);
const Sha512_1 = __importDefault(__nccwpck_require__(5086));
const assert_1 = __importDefault(__nccwpck_require__(8649));
const getAlgorithmFromKey_1 = __nccwpck_require__(352);
const secp256k1_1 = __importDefault(__nccwpck_require__(3163));
const ed25519_1 = __importDefault(__nccwpck_require__(2149));
function getSigningScheme(algorithm) {
    const schemes = { 'ecdsa-secp256k1': secp256k1_1.default, ed25519: ed25519_1.default };
    return schemes[algorithm];
}
function generateSeed(options = {}) {
    assert_1.default.ok(!options.entropy || options.entropy.length >= 16, 'entropy too short');
    const entropy = options.entropy
        ? options.entropy.slice(0, 16)
        : (0, utils_1.randomBytes)(16);
    const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';
    return (0, xahau_address_codec_1.encodeSeed)(entropy, type);
}
exports.generateSeed = generateSeed;
function deriveKeypair(seed, options) {
    var _a;
    const decoded = (0, xahau_address_codec_1.decodeSeed)(seed);
    const proposedAlgorithm = (_a = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a !== void 0 ? _a : decoded.type;
    const algorithm = proposedAlgorithm === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';
    const scheme = getSigningScheme(algorithm);
    const keypair = scheme.deriveKeypair(decoded.bytes, options);
    const messageToVerify = Sha512_1.default.half('This test message should verify.');
    const signature = scheme.sign(messageToVerify, keypair.privateKey);
    /* istanbul ignore if */
    if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {
        throw new Error('derived keypair did not generate verifiable signature');
    }
    return keypair;
}
exports.deriveKeypair = deriveKeypair;
function sign(messageHex, privateKey) {
    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);
    return getSigningScheme(algorithm).sign((0, utils_1.hexToBytes)(messageHex), privateKey);
}
exports.sign = sign;
function verify(messageHex, signature, publicKey) {
    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);
    return getSigningScheme(algorithm).verify((0, utils_1.hexToBytes)(messageHex), signature, publicKey);
}
exports.verify = verify;
function computePublicKeyHash(publicKeyBytes) {
    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));
}
function deriveAddressFromBytes(publicKeyBytes) {
    return (0, xahau_address_codec_1.encodeAccountID)(computePublicKeyHash(publicKeyBytes));
}
function deriveAddress(publicKey) {
    return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));
}
exports.deriveAddress = deriveAddress;
function deriveNodeAddress(publicKey) {
    const generatorBytes = (0, xahau_address_codec_1.decodeNodePublic)(publicKey);
    const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(generatorBytes);
    return deriveAddressFromBytes(accountPublicBytes);
}
exports.deriveNodeAddress = deriveNodeAddress;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2149:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ed25519_1 = __nccwpck_require__(9038);
const utils_1 = __nccwpck_require__(3617);
const assert_1 = __importDefault(__nccwpck_require__(8649));
const Sha512_1 = __importDefault(__nccwpck_require__(5086));
const ED_PREFIX = 'ED';
const ed25519 = {
    deriveKeypair(entropy) {
        const rawPrivateKey = Sha512_1.default.half(entropy);
        const privateKey = ED_PREFIX + (0, utils_1.bytesToHex)(rawPrivateKey);
        const publicKey = ED_PREFIX + (0, utils_1.bytesToHex)(ed25519_1.ed25519.getPublicKey(rawPrivateKey));
        return { privateKey, publicKey };
    },
    sign(message, privateKey) {
        assert_1.default.ok(message instanceof Uint8Array, 'message must be array of octets');
        assert_1.default.ok(privateKey.length === 66, 'private key must be 33 bytes including prefix');
        return (0, utils_1.bytesToHex)(ed25519_1.ed25519.sign(message, privateKey.slice(2)));
    },
    verify(message, signature, publicKey) {
        // Unlikely to be triggered as these are internal and guarded by getAlgorithmFromKey
        assert_1.default.ok(publicKey.length === 66, 'public key must be 33 bytes including prefix');
        return ed25519_1.ed25519.verify(signature, message, 
        // Remove the 0xED prefix
        publicKey.slice(2), 
        // By default, set zip215 to false for compatibility reasons.
        // ZIP 215 is a stricter Ed25519 signature verification scheme.
        // However, setting it to false adheres to the more commonly used
        // RFC8032 / NIST186-5 standards, making it compatible with systems
        // like the XAH Ledger.
        { zip215: false });
    },
};
exports["default"] = ed25519;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3163:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __nccwpck_require__(2210);
const secp256k1_1 = __nccwpck_require__(6379);
const utils_2 = __nccwpck_require__(3617);
const utils_3 = __nccwpck_require__(1951);
const assert_1 = __importDefault(__nccwpck_require__(8649));
const Sha512_1 = __importDefault(__nccwpck_require__(5086));
const SECP256K1_PREFIX = '00';
const secp256k1 = {
    deriveKeypair(entropy, options) {
        const derived = (0, utils_3.derivePrivateKey)(entropy, options);
        const privateKey = SECP256K1_PREFIX + (0, utils_2.bytesToHex)((0, utils_1.numberToBytesBE)(derived, 32));
        const publicKey = (0, utils_2.bytesToHex)(secp256k1_1.secp256k1.getPublicKey(derived, true));
        return { privateKey, publicKey };
    },
    sign(message, privateKey) {
        // Some callers pass the privateKey with the prefix, others without.
        // @noble/curves will throw if the key is not exactly 32 bytes, so we
        // normalize it before passing to the sign method.
        assert_1.default.ok((privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX)) ||
            privateKey.length === 64);
        const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;
        return secp256k1_1.secp256k1
            .sign(Sha512_1.default.half(message), normedPrivateKey, {
            // "Canonical" signatures
            lowS: true,
            // Would fail tests if signatures aren't deterministic
            extraEntropy: undefined,
        })
            .toDERHex(true)
            .toUpperCase();
    },
    verify(message, signature, publicKey) {
        const decoded = secp256k1_1.secp256k1.Signature.fromDER(signature);
        return secp256k1_1.secp256k1.verify(decoded, Sha512_1.default.half(message), publicKey);
    },
};
exports["default"] = secp256k1;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1951:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;
const secp256k1_1 = __nccwpck_require__(6379);
const Sha512_1 = __importDefault(__nccwpck_require__(5086));
const ZERO = BigInt(0);
function deriveScalar(bytes, discrim) {
    const order = secp256k1_1.secp256k1.CURVE.n;
    for (let i = 0; i <= 4294967295; i++) {
        // We hash the bytes to find a 256-bit number, looping until we are sure it
        // is less than the order of the curve.
        const hasher = new Sha512_1.default().add(bytes);
        // If the optional discriminator index was passed in, update the hash.
        if (discrim !== undefined) {
            hasher.addU32(discrim);
        }
        hasher.addU32(i);
        const key = hasher.first256BigInt();
        /* istanbul ignore else */
        if (key > ZERO && key < order) {
            return key;
        }
    }
    // This error is practically impossible to reach.
    // The order of the curve describes the (finite) amount of points on the curve
    // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182
    // How often will an (essentially) random number generated by Sha512 be larger than that?
    // There's 2^32 chances (the for loop) to get a number smaller than the order,
    // and it's rare that you'll even get past the first loop iteration.
    // Note that in TypeScript we actually need the throw, otherwise the function signature would be bigint | undefined
    //
    /* istanbul ignore next */
    throw new Error('impossible unicorn ;)');
}
/**
 * @param seed - Bytes.
 * @param [opts] - Object.
 * @param [opts.accountIndex=0] - The account number to generate.
 * @param [opts.validator=false] - Generate root key-pair,
 *                                              as used by validators.
 * @returns {bigint} 256 bit scalar value.
 *
 */
function derivePrivateKey(seed, opts = {}) {
    const root = opts.validator;
    const order = secp256k1_1.secp256k1.CURVE.n;
    // This private generator represents the `root` private key, and is what's
    // used by validators for signing when a keypair is generated from a seed.
    const privateGen = deriveScalar(seed);
    if (root) {
        // As returned by validation_create for a given seed
        return privateGen;
    }
    const publicGen = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);
    // A seed can generate many keypairs as a function of the seed and a uint32.
    // Almost everyone just uses the first account, `0`.
    const accountIndex = opts.accountIndex || 0;
    return (deriveScalar(publicGen, accountIndex) + privateGen) % order;
}
exports.derivePrivateKey = derivePrivateKey;
function accountPublicFromPublicGenerator(publicGenBytes) {
    const rootPubPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicGenBytes);
    const scalar = deriveScalar(publicGenBytes, 0);
    const point = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(scalar);
    const offset = rootPubPoint.add(point);
    return offset.toRawBytes(true);
}
exports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 5086:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const sha512_1 = __nccwpck_require__(65);
const utils_1 = __nccwpck_require__(2210);
class Sha512 {
    constructor() {
        // instantiate empty sha512 hash
        this.hash = sha512_1.sha512.create();
    }
    static half(input) {
        return new Sha512().add(input).first256();
    }
    add(bytes) {
        this.hash.update(bytes);
        return this;
    }
    addU32(i) {
        const buffer = new Uint8Array(4);
        new DataView(buffer.buffer).setUint32(0, i);
        return this.add(buffer);
    }
    finish() {
        return this.hash.digest();
    }
    first256() {
        return this.finish().slice(0, 32);
    }
    first256BigInt() {
        return (0, utils_1.bytesToNumberBE)(this.first256());
    }
}
exports["default"] = Sha512;
//# sourceMappingURL=Sha512.js.map

/***/ }),

/***/ 8649:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const assertHelper = {
    ok(cond, message) {
        if (!cond) {
            throw new Error(message);
        }
    },
};
exports["default"] = assertHelper;
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ 352:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;
var Prefix;
(function (Prefix) {
    Prefix[Prefix["NONE"] = -1] = "NONE";
    Prefix[Prefix["ED25519"] = 237] = "ED25519";
    Prefix[Prefix["SECP256K1_PUB_X"] = 2] = "SECP256K1_PUB_X";
    Prefix[Prefix["SECP256K1_PUB_X_ODD_Y"] = 3] = "SECP256K1_PUB_X_ODD_Y";
    Prefix[Prefix["SECP256K1_PUB_XY"] = 4] = "SECP256K1_PUB_XY";
    Prefix[Prefix["SECP256K1_PRIVATE"] = 0] = "SECP256K1_PRIVATE";
})(Prefix || (Prefix = {}));
/**
 * | Curve     | Type        | Prefix | Length | Description                                           | Algorithm       |
 * |-----------|-------------|:------:|:------:|-------------------------------------------------------|----------------:|
 * | ed25519   | Private     |  0xED  |   33   | prefix + Uint256LE (0 < n < order )                   |         ed25519 |
 * | ed25519   | Public      |  0xED  |   33   | prefix + 32 y-bytes                                   |         ed25519 |
 * | secp256k1 | Public (1)  |  0x02  |   33   | prefix + 32 x-bytes                                   | ecdsa-secp256k1 |
 * | secp256k1 | Public (2)  |  0x03  |   33   | prefix + 32 x-bytes (y is odd)                        | ecdsa-secp256k1 |
 * | secp256k1 | Public (3)  |  0x04  |   65   | prefix + 32 x-bytes + 32 y-bytes                      | ecdsa-secp256k1 |
 * | secp256k1 | Private (1) |  None  |   32   | Uint256BE (0 < n < order)                             | ecdsa-secp256k1 |
 * | secp256k1 | Private (2) |  0x00  |   33   | prefix + Uint256BE (0 < n < order)                    | ecdsa-secp256k1 |
 *
 * Note: The 0x00 prefix for secpk256k1 Private (2) essentially 0 pads the number
 *       and the interpreted number is the same as 32 bytes.
 */
const KEY_TYPES = {
    [`private_${Prefix.NONE}_32`]: 'ecdsa-secp256k1',
    [`private_${Prefix.SECP256K1_PRIVATE}_33`]: 'ecdsa-secp256k1',
    [`private_${Prefix.ED25519}_33`]: 'ed25519',
    [`public_${Prefix.ED25519}_33`]: 'ed25519',
    [`public_${Prefix.SECP256K1_PUB_X}_33`]: 'ecdsa-secp256k1',
    [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: 'ecdsa-secp256k1',
    [`public_${Prefix.SECP256K1_PUB_XY}_65`]: 'ecdsa-secp256k1',
};
function getKeyInfo(key) {
    return {
        prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),
        len: key.length / 2,
    };
}
function prefixRepr(prefix) {
    return prefix === Prefix.NONE
        ? 'None'
        : `0x${prefix.toString(16).padStart(2, '0')}`;
}
function getValidFormatsTable(type) {
    // No need overkill with renderTable method
    const padding = 2;
    const colWidth = {
        algorithm: 'ecdsa-secp256k1'.length + padding,
        prefix: '0x00'.length + padding,
    };
    return Object.entries(KEY_TYPES)
        .filter(([key]) => key.startsWith(type))
        .map(([key, algorithm]) => {
        const [, prefix, length] = key.split('_');
        const paddedAlgo = algorithm.padEnd(colWidth.algorithm);
        const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix);
        return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;
    })
        .join('\n');
}
function keyError({ key, type, prefix, len, }) {
    const validFormats = getValidFormatsTable(type);
    return `invalid_key:

Type: ${type}
Key: ${key}
Prefix: ${prefixRepr(prefix)} 
Length: ${len} bytes

Acceptable ${type} formats are:
${validFormats}
`;
}
/**
 * Determines the algorithm associated with a given key (public/private).
 *
 * @param key - hexadecimal string representation of the key.
 * @param type - whether expected key is public or private
 * @returns Algorithm algorithm for signing/verifying
 * @throws Error when key is invalid
 */
function getAlgorithmFromKey(key, type) {
    const { prefix, len } = getKeyInfo(key);
    // Special case back compat support for no prefix
    const usedPrefix = type === 'private' && len === 32 ? Prefix.NONE : prefix;
    const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`];
    if (!algorithm) {
        throw new Error(keyError({ key, type, len, prefix: usedPrefix }));
    }
    return algorithm;
}
exports.getAlgorithmFromKey = getAlgorithmFromKey;
function getAlgorithmFromPublicKey(key) {
    return getAlgorithmFromKey(key, 'public');
}
exports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;
function getAlgorithmFromPrivateKey(key) {
    return getAlgorithmFromKey(key, 'private');
}
exports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;
//# sourceMappingURL=getAlgorithmFromKey.js.map

/***/ }),

/***/ 5657:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var ECDSA;
(function (ECDSA) {
    ECDSA["ed25519"] = "ed25519";
    ECDSA["secp256k1"] = "ecdsa-secp256k1";
})(ECDSA || (ECDSA = {}));
exports["default"] = ECDSA;
//# sourceMappingURL=ECDSA.js.map

/***/ }),

/***/ 7428:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultFaucetPath = exports.getFaucetHost = exports.FaucetNetworkPaths = exports.FaucetNetwork = void 0;
const errors_1 = __nccwpck_require__(842);
var FaucetNetwork;
(function (FaucetNetwork) {
    FaucetNetwork["Testnet"] = "xahau-test.net";
    FaucetNetwork["Devnet"] = "jshooks.xahau-test.net";
})(FaucetNetwork || (exports.FaucetNetwork = FaucetNetwork = {}));
exports.FaucetNetworkPaths = {
    [FaucetNetwork.Testnet]: '/accounts',
    [FaucetNetwork.Devnet]: '/accounts',
};
function getFaucetHost(client) {
    const connectionUrl = client.url;
    if (connectionUrl.includes('jshooks')) {
        return FaucetNetwork.Devnet;
    }
    if (connectionUrl.includes('test')) {
        return FaucetNetwork.Testnet;
    }
    throw new errors_1.XRPLFaucetError('Faucet URL is not defined or inferrable.');
}
exports.getFaucetHost = getFaucetHost;
function getDefaultFaucetPath(hostname) {
    if (hostname === undefined) {
        return '/accounts';
    }
    return exports.FaucetNetworkPaths[hostname] || '/accounts';
}
exports.getDefaultFaucetPath = getDefaultFaucetPath;
//# sourceMappingURL=defaultFaucets.js.map

/***/ }),

/***/ 1730:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requestFunding = exports.getStartingBalance = exports.generateWalletToFund = void 0;
const xahau_address_codec_1 = __nccwpck_require__(647);
const errors_1 = __nccwpck_require__(842);
const defaultFaucets_1 = __nccwpck_require__(7428);
const _1 = __nccwpck_require__(2586);
const INTERVAL_SECONDS = 1;
const MAX_ATTEMPTS = 20;
function generateWalletToFund(wallet) {
    if (wallet && (0, xahau_address_codec_1.isValidClassicAddress)(wallet.classicAddress)) {
        return wallet;
    }
    return _1.Wallet.generate();
}
exports.generateWalletToFund = generateWalletToFund;
function getStartingBalance(client, classicAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        let startingBalance = 0;
        try {
            startingBalance = Number(yield client.getXrpBalance(classicAddress));
        }
        catch (_a) {
        }
        return startingBalance;
    });
}
exports.getStartingBalance = getStartingBalance;
function requestFunding(options, client, startingBalance, walletToFund, postBody) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const hostname = (_a = options.faucetHost) !== null && _a !== void 0 ? _a : (0, defaultFaucets_1.getFaucetHost)(client);
        if (!hostname) {
            throw new errors_1.XRPLFaucetError('No faucet hostname could be derived');
        }
        const pathname = (_b = options.faucetPath) !== null && _b !== void 0 ? _b : (0, defaultFaucets_1.getDefaultFaucetPath)(hostname);
        const response = yield fetch(`https://${hostname}${pathname}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(postBody),
        });
        const body = yield response.json();
        if (response.ok &&
            ((_c = response.headers.get('Content-Type')) === null || _c === void 0 ? void 0 : _c.startsWith('application/json'))) {
            const classicAddress = body.account.classicAddress;
            return processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance);
        }
        return processError(response, body);
    });
}
exports.requestFunding = requestFunding;
function processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!classicAddress) {
            return Promise.reject(new errors_1.XRPLFaucetError(`The faucet account is undefined`));
        }
        try {
            const updatedBalance = yield getUpdatedBalance(client, classicAddress, startingBalance);
            if (updatedBalance > startingBalance) {
                return {
                    wallet: walletToFund,
                    balance: updatedBalance,
                };
            }
            throw new errors_1.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`);
        }
        catch (err) {
            if (err instanceof Error) {
                throw new errors_1.XRPLFaucetError(err.message);
            }
            throw err;
        }
    });
}
function processError(response, body) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.reject(new errors_1.XRPLFaucetError(`Request failed: ${JSON.stringify({
            body: body || {},
            contentType: response.headers.get('Content-Type'),
            statusCode: response.status,
        })}`));
    });
}
function getUpdatedBalance(client, address, originalBalance) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let attempts = MAX_ATTEMPTS;
            const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                if (attempts < 0) {
                    clearInterval(interval);
                    resolve(originalBalance);
                }
                else {
                    attempts -= 1;
                }
                try {
                    let newBalance;
                    try {
                        newBalance = Number(yield client.getXrpBalance(address));
                    }
                    catch (_a) {
                    }
                    if (newBalance > originalBalance) {
                        clearInterval(interval);
                        resolve(newBalance);
                    }
                }
                catch (err) {
                    clearInterval(interval);
                    if (err instanceof Error) {
                        reject(new errors_1.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err.message}`));
                    }
                    reject(err);
                }
            }), INTERVAL_SECONDS * 1000);
        });
    });
}
//# sourceMappingURL=fundWallet.js.map

/***/ }),

/***/ 2586:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wallet = void 0;
const bip32_1 = __nccwpck_require__(2452);
const bip39_1 = __nccwpck_require__(5587);
const english_1 = __nccwpck_require__(2502);
const utils_1 = __nccwpck_require__(3617);
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const xahau_address_codec_1 = __nccwpck_require__(647);
const xahau_binary_codec_1 = __nccwpck_require__(67);
const xahau_keypairs_1 = __nccwpck_require__(4095);
const ECDSA_1 = __importDefault(__nccwpck_require__(5657));
const errors_1 = __nccwpck_require__(842);
const transactions_1 = __nccwpck_require__(1736);
const utils_2 = __nccwpck_require__(9659);
const collections_1 = __nccwpck_require__(991);
const hashLedger_1 = __nccwpck_require__(9716);
const rfc1751_1 = __nccwpck_require__(6051);
const signer_1 = __nccwpck_require__(8857);
const DEFAULT_ALGORITHM = ECDSA_1.default.ed25519;
const DEFAULT_DERIVATION_PATH = "m/44'/144'/0'/0/0";
function validateKey(node) {
    if (!(node.privateKey instanceof Uint8Array)) {
        throw new errors_1.ValidationError('Unable to derive privateKey from mnemonic input');
    }
    if (!(node.publicKey instanceof Uint8Array)) {
        throw new errors_1.ValidationError('Unable to derive publicKey from mnemonic input');
    }
}
class Wallet {
    constructor(publicKey, privateKey, opts = {}) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
        this.classicAddress = opts.masterAddress
            ? (0, utils_2.ensureClassicAddress)(opts.masterAddress)
            : (0, xahau_keypairs_1.deriveAddress)(publicKey);
        this.seed = opts.seed;
    }
    get address() {
        return this.classicAddress;
    }
    static generate(algorithm = DEFAULT_ALGORITHM) {
        if (!Object.values(ECDSA_1.default).includes(algorithm)) {
            throw new errors_1.ValidationError('Invalid cryptographic signing algorithm');
        }
        const seed = (0, xahau_keypairs_1.generateSeed)({ algorithm });
        return Wallet.fromSeed(seed, { algorithm });
    }
    static fromSeed(seed, opts = {}) {
        return Wallet.deriveWallet(seed, {
            algorithm: opts.algorithm,
            masterAddress: opts.masterAddress,
        });
    }
    static fromEntropy(entropy, opts = {}) {
        var _a;
        const algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM;
        const options = {
            entropy: Uint8Array.from(entropy),
            algorithm,
        };
        const seed = (0, xahau_keypairs_1.generateSeed)(options);
        return Wallet.deriveWallet(seed, {
            algorithm,
            masterAddress: opts.masterAddress,
        });
    }
    static fromMnemonic(mnemonic, opts = {}) {
        var _a;
        if (opts.mnemonicEncoding === 'rfc1751') {
            return Wallet.fromRFC1751Mnemonic(mnemonic, {
                masterAddress: opts.masterAddress,
                algorithm: opts.algorithm,
            });
        }
        if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {
            throw new errors_1.ValidationError('Unable to parse the given mnemonic using bip39 encoding');
        }
        const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
        const masterNode = bip32_1.HDKey.fromMasterSeed(seed);
        const node = masterNode.derive((_a = opts.derivationPath) !== null && _a !== void 0 ? _a : DEFAULT_DERIVATION_PATH);
        validateKey(node);
        const publicKey = (0, utils_1.bytesToHex)(node.publicKey);
        const privateKey = (0, utils_1.bytesToHex)(node.privateKey);
        return new Wallet(publicKey, `00${privateKey}`, {
            masterAddress: opts.masterAddress,
        });
    }
    static fromRFC1751Mnemonic(mnemonic, opts) {
        const seed = (0, rfc1751_1.rfc1751MnemonicToKey)(mnemonic);
        let encodeAlgorithm;
        if (opts.algorithm === ECDSA_1.default.ed25519) {
            encodeAlgorithm = 'ed25519';
        }
        else {
            encodeAlgorithm = 'secp256k1';
        }
        const encodedSeed = (0, xahau_address_codec_1.encodeSeed)(seed, encodeAlgorithm);
        return Wallet.fromSeed(encodedSeed, {
            masterAddress: opts.masterAddress,
            algorithm: opts.algorithm,
        });
    }
    static deriveWallet(seed, opts = {}) {
        var _a;
        const { publicKey, privateKey } = (0, xahau_keypairs_1.deriveKeypair)(seed, {
            algorithm: (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM,
        });
        return new Wallet(publicKey, privateKey, {
            seed,
            masterAddress: opts.masterAddress,
        });
    }
    sign(transaction, multisign) {
        let multisignAddress = false;
        if (typeof multisign === 'string' && multisign.startsWith('X')) {
            multisignAddress = multisign;
        }
        else if (multisign) {
            multisignAddress = this.classicAddress;
        }
        const tx = (0, collections_1.omitBy)(Object.assign({}, transaction), (value) => value == null);
        if (tx.TxnSignature || tx.Signers) {
            throw new errors_1.ValidationError('txJSON must not contain "TxnSignature" or "Signers" properties');
        }
        removeTrailingZeros(tx);
        (0, transactions_1.validate)(tx);
        const txToSignAndEncode = Object.assign({}, tx);
        txToSignAndEncode.SigningPubKey = multisignAddress ? '' : this.publicKey;
        if (multisignAddress) {
            const signer = {
                Account: multisignAddress,
                SigningPubKey: this.publicKey,
                TxnSignature: computeSignature(txToSignAndEncode, this.privateKey, multisignAddress),
            };
            txToSignAndEncode.Signers = [{ Signer: signer }];
        }
        else {
            txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, this.privateKey);
        }
        const serialized = (0, xahau_binary_codec_1.encode)(txToSignAndEncode);
        return {
            tx_blob: serialized,
            hash: (0, hashLedger_1.hashSignedTx)(serialized),
        };
    }
    verifyTransaction(signedTransaction) {
        return (0, signer_1.verifySignature)(signedTransaction, this.publicKey);
    }
    getXAddress(tag = false, isTestnet = false) {
        return (0, xahau_address_codec_1.classicAddressToXAddress)(this.classicAddress, tag, isTestnet);
    }
}
exports.Wallet = Wallet;
Wallet.fromSecret = Wallet.fromSeed;
function computeSignature(tx, privateKey, signAs) {
    if (signAs) {
        const classicAddress = (0, xahau_address_codec_1.isValidXAddress)(signAs)
            ? (0, xahau_address_codec_1.xAddressToClassicAddress)(signAs).classicAddress
            : signAs;
        return (0, xahau_keypairs_1.sign)((0, xahau_binary_codec_1.encodeForMultisigning)(tx, classicAddress), privateKey);
    }
    return (0, xahau_keypairs_1.sign)((0, xahau_binary_codec_1.encodeForSigning)(tx), privateKey);
}
function removeTrailingZeros(tx) {
    if (tx.TransactionType === 'Payment' &&
        typeof tx.Amount !== 'string' &&
        tx.Amount.value.includes('.') &&
        tx.Amount.value.endsWith('0')) {
        tx.Amount = Object.assign({}, tx.Amount);
        tx.Amount.value = new bignumber_js_1.default(tx.Amount.value).toString();
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6051:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keyToRFC1751Mnemonic = exports.rfc1751MnemonicToKey = void 0;
const utils_1 = __nccwpck_require__(3617);
const rfc1751Words_json_1 = __importDefault(__nccwpck_require__(2103));
const rfc1751WordList = rfc1751Words_json_1.default;
const BINARY = ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
    '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'];
function keyToBinary(key) {
    let res = '';
    for (const num of key) {
        res += BINARY[num >> 4] + BINARY[num & 0x0f];
    }
    return res;
}
function extract(key, start, length) {
    const subKey = key.substring(start, start + length);
    let acc = 0;
    for (let index = 0; index < subKey.length; index++) {
        acc = acc * 2 + subKey.charCodeAt(index) - 48;
    }
    return acc;
}
function keyToRFC1751Mnemonic(hex_key) {
    const buf = (0, utils_1.hexToBytes)(hex_key.replace(/\s+/gu, ''));
    let key = bufferToArray(swap128(buf));
    const padding = [];
    for (let index = 0; index < (8 - (key.length % 8)) % 8; index++) {
        padding.push(0);
    }
    key = padding.concat(key);
    const english = [];
    for (let index = 0; index < key.length; index += 8) {
        const subKey = key.slice(index, index + 8);
        let skbin = keyToBinary(subKey);
        let parity = 0;
        for (let j = 0; j < 64; j += 2) {
            parity += extract(skbin, j, 2);
        }
        subKey.push((parity << 6) & 0xff);
        skbin = keyToBinary(subKey);
        for (let j = 0; j < 64; j += 11) {
            english.push(rfc1751WordList[extract(skbin, j, 11)]);
        }
    }
    return english.join(' ');
}
exports.keyToRFC1751Mnemonic = keyToRFC1751Mnemonic;
function rfc1751MnemonicToKey(english) {
    const words = english.split(' ');
    let key = [];
    for (let index = 0; index < words.length; index += 6) {
        const { subKey, word } = getSubKey(words, index);
        const skbin = keyToBinary(subKey);
        let parity = 0;
        for (let j = 0; j < 64; j += 2) {
            parity += extract(skbin, j, 2);
        }
        const cs0 = extract(skbin, 64, 2);
        const cs1 = parity & 3;
        if (cs0 !== cs1) {
            throw new Error(`Parity error at ${word}`);
        }
        key = key.concat(subKey.slice(0, 8));
    }
    const bufferKey = swap128(Uint8Array.from(key));
    return bufferKey;
}
exports.rfc1751MnemonicToKey = rfc1751MnemonicToKey;
function getSubKey(words, index) {
    const sublist = words.slice(index, index + 6);
    let bits = 0;
    const ch = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    let word = '';
    for (word of sublist) {
        const idx = rfc1751WordList.indexOf(word.toUpperCase());
        if (idx === -1) {
            throw new TypeError(`Expected an RFC1751 word, but received '${word}'. ` +
                `For the full list of words in the RFC1751 encoding see https://datatracker.ietf.org/doc/html/rfc1751`);
        }
        const shift = (8 - ((bits + 11) % 8)) % 8;
        const y = idx << shift;
        const cl = y >> 16;
        const cc = (y >> 8) & 0xff;
        const cr = y & 0xff;
        const t = Math.floor(bits / 8);
        if (shift > 5) {
            ch[t] |= cl;
            ch[t + 1] |= cc;
            ch[t + 2] |= cr;
        }
        else if (shift > -3) {
            ch[t] |= cc;
            ch[t + 1] |= cr;
        }
        else {
            ch[t] |= cr;
        }
        bits += 11;
    }
    const subKey = ch.slice();
    return { subKey, word };
}
function bufferToArray(buf) {
    return Array.prototype.slice.call(buf);
}
function swap(arr, n, m) {
    const i = arr[n];
    arr[n] = arr[m];
    arr[m] = i;
}
function swap64(arr) {
    const len = arr.length;
    for (let i = 0; i < len; i += 8) {
        swap(arr, i, i + 7);
        swap(arr, i + 1, i + 6);
        swap(arr, i + 2, i + 5);
        swap(arr, i + 3, i + 4);
    }
    return arr;
}
function swap128(arr) {
    const reversedBytes = swap64(arr);
    return (0, utils_1.concat)([reversedBytes.slice(8, 16), reversedBytes.slice(0, 8)]);
}
//# sourceMappingURL=rfc1751.js.map

/***/ }),

/***/ 8857:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multisign = exports.verifySignature = void 0;
const utils_1 = __nccwpck_require__(3617);
const bignumber_js_1 = __nccwpck_require__(7558);
const xahau_address_codec_1 = __nccwpck_require__(647);
const xahau_binary_codec_1 = __nccwpck_require__(67);
const xahau_keypairs_1 = __nccwpck_require__(4095);
const errors_1 = __nccwpck_require__(842);
const transactions_1 = __nccwpck_require__(1736);
function multisign(transactions) {
    if (transactions.length === 0) {
        throw new errors_1.ValidationError('There were 0 transactions to multisign');
    }
    const decodedTransactions = transactions.map((txOrBlob) => {
        return getDecodedTransaction(txOrBlob);
    });
    decodedTransactions.forEach((tx) => {
        (0, transactions_1.validate)(tx);
        if (tx.Signers == null || tx.Signers.length === 0) {
            throw new errors_1.ValidationError("For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.");
        }
        if (tx.SigningPubKey !== '') {
            throw new errors_1.ValidationError('SigningPubKey must be an empty string for all transactions when multisigning.');
        }
    });
    validateTransactionEquivalence(decodedTransactions);
    return (0, xahau_binary_codec_1.encode)(getTransactionWithAllSigners(decodedTransactions));
}
exports.multisign = multisign;
function verifySignature(tx, publicKey) {
    const decodedTx = getDecodedTransaction(tx);
    let key = publicKey;
    if (typeof decodedTx.TxnSignature !== 'string' || !decodedTx.TxnSignature) {
        throw new Error('Transaction is missing a signature, TxnSignature');
    }
    if (!key) {
        if (typeof decodedTx.SigningPubKey !== 'string' ||
            !decodedTx.SigningPubKey) {
            throw new Error('Transaction is missing a public key, SigningPubKey');
        }
        key = decodedTx.SigningPubKey;
    }
    return (0, xahau_keypairs_1.verify)((0, xahau_binary_codec_1.encodeForSigning)(decodedTx), decodedTx.TxnSignature, key);
}
exports.verifySignature = verifySignature;
function validateTransactionEquivalence(transactions) {
    const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), { Signers: null }));
    if (transactions
        .slice(1)
        .some((tx) => JSON.stringify(Object.assign(Object.assign({}, tx), { Signers: null })) !== exampleTransaction)) {
        throw new errors_1.ValidationError('txJSON is not the same for all signedTransactions');
    }
}
function getTransactionWithAllSigners(transactions) {
    const sortedSigners = transactions
        .flatMap((tx) => { var _a; return (_a = tx.Signers) !== null && _a !== void 0 ? _a : []; })
        .sort(compareSigners);
    return Object.assign(Object.assign({}, transactions[0]), { Signers: sortedSigners });
}
function compareSigners(left, right) {
    return addressToBigNumber(left.Signer.Account).comparedTo(addressToBigNumber(right.Signer.Account));
}
const NUM_BITS_IN_HEX = 16;
function addressToBigNumber(address) {
    const hex = (0, utils_1.bytesToHex)((0, xahau_address_codec_1.decodeAccountID)(address));
    return new bignumber_js_1.BigNumber(hex, NUM_BITS_IN_HEX);
}
function getDecodedTransaction(txOrBlob) {
    if (typeof txOrBlob === 'object') {
        return (0, xahau_binary_codec_1.decode)((0, xahau_binary_codec_1.encode)(txOrBlob));
    }
    return (0, xahau_binary_codec_1.decode)(txOrBlob);
}
//# sourceMappingURL=signer.js.map

/***/ }),

/***/ 3536:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.walletFromSecretNumbers = void 0;
const secret_numbers_1 = __nccwpck_require__(2594);
const ECDSA_1 = __importDefault(__nccwpck_require__(5657));
const _1 = __nccwpck_require__(2586);
function walletFromSecretNumbers(secretNumbers, opts) {
    var _a;
    const secret = new secret_numbers_1.Account(secretNumbers).getFamilySeed();
    const updatedOpts = {
        masterAddress: undefined,
        algorithm: undefined,
    };
    if (opts === undefined) {
        updatedOpts.algorithm = ECDSA_1.default.secp256k1;
    }
    else {
        updatedOpts.masterAddress = opts.masterAddress;
        updatedOpts.algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : ECDSA_1.default.secp256k1;
    }
    return _1.Wallet.fromSecret(secret, updatedOpts);
}
exports.walletFromSecretNumbers = walletFromSecretNumbers;
//# sourceMappingURL=walletFromSecretNumbers.js.map

/***/ }),

/***/ 735:
/***/ (function(__unused_webpack_module, exports) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
class ConnectionManager {
    constructor() {
        this.promisesAwaitingConnection = [];
    }
    resolveAllAwaiting() {
        this.promisesAwaitingConnection.map(({ resolve }) => resolve());
        this.promisesAwaitingConnection = [];
    }
    rejectAllAwaiting(error) {
        this.promisesAwaitingConnection.map(({ reject }) => reject(error));
        this.promisesAwaitingConnection = [];
    }
    awaitConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.promisesAwaitingConnection.push({ resolve, reject });
            });
        });
    }
}
exports["default"] = ConnectionManager;
//# sourceMappingURL=ConnectionManager.js.map

/***/ }),

/***/ 9719:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const DEFAULT_MIN = 100;
const DEFAULT_MAX = 1000;
class ExponentialBackoff {
    constructor(opts = {}) {
        var _a, _b;
        this.factor = 2;
        this.numAttempts = 0;
        this.ms = (_a = opts.min) !== null && _a !== void 0 ? _a : DEFAULT_MIN;
        this.max = (_b = opts.max) !== null && _b !== void 0 ? _b : DEFAULT_MAX;
    }
    get attempts() {
        return this.numAttempts;
    }
    duration() {
        const ms = this.ms * Math.pow(this.factor, this.numAttempts);
        this.numAttempts += 1;
        return Math.floor(Math.min(ms, this.max));
    }
    reset() {
        this.numAttempts = 0;
    }
}
exports["default"] = ExponentialBackoff;
//# sourceMappingURL=ExponentialBackoff.js.map

/***/ }),

/***/ 3815:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const errors_1 = __nccwpck_require__(842);
class RequestManager {
    constructor() {
        this.nextId = 0;
        this.promisesAwaitingResponse = new Map();
    }
    addPromise(newId, timer) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.promisesAwaitingResponse.set(newId, {
                    resolve,
                    reject,
                    timer,
                });
            });
        });
    }
    resolve(id, response) {
        const promise = this.promisesAwaitingResponse.get(id);
        if (promise == null) {
            throw new errors_1.XahlError(`No existing promise with id ${id}`, {
                type: 'resolve',
                response,
            });
        }
        clearTimeout(promise.timer);
        promise.resolve(response);
        this.deletePromise(id);
    }
    reject(id, error) {
        const promise = this.promisesAwaitingResponse.get(id);
        if (promise == null) {
            throw new errors_1.XahlError(`No existing promise with id ${id}`, {
                type: 'reject',
                error,
            });
        }
        clearTimeout(promise.timer);
        promise.reject(error);
        this.deletePromise(id);
    }
    rejectAll(error) {
        this.promisesAwaitingResponse.forEach((_promise, id, _map) => {
            this.reject(id, error);
            this.deletePromise(id);
        });
    }
    createRequest(request, timeout) {
        let newId;
        if (request.id == null) {
            newId = this.nextId;
            this.nextId += 1;
        }
        else {
            newId = request.id;
        }
        const newRequest = JSON.stringify(Object.assign(Object.assign({}, request), { id: newId }));
        const timer = setTimeout(() => {
            this.reject(newId, new errors_1.TimeoutError(`Timeout for request: ${JSON.stringify(request)} with id ${newId}`, request));
        }, timeout);
        if (timer.unref) {
            ;
            timer.unref();
        }
        if (this.promisesAwaitingResponse.has(newId)) {
            clearTimeout(timer);
            throw new errors_1.XahlError(`Response with id '${newId}' is already pending`, request);
        }
        const newPromise = new Promise((resolve, reject) => {
            this.promisesAwaitingResponse.set(newId, {
                resolve,
                reject,
                timer,
            });
        });
        return [newId, newRequest, newPromise];
    }
    handleResponse(response) {
        var _a, _b;
        if (response.id == null ||
            !(typeof response.id === 'string' || typeof response.id === 'number')) {
            throw new errors_1.ResponseFormatError('valid id not found in response', response);
        }
        if (!this.promisesAwaitingResponse.has(response.id)) {
            return;
        }
        if (response.status == null) {
            const error = new errors_1.ResponseFormatError('Response has no status');
            this.reject(response.id, error);
        }
        if (response.status === 'error') {
            const errorResponse = response;
            const error = new errors_1.XahaudError((_a = errorResponse.error_message) !== null && _a !== void 0 ? _a : errorResponse.error, errorResponse);
            this.reject(response.id, error);
            return;
        }
        if (response.status !== 'success') {
            const error = new errors_1.ResponseFormatError(`unrecognized response.status: ${(_b = response.status) !== null && _b !== void 0 ? _b : ''}`, response);
            this.reject(response.id, error);
            return;
        }
        delete response.status;
        this.resolve(response.id, response);
    }
    deletePromise(id) {
        this.promisesAwaitingResponse.delete(id);
    }
}
exports["default"] = RequestManager;
//# sourceMappingURL=RequestManager.js.map

/***/ }),

/***/ 2808:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Connection = exports.INTENTIONAL_DISCONNECT_CODE = void 0;
const utils_1 = __nccwpck_require__(3617);
const ws_1 = __importDefault(__nccwpck_require__(5634));
const eventemitter3_1 = __nccwpck_require__(1848);
const errors_1 = __nccwpck_require__(842);
const ConnectionManager_1 = __importDefault(__nccwpck_require__(735));
const ExponentialBackoff_1 = __importDefault(__nccwpck_require__(9719));
const RequestManager_1 = __importDefault(__nccwpck_require__(3815));
const SECONDS_PER_MINUTE = 60;
const TIMEOUT = 20;
const CONNECTION_TIMEOUT = 5;
exports.INTENTIONAL_DISCONNECT_CODE = 4000;
function createWebSocket(url, config) {
    const options = {
        agent: config.agent,
    };
    if (config.headers) {
        options.headers = config.headers;
    }
    if (config.authorization != null) {
        options.headers = Object.assign(Object.assign({}, options.headers), { Authorization: `Basic ${btoa(config.authorization)}` });
    }
    const websocketOptions = Object.assign({}, options);
    return new ws_1.default(url, websocketOptions);
}
function websocketSendAsync(ws, message) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            ws.send(message, (error) => {
                if (error) {
                    reject(new errors_1.DisconnectedError(error.message, error));
                }
                else {
                    resolve();
                }
            });
        });
    });
}
class Connection extends eventemitter3_1.EventEmitter {
    constructor(url, options = {}) {
        super();
        this.ws = null;
        this.reconnectTimeoutID = null;
        this.heartbeatIntervalID = null;
        this.retryConnectionBackoff = new ExponentialBackoff_1.default({
            min: 100,
            max: SECONDS_PER_MINUTE * 1000,
        });
        this.requestManager = new RequestManager_1.default();
        this.connectionManager = new ConnectionManager_1.default();
        this.trace = () => { };
        this.url = url;
        this.config = Object.assign({ timeout: TIMEOUT * 1000, connectionTimeout: CONNECTION_TIMEOUT * 1000 }, options);
        if (typeof options.trace === 'function') {
            this.trace = options.trace;
        }
        else if (options.trace) {
            this.trace = console.log;
        }
    }
    get state() {
        return this.ws ? this.ws.readyState : ws_1.default.CLOSED;
    }
    get shouldBeConnected() {
        return this.ws !== null;
    }
    isConnected() {
        return this.state === ws_1.default.OPEN;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isConnected()) {
                return Promise.resolve();
            }
            if (this.state === ws_1.default.CONNECTING) {
                return this.connectionManager.awaitConnection();
            }
            if (!this.url) {
                return Promise.reject(new errors_1.ConnectionError('Cannot connect because no server was specified'));
            }
            if (this.ws != null) {
                return Promise.reject(new errors_1.XahlError('Websocket connection never cleaned up.', {
                    state: this.state,
                }));
            }
            const connectionTimeoutID = setTimeout(() => {
                this.onConnectionFailed(new errors_1.ConnectionError(`Error: connect() timed out after ${this.config.connectionTimeout} ms. If your internet connection is working, the ` +
                    `xahaud server may be blocked or inaccessible. You can also try setting the 'connectionTimeout' option in the Client constructor.`));
            }, this.config.connectionTimeout);
            this.ws = createWebSocket(this.url, this.config);
            if (this.ws == null) {
                throw new errors_1.XahlError('Connect: created null websocket');
            }
            this.ws.on('error', (error) => this.onConnectionFailed(error));
            this.ws.on('error', () => clearTimeout(connectionTimeoutID));
            this.ws.on('close', (reason) => this.onConnectionFailed(reason));
            this.ws.on('close', () => clearTimeout(connectionTimeoutID));
            this.ws.once('open', () => {
                void this.onceOpen(connectionTimeoutID);
            });
            return this.connectionManager.awaitConnection();
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.clearHeartbeatInterval();
            if (this.reconnectTimeoutID !== null) {
                clearTimeout(this.reconnectTimeoutID);
                this.reconnectTimeoutID = null;
            }
            if (this.state === ws_1.default.CLOSED) {
                return Promise.resolve(undefined);
            }
            if (this.ws == null) {
                return Promise.resolve(undefined);
            }
            return new Promise((resolve) => {
                if (this.ws == null) {
                    resolve(undefined);
                }
                if (this.ws != null) {
                    this.ws.once('close', (code) => resolve(code));
                }
                if (this.ws != null && this.state !== ws_1.default.CLOSING) {
                    this.ws.close(exports.INTENTIONAL_DISCONNECT_CODE);
                }
            });
        });
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('reconnect');
            yield this.disconnect();
            yield this.connect();
        });
    }
    request(request, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.shouldBeConnected || this.ws == null) {
                throw new errors_1.NotConnectedError(JSON.stringify(request), request);
            }
            const [id, message, responsePromise] = this.requestManager.createRequest(request, timeout !== null && timeout !== void 0 ? timeout : this.config.timeout);
            this.trace('send', message);
            websocketSendAsync(this.ws, message).catch((error) => {
                this.requestManager.reject(id, error);
            });
            return responsePromise;
        });
    }
    getUrl() {
        var _a;
        return (_a = this.url) !== null && _a !== void 0 ? _a : '';
    }
    onMessage(message) {
        this.trace('receive', message);
        let data;
        try {
            data = JSON.parse(message);
        }
        catch (error) {
            if (error instanceof Error) {
                this.emit('error', 'badMessage', error.message, message);
            }
            return;
        }
        if (data.type == null && data.error) {
            this.emit('error', data.error, data.error_message, data);
            return;
        }
        if (data.type) {
            this.emit(data.type, data);
        }
        if (data.type === 'response') {
            try {
                this.requestManager.handleResponse(data);
            }
            catch (error) {
                if (error instanceof Error) {
                    this.emit('error', 'badMessage', error.message, message);
                }
                else {
                    this.emit('error', 'badMessage', error, error);
                }
            }
        }
    }
    onceOpen(connectionTimeoutID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ws == null) {
                throw new errors_1.XahlError('onceOpen: ws is null');
            }
            this.ws.removeAllListeners();
            clearTimeout(connectionTimeoutID);
            this.ws.on('message', (message) => this.onMessage(message));
            this.ws.on('error', (error) => this.emit('error', 'websocket', error.message, error));
            this.ws.once('close', (code, reason) => {
                if (this.ws == null) {
                    throw new errors_1.XahlError('onceClose: ws is null');
                }
                this.clearHeartbeatInterval();
                this.requestManager.rejectAll(new errors_1.DisconnectedError(`websocket was closed, ${reason ? (0, utils_1.hexToString)((0, utils_1.bytesToHex)(reason)) : ''}`));
                this.ws.removeAllListeners();
                this.ws = null;
                if (code === undefined) {
                    const internalErrorCode = 1011;
                    this.emit('disconnected', internalErrorCode);
                }
                else {
                    this.emit('disconnected', code);
                }
                if (code !== exports.INTENTIONAL_DISCONNECT_CODE && code !== undefined) {
                    this.intentionalDisconnect();
                }
            });
            try {
                this.retryConnectionBackoff.reset();
                this.startHeartbeatInterval();
                this.connectionManager.resolveAllAwaiting();
                this.emit('connected');
            }
            catch (error) {
                if (error instanceof Error) {
                    this.connectionManager.rejectAllAwaiting(error);
                    yield this.disconnect().catch(() => { });
                }
            }
        });
    }
    intentionalDisconnect() {
        const retryTimeout = this.retryConnectionBackoff.duration();
        this.trace('reconnect', `Retrying connection in ${retryTimeout}ms.`);
        this.emit('reconnecting', this.retryConnectionBackoff.attempts);
        this.reconnectTimeoutID = setTimeout(() => {
            this.reconnect().catch((error) => {
                this.emit('error', 'reconnect', error.message, error);
            });
        }, retryTimeout);
    }
    clearHeartbeatInterval() {
        if (this.heartbeatIntervalID) {
            clearInterval(this.heartbeatIntervalID);
        }
    }
    startHeartbeatInterval() {
        this.clearHeartbeatInterval();
        this.heartbeatIntervalID = setInterval(() => {
            void this.heartbeat();
        }, this.config.timeout);
    }
    heartbeat() {
        return __awaiter(this, void 0, void 0, function* () {
            this.request({ command: 'ping' }).catch(() => __awaiter(this, void 0, void 0, function* () {
                return this.reconnect().catch((error) => {
                    this.emit('error', 'reconnect', error.message, error);
                });
            }));
        });
    }
    onConnectionFailed(errorOrCode) {
        if (this.ws) {
            this.ws.removeAllListeners();
            this.ws.on('error', () => {
            });
            this.ws.close();
            this.ws = null;
        }
        if (typeof errorOrCode === 'number') {
            this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(`Connection failed with code ${errorOrCode}.`, {
                code: errorOrCode,
            }));
        }
        else if (errorOrCode === null || errorOrCode === void 0 ? void 0 : errorOrCode.message) {
            this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(errorOrCode.message, errorOrCode));
        }
        else {
            this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError('Connection failed.'));
        }
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 6812:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = void 0;
const eventemitter3_1 = __nccwpck_require__(1848);
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(4215);
const flags_1 = __nccwpck_require__(7945);
const sugar_1 = __nccwpck_require__(2028);
const autofill_1 = __nccwpck_require__(7522);
const balances_1 = __nccwpck_require__(6680);
const getOrderbook_1 = __nccwpck_require__(5685);
const utils_1 = __nccwpck_require__(8329);
const Wallet_1 = __nccwpck_require__(2586);
const fundWallet_1 = __nccwpck_require__(1730);
const connection_1 = __nccwpck_require__(2808);
const partialPayment_1 = __nccwpck_require__(8813);
function getCollectKeyFromCommand(command) {
    switch (command) {
        case 'account_channels':
            return 'channels';
        case 'account_lines':
            return 'lines';
        case 'account_objects':
            return 'account_objects';
        case 'account_tx':
            return 'transactions';
        case 'account_offers':
        case 'book_offers':
            return 'offers';
        case 'ledger_data':
            return 'state';
        default:
            return null;
    }
}
function clamp(value, min, max) {
    if (min > max) {
        throw new Error('Illegal clamp bounds');
    }
    return Math.min(Math.max(value, min), max);
}
const DEFAULT_FEE_CUSHION = 1.2;
const DEFAULT_MAX_FEE_XAH = '2';
const MIN_LIMIT = 10;
const MAX_LIMIT = 400;
const NORMAL_DISCONNECT_CODE = 1000;
class Client extends eventemitter3_1.EventEmitter {
    constructor(server, options = {}) {
        var _a, _b;
        super();
        this.apiVersion = common_1.DEFAULT_API_VERSION;
        if (typeof server !== 'string' || !/wss?(?:\+unix)?:\/\//u.exec(server)) {
            throw new errors_1.ValidationError('server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.');
        }
        this.feeCushion = (_a = options.feeCushion) !== null && _a !== void 0 ? _a : DEFAULT_FEE_CUSHION;
        this.maxFeeXAH = (_b = options.maxFeeXAH) !== null && _b !== void 0 ? _b : DEFAULT_MAX_FEE_XAH;
        this.connection = new connection_1.Connection(server, options);
        this.connection.on('error', (errorCode, errorMessage, data) => {
            this.emit('error', errorCode, errorMessage, data);
        });
        this.connection.on('reconnect', () => {
            this.connection.on('connected', () => this.emit('connected'));
        });
        this.connection.on('disconnected', (code) => {
            let finalCode = code;
            if (finalCode === connection_1.INTENTIONAL_DISCONNECT_CODE) {
                finalCode = NORMAL_DISCONNECT_CODE;
            }
            this.emit('disconnected', finalCode);
        });
        this.connection.on('ledgerClosed', (ledger) => {
            this.emit('ledgerClosed', ledger);
        });
        this.connection.on('transaction', (tx) => {
            (0, partialPayment_1.handleStreamPartialPayment)(tx, this.connection.trace);
            this.emit('transaction', tx);
        });
        this.connection.on('validationReceived', (validation) => {
            this.emit('validationReceived', validation);
        });
        this.connection.on('manifestReceived', (manifest) => {
            this.emit('manifestReceived', manifest);
        });
        this.connection.on('peerStatusChange', (status) => {
            this.emit('peerStatusChange', status);
        });
        this.connection.on('consensusPhase', (consensus) => {
            this.emit('consensusPhase', consensus);
        });
        this.connection.on('path_find', (path) => {
            this.emit('path_find', path);
        });
    }
    get url() {
        return this.connection.getUrl();
    }
    request(req) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const request = Object.assign(Object.assign({}, req), { account: typeof req.account === 'string'
                    ? (0, sugar_1.ensureClassicAddress)(req.account)
                    : undefined, api_version: (_a = req.api_version) !== null && _a !== void 0 ? _a : this.apiVersion });
            const response = yield this.connection.request(request);
            (0, partialPayment_1.handlePartialPayment)(req.command, response);
            return response;
        });
    }
    requestNextPage(req, resp) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!resp.result.marker) {
                return Promise.reject(new errors_1.NotFoundError('response does not have a next page'));
            }
            const nextPageRequest = Object.assign(Object.assign({}, req), { marker: resp.result.marker });
            return this.request(nextPageRequest);
        });
    }
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    requestAll(request, collect) {
        return __awaiter(this, void 0, void 0, function* () {
            const collectKey = collect !== null && collect !== void 0 ? collect : getCollectKeyFromCommand(request.command);
            if (!collectKey) {
                throw new errors_1.ValidationError(`no collect key for command ${request.command}`);
            }
            const countTo = request.limit == null ? Infinity : request.limit;
            let count = 0;
            let marker = request.marker;
            const results = [];
            do {
                const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT);
                const repeatProps = Object.assign(Object.assign({}, request), { limit: countRemaining, marker });
                const singleResponse = yield this.connection.request(repeatProps);
                const singleResult = singleResponse.result;
                if (!(collectKey in singleResult)) {
                    throw new errors_1.XahlError(`${collectKey} not in result`);
                }
                const collectedData = singleResult[collectKey];
                marker = singleResult.marker;
                results.push(singleResponse);
                if (Array.isArray(collectedData)) {
                    count += collectedData.length;
                }
            } while (Boolean(marker) && count < countTo);
            return results;
        });
    }
    getServerInfo() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.request({
                    command: 'server_info',
                });
                this.networkID = (_a = response.result.info.network_id) !== null && _a !== void 0 ? _a : undefined;
                this.buildVersion = response.result.info.build_version;
            }
            catch (error) {
                console.error(error);
            }
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.connect().then(() => __awaiter(this, void 0, void 0, function* () {
                yield this.getServerInfo();
                this.emit('connected');
            }));
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connection.disconnect();
        });
    }
    isConnected() {
        return this.connection.isConnected();
    }
    autofill(transaction, signersCount) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = Object.assign({}, transaction);
            (0, autofill_1.setValidAddresses)(tx);
            (0, flags_1.setTransactionFlagsToNumber)(tx);
            const promises = [];
            if (tx.NetworkID == null) {
                tx.NetworkID = (0, autofill_1.txNeedsNetworkID)(this) ? this.networkID : undefined;
            }
            if (tx.Sequence == null) {
                promises.push((0, autofill_1.setNextValidSequenceNumber)(this, tx));
            }
            if (tx.LastLedgerSequence == null) {
                promises.push((0, autofill_1.setLatestValidatedLedgerSequence)(this, tx));
            }
            yield Promise.all(promises).then(() => tx);
            if (tx.Fee == null) {
                yield (0, autofill_1.calculateFeePerTransactionType)(this, tx, signersCount);
            }
            return tx;
        });
    }
    submit(transaction, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);
            return (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
        });
    }
    submitAndWait(transaction, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);
            const lastLedger = (0, sugar_1.getLastLedgerSequence)(signedTx);
            if (lastLedger == null) {
                throw new errors_1.ValidationError('Transaction must contain a LastLedgerSequence value for reliable submission.');
            }
            const response = yield (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
            const txHash = utils_1.hashes.hashSignedTx(signedTx);
            return (0, sugar_1.waitForFinalTransactionOutcome)(this, txHash, lastLedger, response.result.engine_result);
        });
    }
    prepareTransaction(transaction, signersCount) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.autofill(transaction, signersCount);
        });
    }
    getXrpBalance(address, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const xrpRequest = {
                command: 'account_info',
                account: address,
                ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',
                ledger_hash: options.ledger_hash,
            };
            const response = yield this.request(xrpRequest);
            return (0, utils_1.dropsToXah)(response.result.account_data.Balance);
        });
    }
    getBalances(address, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const balances = [];
            let xrpPromise = Promise.resolve(0);
            if (!options.peer) {
                xrpPromise = this.getXrpBalance(address, {
                    ledger_hash: options.ledger_hash,
                    ledger_index: options.ledger_index,
                });
            }
            const linesRequest = {
                command: 'account_lines',
                account: address,
                ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',
                ledger_hash: options.ledger_hash,
                peer: options.peer,
                limit: options.limit,
            };
            const linesPromise = this.requestAll(linesRequest);
            yield Promise.all([xrpPromise, linesPromise]).then(([xrpBalance, linesResponses]) => {
                const accountLinesBalance = linesResponses.flatMap((response) => (0, balances_1.formatBalances)(response.result.lines));
                if (xrpBalance !== 0) {
                    balances.push({ currency: 'XAH', value: xrpBalance.toString() });
                }
                balances.push(...accountLinesBalance);
            });
            return balances.slice(0, options.limit);
        });
    }
    getOrderbook(currency1, currency2, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, getOrderbook_1.validateOrderbookOptions)(options);
            const request = (0, getOrderbook_1.createBookOffersRequest)(currency1, currency2, options);
            const directOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, request);
            const reverseOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, (0, getOrderbook_1.reverseRequest)(request));
            const directOffers = (0, getOrderbook_1.extractOffers)(directOfferResults);
            const reverseOffers = (0, getOrderbook_1.extractOffers)(reverseOfferResults);
            const orders = (0, getOrderbook_1.combineOrders)(directOffers, reverseOffers);
            const { buy, sell } = (0, getOrderbook_1.separateBuySellOrders)(orders);
            return {
                buy: (0, getOrderbook_1.sortAndLimitOffers)(buy, options.limit),
                sell: (0, getOrderbook_1.sortAndLimitOffers)(sell, options.limit),
            };
        });
    }
    getLedgerIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            const ledgerResponse = yield this.request({
                command: 'ledger',
                ledger_index: 'validated',
            });
            return ledgerResponse.result.ledger_index;
        });
    }
    fundWallet(wallet, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected()) {
                throw new errors_1.XahaudError('Client not connected, cannot call faucet');
            }
            const existingWallet = Boolean(wallet);
            const walletToFund = wallet && (0, utils_1.isValidClassicAddress)(wallet.classicAddress)
                ? wallet
                : Wallet_1.Wallet.generate();
            const postBody = {
                destination: walletToFund.classicAddress,
                xrpAmount: options.amount,
                usageContext: options.usageContext,
                userAgent: 'xahau.js',
            };
            let startingBalance = 0;
            if (existingWallet) {
                try {
                    startingBalance = Number(yield this.getXrpBalance(walletToFund.classicAddress));
                }
                catch (_a) {
                }
            }
            return (0, fundWallet_1.requestFunding)(options, this, startingBalance, walletToFund, postBody);
        });
    }
}
exports.Client = Client;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8813:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleStreamPartialPayment = exports.handlePartialPayment = void 0;
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const xahau_binary_codec_1 = __nccwpck_require__(67);
const transactions_1 = __nccwpck_require__(1736);
const utils_1 = __nccwpck_require__(8429);
const WARN_PARTIAL_PAYMENT_CODE = 2001;
function amountsEqual(amt1, amt2) {
    if (typeof amt1 === 'string' && typeof amt2 === 'string') {
        return amt1 === amt2;
    }
    if (typeof amt1 === 'string' || typeof amt2 === 'string') {
        return false;
    }
    const aValue = new bignumber_js_1.default(amt1.value);
    const bValue = new bignumber_js_1.default(amt2.value);
    return (amt1.currency === amt2.currency &&
        amt1.issuer === amt2.issuer &&
        aValue.isEqualTo(bValue));
}
function isPartialPayment(tx, metadata) {
    var _a;
    if (tx == null || metadata == null || tx.TransactionType !== 'Payment') {
        return false;
    }
    let meta = metadata;
    if (typeof meta === 'string') {
        if (meta === 'unavailable') {
            return false;
        }
        meta = (0, xahau_binary_codec_1.decode)(meta);
    }
    const tfPartial = typeof tx.Flags === 'number'
        ? (0, utils_1.isFlagEnabled)(tx.Flags, transactions_1.PaymentFlags.tfPartialPayment)
        : (_a = tx.Flags) === null || _a === void 0 ? void 0 : _a.tfPartialPayment;
    if (!tfPartial) {
        return false;
    }
    const delivered = meta.delivered_amount;
    const amount = tx.DeliverMax;
    if (delivered === undefined) {
        return false;
    }
    return !amountsEqual(delivered, amount);
}
function txHasPartialPayment(response) {
    return isPartialPayment(response.result.tx_json, response.result.meta);
}
function txEntryHasPartialPayment(response) {
    return isPartialPayment(response.result.tx_json, response.result.metadata);
}
function accountTxHasPartialPayment(response) {
    const { transactions } = response.result;
    const foo = transactions.some((tx) => {
        if (tx.tx_json != null) {
            const transaction = tx;
            return isPartialPayment(transaction.tx_json, transaction.meta);
        }
        const transaction = tx;
        return isPartialPayment(transaction.tx, transaction.meta);
    });
    return foo;
}
function hasPartialPayment(command, response) {
    switch (command) {
        case 'tx':
            return txHasPartialPayment(response);
        case 'transaction_entry':
            return txEntryHasPartialPayment(response);
        case 'account_tx':
            return accountTxHasPartialPayment(response);
        default:
            return false;
    }
}
function handlePartialPayment(command, response) {
    var _a;
    if (hasPartialPayment(command, response)) {
        const warnings = (_a = response.warnings) !== null && _a !== void 0 ? _a : [];
        const warning = {
            id: WARN_PARTIAL_PAYMENT_CODE,
            message: 'This response contains a Partial Payment',
        };
        warnings.push(warning);
        response.warnings = warnings;
    }
}
exports.handlePartialPayment = handlePartialPayment;
function handleStreamPartialPayment(stream, log) {
    var _a, _b;
    if (isPartialPayment((_a = stream.tx_json) !== null && _a !== void 0 ? _a : stream.transaction, stream.meta)) {
        const warnings = (_b = stream.warnings) !== null && _b !== void 0 ? _b : [];
        const warning = {
            id: WARN_PARTIAL_PAYMENT_CODE,
            message: 'This response contains a Partial Payment',
        };
        warnings.push(warning);
        stream.warnings = warnings;
        log('Partial payment received', JSON.stringify(stream));
    }
}
exports.handleStreamPartialPayment = handleStreamPartialPayment;
//# sourceMappingURL=partialPayment.js.map

/***/ }),

/***/ 842:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XRPLFaucetError = exports.NotFoundError = exports.ValidationError = exports.ResponseFormatError = exports.TimeoutError = exports.XahaudNotInitializedError = exports.DisconnectedError = exports.NotConnectedError = exports.XahaudError = exports.ConnectionError = exports.UnexpectedError = exports.XahlError = void 0;
class XahlError extends Error {
    constructor(message = '', data) {
        super(message);
        this.name = this.constructor.name;
        this.message = message;
        this.data = data;
        if (Error.captureStackTrace != null) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    toString() {
        let result = `[${this.name}(${this.message}`;
        if (this.data) {
            result += `, ${JSON.stringify(this.data)}`;
        }
        result += ')]';
        return result;
    }
    inspect() {
        return this.toString();
    }
}
exports.XahlError = XahlError;
class XahaudError extends XahlError {
}
exports.XahaudError = XahaudError;
class UnexpectedError extends XahlError {
}
exports.UnexpectedError = UnexpectedError;
class ConnectionError extends XahlError {
}
exports.ConnectionError = ConnectionError;
class NotConnectedError extends ConnectionError {
}
exports.NotConnectedError = NotConnectedError;
class DisconnectedError extends ConnectionError {
}
exports.DisconnectedError = DisconnectedError;
class XahaudNotInitializedError extends ConnectionError {
}
exports.XahaudNotInitializedError = XahaudNotInitializedError;
class TimeoutError extends ConnectionError {
}
exports.TimeoutError = TimeoutError;
class ResponseFormatError extends ConnectionError {
}
exports.ResponseFormatError = ResponseFormatError;
class ValidationError extends XahlError {
}
exports.ValidationError = ValidationError;
class XRPLFaucetError extends XahlError {
}
exports.XRPLFaucetError = XRPLFaucetError;
class NotFoundError extends XahlError {
    constructor(message = 'Not found') {
        super(message);
    }
}
exports.NotFoundError = NotFoundError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 2365:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rfc1751MnemonicToKey = exports.keyToRFC1751Mnemonic = exports.walletFromSecretNumbers = exports.Wallet = exports.ECDSA = exports.Client = void 0;
var client_1 = __nccwpck_require__(6812);
Object.defineProperty(exports, "Client", ({ enumerable: true, get: function () { return client_1.Client; } }));
__exportStar(__nccwpck_require__(8902), exports);
__exportStar(__nccwpck_require__(8329), exports);
var ECDSA_1 = __nccwpck_require__(5657);
Object.defineProperty(exports, "ECDSA", ({ enumerable: true, get: function () { return __importDefault(ECDSA_1).default; } }));
__exportStar(__nccwpck_require__(842), exports);
var Wallet_1 = __nccwpck_require__(2586);
Object.defineProperty(exports, "Wallet", ({ enumerable: true, get: function () { return Wallet_1.Wallet; } }));
var walletFromSecretNumbers_1 = __nccwpck_require__(3536);
Object.defineProperty(exports, "walletFromSecretNumbers", ({ enumerable: true, get: function () { return walletFromSecretNumbers_1.walletFromSecretNumbers; } }));
var rfc1751_1 = __nccwpck_require__(6051);
Object.defineProperty(exports, "keyToRFC1751Mnemonic", ({ enumerable: true, get: function () { return rfc1751_1.keyToRFC1751Mnemonic; } }));
Object.defineProperty(exports, "rfc1751MnemonicToKey", ({ enumerable: true, get: function () { return rfc1751_1.rfc1751MnemonicToKey; } }));
__exportStar(__nccwpck_require__(8857), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4215:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_API_VERSION = exports.XAHAUD_API_V2 = exports.XAHAUD_API_V1 = void 0;
exports.XAHAUD_API_V1 = 1;
exports.XAHAUD_API_V2 = 2;
exports.DEFAULT_API_VERSION = exports.XAHAUD_API_V1;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8902:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseTransactionFlags = exports.parseAccountRootFlags = exports.setTransactionFlagsToNumber = exports.LedgerEntry = void 0;
exports.LedgerEntry = __importStar(__nccwpck_require__(5904));
var flags_1 = __nccwpck_require__(7945);
Object.defineProperty(exports, "setTransactionFlagsToNumber", ({ enumerable: true, get: function () { return flags_1.setTransactionFlagsToNumber; } }));
Object.defineProperty(exports, "parseAccountRootFlags", ({ enumerable: true, get: function () { return flags_1.parseAccountRootFlags; } }));
Object.defineProperty(exports, "parseTransactionFlags", ({ enumerable: true, get: function () { return flags_1.parseTransactionFlags; } }));
__exportStar(__nccwpck_require__(2657), exports);
__exportStar(__nccwpck_require__(1736), exports);
__exportStar(__nccwpck_require__(4215), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9341:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountRootFlags = void 0;
var AccountRootFlags;
(function (AccountRootFlags) {
    AccountRootFlags[AccountRootFlags["lsfPasswordSpent"] = 65536] = "lsfPasswordSpent";
    AccountRootFlags[AccountRootFlags["lsfRequireDestTag"] = 131072] = "lsfRequireDestTag";
    AccountRootFlags[AccountRootFlags["lsfRequireAuth"] = 262144] = "lsfRequireAuth";
    AccountRootFlags[AccountRootFlags["lsfDisallowXAH"] = 524288] = "lsfDisallowXAH";
    AccountRootFlags[AccountRootFlags["lsfDisableMaster"] = 1048576] = "lsfDisableMaster";
    AccountRootFlags[AccountRootFlags["lsfNoFreeze"] = 2097152] = "lsfNoFreeze";
    AccountRootFlags[AccountRootFlags["lsfGlobalFreeze"] = 4194304] = "lsfGlobalFreeze";
    AccountRootFlags[AccountRootFlags["lsfDefaultRipple"] = 8388608] = "lsfDefaultRipple";
    AccountRootFlags[AccountRootFlags["lsfDepositAuth"] = 16777216] = "lsfDepositAuth";
    AccountRootFlags[AccountRootFlags["lsfDisallowIncomingNFTokenOffer"] = 67108864] = "lsfDisallowIncomingNFTokenOffer";
    AccountRootFlags[AccountRootFlags["lsfDisallowIncomingCheck"] = 134217728] = "lsfDisallowIncomingCheck";
    AccountRootFlags[AccountRootFlags["lsfDisallowIncomingPayChan"] = 268435456] = "lsfDisallowIncomingPayChan";
    AccountRootFlags[AccountRootFlags["lsfDisallowIncomingTrustline"] = 536870912] = "lsfDisallowIncomingTrustline";
    AccountRootFlags[AccountRootFlags["lsfURITokenIssuer"] = 1073741824] = "lsfURITokenIssuer";
    AccountRootFlags[AccountRootFlags["lsfDisallowIncomingRemit"] = 2147483648] = "lsfDisallowIncomingRemit";
    AccountRootFlags[AccountRootFlags["lsfAllowTrustLineClawback"] = 4096] = "lsfAllowTrustLineClawback";
})(AccountRootFlags || (exports.AccountRootFlags = AccountRootFlags = {}));
//# sourceMappingURL=AccountRoot.js.map

/***/ }),

/***/ 641:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AMENDMENTS_ID = void 0;
exports.AMENDMENTS_ID = '7DB0788C020F02780A673DC74757F23823FA3014C1866E72CC4CD8B226CD6EF4';
//# sourceMappingURL=Amendments.js.map

/***/ }),

/***/ 2887:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FEE_SETTINGS_ID = void 0;
exports.FEE_SETTINGS_ID = '4BC50C9B0D8515D3EAAE1E74B29A95804346C491EE1A95BF25E4AAB854A6A651';
//# sourceMappingURL=FeeSettings.js.map

/***/ }),

/***/ 7039:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NEGATIVE_UNL_ID = void 0;
exports.NEGATIVE_UNL_ID = '2E8A59AA9D3B5B186B0B9E0F62E6C02587CA74A4D778938E957B6357D364B244';
//# sourceMappingURL=NegativeUNL.js.map

/***/ }),

/***/ 3178:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OfferFlags = void 0;
var OfferFlags;
(function (OfferFlags) {
    OfferFlags[OfferFlags["lsfPassive"] = 65536] = "lsfPassive";
    OfferFlags[OfferFlags["lsfSell"] = 131072] = "lsfSell";
})(OfferFlags || (exports.OfferFlags = OfferFlags = {}));
//# sourceMappingURL=Offer.js.map

/***/ }),

/***/ 7573:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RippleStateFlags = void 0;
var RippleStateFlags;
(function (RippleStateFlags) {
    RippleStateFlags[RippleStateFlags["lsfLowReserve"] = 65536] = "lsfLowReserve";
    RippleStateFlags[RippleStateFlags["lsfHighReserve"] = 131072] = "lsfHighReserve";
    RippleStateFlags[RippleStateFlags["lsfLowAuth"] = 262144] = "lsfLowAuth";
    RippleStateFlags[RippleStateFlags["lsfHighAuth"] = 524288] = "lsfHighAuth";
    RippleStateFlags[RippleStateFlags["lsfLowNoRipple"] = 1048576] = "lsfLowNoRipple";
    RippleStateFlags[RippleStateFlags["lsfHighNoRipple"] = 2097152] = "lsfHighNoRipple";
    RippleStateFlags[RippleStateFlags["lsfLowFreeze"] = 4194304] = "lsfLowFreeze";
    RippleStateFlags[RippleStateFlags["lsfHighFreeze"] = 8388608] = "lsfHighFreeze";
    RippleStateFlags[RippleStateFlags["lsfAMMNode"] = 16777216] = "lsfAMMNode";
    RippleStateFlags[RippleStateFlags["lsfLowDeepFreeze"] = 33554432] = "lsfLowDeepFreeze";
    RippleStateFlags[RippleStateFlags["lsfHighDeepFreeze"] = 67108864] = "lsfHighDeepFreeze";
})(RippleStateFlags || (exports.RippleStateFlags = RippleStateFlags = {}));
//# sourceMappingURL=RippleState.js.map

/***/ }),

/***/ 1389:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignerListFlags = void 0;
var SignerListFlags;
(function (SignerListFlags) {
    SignerListFlags[SignerListFlags["lsfOneOwnerCount"] = 65536] = "lsfOneOwnerCount";
})(SignerListFlags || (exports.SignerListFlags = SignerListFlags = {}));
//# sourceMappingURL=SignerList.js.map

/***/ }),

/***/ 5904:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignerListFlags = exports.RippleStateFlags = exports.OfferFlags = exports.NEGATIVE_UNL_ID = exports.FEE_SETTINGS_ID = exports.AMENDMENTS_ID = exports.AccountRootFlags = void 0;
const AccountRoot_1 = __nccwpck_require__(9341);
Object.defineProperty(exports, "AccountRootFlags", ({ enumerable: true, get: function () { return AccountRoot_1.AccountRootFlags; } }));
const Amendments_1 = __nccwpck_require__(641);
Object.defineProperty(exports, "AMENDMENTS_ID", ({ enumerable: true, get: function () { return Amendments_1.AMENDMENTS_ID; } }));
const FeeSettings_1 = __nccwpck_require__(2887);
Object.defineProperty(exports, "FEE_SETTINGS_ID", ({ enumerable: true, get: function () { return FeeSettings_1.FEE_SETTINGS_ID; } }));
const NegativeUNL_1 = __nccwpck_require__(7039);
Object.defineProperty(exports, "NEGATIVE_UNL_ID", ({ enumerable: true, get: function () { return NegativeUNL_1.NEGATIVE_UNL_ID; } }));
const Offer_1 = __nccwpck_require__(3178);
Object.defineProperty(exports, "OfferFlags", ({ enumerable: true, get: function () { return Offer_1.OfferFlags; } }));
const RippleState_1 = __nccwpck_require__(7573);
Object.defineProperty(exports, "RippleStateFlags", ({ enumerable: true, get: function () { return RippleState_1.RippleStateFlags; } }));
const SignerList_1 = __nccwpck_require__(1389);
Object.defineProperty(exports, "SignerListFlags", ({ enumerable: true, get: function () { return SignerList_1.SignerListFlags; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2657:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5400:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateAccountSet = exports.AccountSetTfFlags = exports.AccountSetAsfFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
var AccountSetAsfFlags;
(function (AccountSetAsfFlags) {
    AccountSetAsfFlags[AccountSetAsfFlags["asfRequireDest"] = 1] = "asfRequireDest";
    AccountSetAsfFlags[AccountSetAsfFlags["asfRequireAuth"] = 2] = "asfRequireAuth";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDisallowXAH"] = 3] = "asfDisallowXAH";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDisableMaster"] = 4] = "asfDisableMaster";
    AccountSetAsfFlags[AccountSetAsfFlags["asfAccountTxnID"] = 5] = "asfAccountTxnID";
    AccountSetAsfFlags[AccountSetAsfFlags["asfNoFreeze"] = 6] = "asfNoFreeze";
    AccountSetAsfFlags[AccountSetAsfFlags["asfGlobalFreeze"] = 7] = "asfGlobalFreeze";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDefaultRipple"] = 8] = "asfDefaultRipple";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDepositAuth"] = 9] = "asfDepositAuth";
    AccountSetAsfFlags[AccountSetAsfFlags["asfAuthorizedNFTokenMinter"] = 10] = "asfAuthorizedNFTokenMinter";
    AccountSetAsfFlags[AccountSetAsfFlags["asfTshCollect"] = 11] = "asfTshCollect";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDisallowIncomingNFTokenOffer"] = 12] = "asfDisallowIncomingNFTokenOffer";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDisallowIncomingCheck"] = 13] = "asfDisallowIncomingCheck";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDisallowIncomingPayChan"] = 14] = "asfDisallowIncomingPayChan";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDisallowIncomingTrustline"] = 15] = "asfDisallowIncomingTrustline";
    AccountSetAsfFlags[AccountSetAsfFlags["asfDisallowIncomingRemit"] = 16] = "asfDisallowIncomingRemit";
    AccountSetAsfFlags[AccountSetAsfFlags["asfAllowTrustLineClawback"] = 17] = "asfAllowTrustLineClawback";
})(AccountSetAsfFlags || (exports.AccountSetAsfFlags = AccountSetAsfFlags = {}));
var AccountSetTfFlags;
(function (AccountSetTfFlags) {
    AccountSetTfFlags[AccountSetTfFlags["tfRequireDestTag"] = 65536] = "tfRequireDestTag";
    AccountSetTfFlags[AccountSetTfFlags["tfOptionalDestTag"] = 131072] = "tfOptionalDestTag";
    AccountSetTfFlags[AccountSetTfFlags["tfRequireAuth"] = 262144] = "tfRequireAuth";
    AccountSetTfFlags[AccountSetTfFlags["tfOptionalAuth"] = 524288] = "tfOptionalAuth";
    AccountSetTfFlags[AccountSetTfFlags["tfDisallowXAH"] = 1048576] = "tfDisallowXAH";
    AccountSetTfFlags[AccountSetTfFlags["tfAllowXAH"] = 2097152] = "tfAllowXAH";
})(AccountSetTfFlags || (exports.AccountSetTfFlags = AccountSetTfFlags = {}));
const MIN_TICK_SIZE = 3;
const MAX_TICK_SIZE = 15;
const MAX_HOOK_STATE_SCALE = 16;
function validateAccountSet(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    (0, common_1.validateOptionalField)(tx, 'NFTokenMinter', common_1.isAccount);
    if (tx.ClearFlag !== undefined) {
        if (typeof tx.ClearFlag !== 'number') {
            throw new errors_1.ValidationError('AccountSet: invalid ClearFlag');
        }
        if (!Object.values(AccountSetAsfFlags).includes(tx.ClearFlag)) {
            throw new errors_1.ValidationError('AccountSet: invalid ClearFlag');
        }
    }
    if (tx.Domain !== undefined && typeof tx.Domain !== 'string') {
        throw new errors_1.ValidationError('AccountSet: invalid Domain');
    }
    if (tx.EmailHash !== undefined && typeof tx.EmailHash !== 'string') {
        throw new errors_1.ValidationError('AccountSet: invalid EmailHash');
    }
    if (tx.MessageKey !== undefined && typeof tx.MessageKey !== 'string') {
        throw new errors_1.ValidationError('AccountSet: invalid MessageKey');
    }
    if (tx.SetFlag !== undefined) {
        if (typeof tx.SetFlag !== 'number') {
            throw new errors_1.ValidationError('AccountSet: invalid SetFlag');
        }
        if (!Object.values(AccountSetAsfFlags).includes(tx.SetFlag)) {
            throw new errors_1.ValidationError('AccountSet: invalid SetFlag');
        }
    }
    if (tx.TransferRate !== undefined && typeof tx.TransferRate !== 'number') {
        throw new errors_1.ValidationError('AccountSet: invalid TransferRate');
    }
    if (tx.TickSize !== undefined) {
        if (typeof tx.TickSize !== 'number') {
            throw new errors_1.ValidationError('AccountSet: invalid TickSize');
        }
        if (tx.TickSize !== 0 &&
            (tx.TickSize < MIN_TICK_SIZE || tx.TickSize > MAX_TICK_SIZE)) {
            throw new errors_1.ValidationError('AccountSet: invalid TickSize');
        }
    }
    (0, common_1.validateOptionalField)(tx, 'HookStateScale', common_1.isNumber);
    if (typeof tx.HookStateScale === 'number' &&
        tx.HookStateScale > MAX_HOOK_STATE_SCALE) {
        throw new errors_1.ValidationError(`AccountSet: HookStateScale must be less than ${MAX_HOOK_STATE_SCALE}`);
    }
}
exports.validateAccountSet = validateAccountSet;
//# sourceMappingURL=accountSet.js.map

/***/ }),

/***/ 58:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateCheckCancel = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateCheckCancel(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.CheckID !== undefined && typeof tx.CheckID !== 'string') {
        throw new errors_1.ValidationError('CheckCancel: invalid CheckID');
    }
}
exports.validateCheckCancel = validateCheckCancel;
//# sourceMappingURL=checkCancel.js.map

/***/ }),

/***/ 372:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateCheckCash = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateCheckCash(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Amount == null && tx.DeliverMin == null) {
        throw new errors_1.ValidationError('CheckCash: must have either Amount or DeliverMin');
    }
    if (tx.Amount != null && tx.DeliverMin != null) {
        throw new errors_1.ValidationError('CheckCash: cannot have both Amount and DeliverMin');
    }
    if (tx.Amount != null && tx.Amount !== undefined && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError('CheckCash: invalid Amount');
    }
    if (tx.DeliverMin != null &&
        tx.DeliverMin !== undefined &&
        !(0, common_1.isAmount)(tx.DeliverMin)) {
        throw new errors_1.ValidationError('CheckCash: invalid DeliverMin');
    }
    if (tx.CheckID !== undefined && typeof tx.CheckID !== 'string') {
        throw new errors_1.ValidationError('CheckCash: invalid CheckID');
    }
}
exports.validateCheckCash = validateCheckCash;
//# sourceMappingURL=checkCash.js.map

/***/ }),

/***/ 9105:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateCheckCreate = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateCheckCreate(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.SendMax === undefined) {
        throw new errors_1.ValidationError('CheckCreate: missing field SendMax');
    }
    (0, common_1.validateRequiredField)(tx, 'Destination', common_1.isAccount);
    (0, common_1.validateOptionalField)(tx, 'DestinationTag', common_1.isNumber);
    if (typeof tx.SendMax !== 'string' &&
        !(0, common_1.isIssuedCurrency)(tx.SendMax)) {
        throw new errors_1.ValidationError('CheckCreate: invalid SendMax');
    }
    if (tx.Expiration !== undefined && typeof tx.Expiration !== 'number') {
        throw new errors_1.ValidationError('CheckCreate: invalid Expiration');
    }
    if (tx.InvoiceID !== undefined && typeof tx.InvoiceID !== 'string') {
        throw new errors_1.ValidationError('CheckCreate: invalid InvoiceID');
    }
}
exports.validateCheckCreate = validateCheckCreate;
//# sourceMappingURL=checkCreate.js.map

/***/ }),

/***/ 1973:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateClaimReward = exports.ClaimRewardFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
var ClaimRewardFlags;
(function (ClaimRewardFlags) {
    ClaimRewardFlags[ClaimRewardFlags["tfOptOut"] = 1] = "tfOptOut";
})(ClaimRewardFlags || (exports.ClaimRewardFlags = ClaimRewardFlags = {}));
function validateClaimReward(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Issuer !== undefined && typeof tx.Issuer !== 'string') {
        throw new errors_1.ValidationError('ClaimReward: Issuer must be a string');
    }
    if (tx.Account === tx.Issuer) {
        throw new errors_1.ValidationError('ClaimReward: Account and Issuer cannot be the same');
    }
}
exports.validateClaimReward = validateClaimReward;
//# sourceMappingURL=claimReward.js.map

/***/ }),

/***/ 6281:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateClawback = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateClawback(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Amount == null) {
        throw new errors_1.ValidationError('Clawback: missing field Amount');
    }
    if (!(0, common_1.isIssuedCurrency)(tx.Amount)) {
        throw new errors_1.ValidationError('Clawback: invalid Amount');
    }
    if ((0, common_1.isIssuedCurrency)(tx.Amount) && tx.Account === tx.Amount.issuer) {
        throw new errors_1.ValidationError('Clawback: invalid holder Account');
    }
}
exports.validateClawback = validateClawback;
//# sourceMappingURL=clawback.js.map

/***/ }),

/***/ 170:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAmountValue = exports.validateBaseTransaction = exports.validateOptionalField = exports.validateRequiredField = exports.isAmount = exports.isAccount = exports.isIssuedCurrency = exports.isCurrency = exports.isNumber = exports.isString = void 0;
const xahau_address_codec_1 = __nccwpck_require__(647);
const xahau_binary_codec_1 = __nccwpck_require__(67);
const errors_1 = __nccwpck_require__(842);
const utils_1 = __nccwpck_require__(8429);
const MEMO_SIZE = 3;
function isMemo(obj) {
    if (obj.Memo == null) {
        return false;
    }
    const memo = obj.Memo;
    const size = Object.keys(memo).length;
    const validData = memo.MemoData == null || typeof memo.MemoData === 'string';
    const validFormat = memo.MemoFormat == null || typeof memo.MemoFormat === 'string';
    const validType = memo.MemoType == null || typeof memo.MemoType === 'string';
    return (size >= 1 &&
        size <= MEMO_SIZE &&
        validData &&
        validFormat &&
        validType &&
        (0, utils_1.onlyHasFields)(memo, ['MemoFormat', 'MemoData', 'MemoType']));
}
const SIGNER_SIZE = 3;
function isSigner(obj) {
    const signerWrapper = obj;
    if (signerWrapper.Signer == null) {
        return false;
    }
    const signer = signerWrapper.Signer;
    return (Object.keys(signer).length === SIGNER_SIZE &&
        typeof signer.Account === 'string' &&
        typeof signer.TxnSignature === 'string' &&
        typeof signer.SigningPubKey === 'string');
}
const XAH_CURRENCY_SIZE = 1;
const ISSUE_SIZE = 2;
const ISSUED_CURRENCY_SIZE = 3;
function isRecord(value) {
    return value !== null && typeof value === 'object';
}
function isString(str) {
    return typeof str === 'string';
}
exports.isString = isString;
function isNumber(num) {
    return typeof num === 'number';
}
exports.isNumber = isNumber;
function isCurrency(input) {
    return (isRecord(input) &&
        ((Object.keys(input).length === ISSUE_SIZE &&
            typeof input.issuer === 'string' &&
            typeof input.currency === 'string') ||
            (Object.keys(input).length === XAH_CURRENCY_SIZE &&
                input.currency === 'XAH')));
}
exports.isCurrency = isCurrency;
function isIssuedCurrency(input) {
    return (isRecord(input) &&
        Object.keys(input).length === ISSUED_CURRENCY_SIZE &&
        typeof input.value === 'string' &&
        typeof input.issuer === 'string' &&
        typeof input.currency === 'string');
}
exports.isIssuedCurrency = isIssuedCurrency;
function isAccount(account) {
    return (typeof account === 'string' &&
        ((0, xahau_address_codec_1.isValidClassicAddress)(account) || (0, xahau_address_codec_1.isValidXAddress)(account)));
}
exports.isAccount = isAccount;
function isAmount(amount) {
    return typeof amount === 'string' || isIssuedCurrency(amount);
}
exports.isAmount = isAmount;
function validateRequiredField(tx, paramName, checkValidity) {
    if (tx[paramName] == null) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: missing field ${paramName}`);
    }
    if (!checkValidity(tx[paramName])) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: invalid field ${paramName}`);
    }
}
exports.validateRequiredField = validateRequiredField;
function validateOptionalField(tx, paramName, checkValidity) {
    if (tx[paramName] !== undefined && !checkValidity(tx[paramName])) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: invalid field ${paramName}`);
    }
}
exports.validateOptionalField = validateOptionalField;
function validateBaseTransaction(common) {
    if (common.TransactionType === undefined) {
        throw new errors_1.ValidationError('BaseTransaction: missing field TransactionType');
    }
    if (typeof common.TransactionType !== 'string') {
        throw new errors_1.ValidationError('BaseTransaction: TransactionType not string');
    }
    if (!xahau_binary_codec_1.TRANSACTION_TYPES.includes(common.TransactionType)) {
        throw new errors_1.ValidationError('BaseTransaction: Unknown TransactionType');
    }
    validateRequiredField(common, 'Account', isString);
    validateOptionalField(common, 'Fee', isString);
    validateOptionalField(common, 'Sequence', isNumber);
    validateOptionalField(common, 'AccountTxnID', isString);
    validateOptionalField(common, 'LastLedgerSequence', isNumber);
    const memos = common.Memos;
    if (memos !== undefined && !memos.every(isMemo)) {
        throw new errors_1.ValidationError('BaseTransaction: invalid Memos');
    }
    const signers = common.Signers;
    if (signers !== undefined &&
        (signers.length === 0 || !signers.every(isSigner))) {
        throw new errors_1.ValidationError('BaseTransaction: invalid Signers');
    }
    validateOptionalField(common, 'SourceTag', isNumber);
    validateOptionalField(common, 'SigningPubKey', isString);
    validateOptionalField(common, 'TicketSequence', isNumber);
    validateOptionalField(common, 'TxnSignature', isString);
    validateOptionalField(common, 'NetworkID', isNumber);
}
exports.validateBaseTransaction = validateBaseTransaction;
function parseAmountValue(amount) {
    if (!isAmount(amount)) {
        return NaN;
    }
    if (typeof amount === 'string') {
        return parseFloat(amount);
    }
    return parseFloat(amount.value);
}
exports.parseAmountValue = parseAmountValue;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ 4965:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateCronSet = exports.CronSetFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
var CronSetFlags;
(function (CronSetFlags) {
    CronSetFlags[CronSetFlags["tfCronUnset"] = 1] = "tfCronUnset";
})(CronSetFlags || (exports.CronSetFlags = CronSetFlags = {}));
const MAX_REPEAT_COUNT = 256;
const MIN_DELAY_SECONDS = 365 * 24 * 60 * 60;
function validateCronSet(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (typeof tx.Flags === 'number' &&
        tx.Flags & CronSetFlags.tfCronUnset) {
        if (tx.RepeatCount !== undefined ||
            tx.DelaySeconds !== undefined ||
            tx.StartTime !== undefined) {
            throw new errors_1.ValidationError('CronSet: RepeatCount, DelaySeconds, and StartTime must not be set when Flags is set to tfCronUnset');
        }
        return;
    }
    (0, common_1.validateRequiredField)(tx, 'StartTime', common_1.isNumber);
    (0, common_1.validateOptionalField)(tx, 'RepeatCount', common_1.isNumber);
    (0, common_1.validateOptionalField)(tx, 'DelaySeconds', common_1.isNumber);
    if ((tx.RepeatCount === undefined) !== (tx.DelaySeconds === undefined)) {
        throw new errors_1.ValidationError('CronSet: Both RepeatCount and DelaySeconds must be set, or neither should be set');
    }
    if (typeof tx.RepeatCount === 'number' && tx.RepeatCount > MAX_REPEAT_COUNT) {
        throw new errors_1.ValidationError(`CronSet: RepeatCount must be less than ${MAX_REPEAT_COUNT}`);
    }
    if (typeof tx.DelaySeconds === 'number' &&
        tx.DelaySeconds > MIN_DELAY_SECONDS) {
        throw new errors_1.ValidationError(`CronSet: DelaySeconds must be less than ${MIN_DELAY_SECONDS}`);
    }
}
exports.validateCronSet = validateCronSet;
//# sourceMappingURL=cronSet.js.map

/***/ }),

/***/ 5664:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateDepositPreauth = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateDepositPreauth(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Authorize !== undefined && tx.Unauthorize !== undefined) {
        throw new errors_1.ValidationError("DepositPreauth: can't provide both Authorize and Unauthorize fields");
    }
    if (tx.Authorize === undefined && tx.Unauthorize === undefined) {
        throw new errors_1.ValidationError('DepositPreauth: must provide either Authorize or Unauthorize field');
    }
    if (tx.Authorize !== undefined) {
        if (typeof tx.Authorize !== 'string') {
            throw new errors_1.ValidationError('DepositPreauth: Authorize must be a string');
        }
        if (tx.Account === tx.Authorize) {
            throw new errors_1.ValidationError("DepositPreauth: Account can't preauthorize its own address");
        }
    }
    if (tx.Unauthorize !== undefined) {
        if (typeof tx.Unauthorize !== 'string') {
            throw new errors_1.ValidationError('DepositPreauth: Unauthorize must be a string');
        }
        if (tx.Account === tx.Unauthorize) {
            throw new errors_1.ValidationError("DepositPreauth: Account can't unauthorize its own address");
        }
    }
}
exports.validateDepositPreauth = validateDepositPreauth;
//# sourceMappingURL=depositPreauth.js.map

/***/ }),

/***/ 2742:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnableAmendmentFlags = void 0;
var EnableAmendmentFlags;
(function (EnableAmendmentFlags) {
    EnableAmendmentFlags[EnableAmendmentFlags["tfGotMajority"] = 65536] = "tfGotMajority";
    EnableAmendmentFlags[EnableAmendmentFlags["tfLostMajority"] = 131072] = "tfLostMajority";
})(EnableAmendmentFlags || (exports.EnableAmendmentFlags = EnableAmendmentFlags = {}));
//# sourceMappingURL=enableAmendment.js.map

/***/ }),

/***/ 4916:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateEscrowCancel = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateEscrowCancel(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    (0, common_1.validateRequiredField)(tx, 'Owner', common_1.isAccount);
    if (tx.OfferSequence === undefined && tx.EscrowID === undefined) {
        throw new errors_1.ValidationError('EscrowCancel: must include OfferSequence or EscrowID');
    }
    if (tx.OfferSequence !== undefined && typeof tx.OfferSequence !== 'number') {
        throw new errors_1.ValidationError('EscrowCancel: OfferSequence must be a number');
    }
    if (tx.EscrowID !== undefined && typeof tx.EscrowID !== 'string') {
        throw new errors_1.ValidationError('EscrowCancel: EscrowID must be a string');
    }
}
exports.validateEscrowCancel = validateEscrowCancel;
//# sourceMappingURL=escrowCancel.js.map

/***/ }),

/***/ 8699:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateEscrowCreate = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateEscrowCreate(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Amount === undefined) {
        throw new errors_1.ValidationError('EscrowCreate: missing field Amount');
    }
    if (typeof tx.Amount !== 'string' && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError('EscrowCreate: Amount must be an Amount');
    }
    (0, common_1.validateRequiredField)(tx, 'Destination', common_1.isAccount);
    (0, common_1.validateOptionalField)(tx, 'DestinationTag', common_1.isNumber);
    if (tx.CancelAfter === undefined && tx.FinishAfter === undefined) {
        throw new errors_1.ValidationError('EscrowCreate: Either CancelAfter or FinishAfter must be specified');
    }
    if (tx.FinishAfter === undefined && tx.Condition === undefined) {
        throw new errors_1.ValidationError('EscrowCreate: Either Condition or FinishAfter must be specified');
    }
    if (tx.CancelAfter !== undefined && typeof tx.CancelAfter !== 'number') {
        throw new errors_1.ValidationError('EscrowCreate: CancelAfter must be a number');
    }
    if (tx.FinishAfter !== undefined && typeof tx.FinishAfter !== 'number') {
        throw new errors_1.ValidationError('EscrowCreate: FinishAfter must be a number');
    }
    if (tx.Condition !== undefined && typeof tx.Condition !== 'string') {
        throw new errors_1.ValidationError('EscrowCreate: Condition must be a string');
    }
}
exports.validateEscrowCreate = validateEscrowCreate;
//# sourceMappingURL=escrowCreate.js.map

/***/ }),

/***/ 1161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateEscrowFinish = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateEscrowFinish(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    (0, common_1.validateRequiredField)(tx, 'Owner', common_1.isAccount);
    if (tx.OfferSequence === undefined && tx.EscrowID === undefined) {
        throw new errors_1.ValidationError('EscrowFinish: must include OfferSequence or EscrowID');
    }
    if (tx.OfferSequence !== undefined && typeof tx.OfferSequence !== 'number') {
        throw new errors_1.ValidationError('EscrowFinish: OfferSequence must be a number');
    }
    if (tx.EscrowID !== undefined && typeof tx.EscrowID !== 'string') {
        throw new errors_1.ValidationError('EscrowFinish: EscrowID must be a string');
    }
    if (tx.Condition !== undefined && typeof tx.Condition !== 'string') {
        throw new errors_1.ValidationError('EscrowFinish: Condition must be a string');
    }
    if (tx.Fulfillment !== undefined && typeof tx.Fulfillment !== 'string') {
        throw new errors_1.ValidationError('EscrowFinish: Fulfillment must be a string');
    }
}
exports.validateEscrowFinish = validateEscrowFinish;
//# sourceMappingURL=escrowFinish.js.map

/***/ }),

/***/ 7543:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateImport = void 0;
const errors_1 = __nccwpck_require__(842);
const utils_1 = __nccwpck_require__(8429);
const common_1 = __nccwpck_require__(170);
const MAX_BLOB_LENGTH = 512;
function validateImport(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Issuer !== undefined && typeof tx.Issuer !== 'string') {
        throw new errors_1.ValidationError('Import: Issuer must be a string');
    }
    if (tx.Account === tx.Issuer) {
        throw new errors_1.ValidationError('Import: Issuer and Account must not be equal');
    }
    if (typeof tx.Blob !== 'string') {
        throw new errors_1.ValidationError('Import: Blob must be a string');
    }
    if (typeof tx.Blob === 'string' && !(0, utils_1.isHex)(tx.Blob)) {
        throw new errors_1.ValidationError('Import: Blob must be in hex format');
    }
    if (tx.Blob.length > MAX_BLOB_LENGTH) {
        throw new errors_1.ValidationError(`Import: Blob must be less than ${MAX_BLOB_LENGTH} characters`);
    }
}
exports.validateImport = validateImport;
//# sourceMappingURL=import.js.map

/***/ }),

/***/ 1736:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URITokenMintFlags = exports.TrustSetFlags = exports.RemarkFlags = exports.SetHookFlags = exports.PaymentChannelClaimFlags = exports.PaymentFlags = exports.OfferCreateFlags = exports.EnableAmendmentFlags = exports.CronSetFlags = exports.ClaimRewardFlags = exports.AccountSetTfFlags = exports.AccountSetAsfFlags = exports.validate = void 0;
var transaction_1 = __nccwpck_require__(4508);
Object.defineProperty(exports, "validate", ({ enumerable: true, get: function () { return transaction_1.validate; } }));
__exportStar(__nccwpck_require__(3144), exports);
var accountSet_1 = __nccwpck_require__(5400);
Object.defineProperty(exports, "AccountSetAsfFlags", ({ enumerable: true, get: function () { return accountSet_1.AccountSetAsfFlags; } }));
Object.defineProperty(exports, "AccountSetTfFlags", ({ enumerable: true, get: function () { return accountSet_1.AccountSetTfFlags; } }));
var claimReward_1 = __nccwpck_require__(1973);
Object.defineProperty(exports, "ClaimRewardFlags", ({ enumerable: true, get: function () { return claimReward_1.ClaimRewardFlags; } }));
var cronSet_1 = __nccwpck_require__(4965);
Object.defineProperty(exports, "CronSetFlags", ({ enumerable: true, get: function () { return cronSet_1.CronSetFlags; } }));
var enableAmendment_1 = __nccwpck_require__(2742);
Object.defineProperty(exports, "EnableAmendmentFlags", ({ enumerable: true, get: function () { return enableAmendment_1.EnableAmendmentFlags; } }));
var offerCreate_1 = __nccwpck_require__(8067);
Object.defineProperty(exports, "OfferCreateFlags", ({ enumerable: true, get: function () { return offerCreate_1.OfferCreateFlags; } }));
var payment_1 = __nccwpck_require__(1645);
Object.defineProperty(exports, "PaymentFlags", ({ enumerable: true, get: function () { return payment_1.PaymentFlags; } }));
var paymentChannelClaim_1 = __nccwpck_require__(5188);
Object.defineProperty(exports, "PaymentChannelClaimFlags", ({ enumerable: true, get: function () { return paymentChannelClaim_1.PaymentChannelClaimFlags; } }));
var setHook_1 = __nccwpck_require__(1763);
Object.defineProperty(exports, "SetHookFlags", ({ enumerable: true, get: function () { return setHook_1.SetHookFlags; } }));
var setRemarks_1 = __nccwpck_require__(9145);
Object.defineProperty(exports, "RemarkFlags", ({ enumerable: true, get: function () { return setRemarks_1.RemarkFlags; } }));
var trustSet_1 = __nccwpck_require__(7745);
Object.defineProperty(exports, "TrustSetFlags", ({ enumerable: true, get: function () { return trustSet_1.TrustSetFlags; } }));
var uriTokenMint_1 = __nccwpck_require__(1022);
Object.defineProperty(exports, "URITokenMintFlags", ({ enumerable: true, get: function () { return uriTokenMint_1.URITokenMintFlags; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9748:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateInvoke = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateInvoke(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Account === tx.Destination) {
        throw new errors_1.ValidationError('Invoke: Destination and Account must not be equal');
    }
}
exports.validateInvoke = validateInvoke;
//# sourceMappingURL=invoke.js.map

/***/ }),

/***/ 3144:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isDeletedNode = exports.isModifiedNode = exports.isCreatedNode = void 0;
function isCreatedNode(node) {
    return Object.prototype.hasOwnProperty.call(node, `CreatedNode`);
}
exports.isCreatedNode = isCreatedNode;
function isModifiedNode(node) {
    return Object.prototype.hasOwnProperty.call(node, `ModifiedNode`);
}
exports.isModifiedNode = isModifiedNode;
function isDeletedNode(node) {
    return Object.prototype.hasOwnProperty.call(node, `DeletedNode`);
}
exports.isDeletedNode = isDeletedNode;
//# sourceMappingURL=metadata.js.map

/***/ }),

/***/ 9173:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateOfferCancel = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateOfferCancel(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.OfferSequence === undefined && tx.OfferID === undefined) {
        throw new errors_1.ValidationError('OfferCancel: must include OfferSequence or OfferID');
    }
    if (tx.OfferSequence !== undefined && typeof tx.OfferSequence !== 'number') {
        throw new errors_1.ValidationError('OfferCancel: OfferSequence must be a number');
    }
    if (tx.OfferID !== undefined && typeof tx.OfferID !== 'string') {
        throw new errors_1.ValidationError('OfferCancel: OfferID must be a string');
    }
}
exports.validateOfferCancel = validateOfferCancel;
//# sourceMappingURL=offerCancel.js.map

/***/ }),

/***/ 8067:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateOfferCreate = exports.OfferCreateFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
var OfferCreateFlags;
(function (OfferCreateFlags) {
    OfferCreateFlags[OfferCreateFlags["tfPassive"] = 65536] = "tfPassive";
    OfferCreateFlags[OfferCreateFlags["tfImmediateOrCancel"] = 131072] = "tfImmediateOrCancel";
    OfferCreateFlags[OfferCreateFlags["tfFillOrKill"] = 262144] = "tfFillOrKill";
    OfferCreateFlags[OfferCreateFlags["tfSell"] = 524288] = "tfSell";
})(OfferCreateFlags || (exports.OfferCreateFlags = OfferCreateFlags = {}));
function validateOfferCreate(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.TakerGets === undefined) {
        throw new errors_1.ValidationError('OfferCreate: missing field TakerGets');
    }
    if (tx.TakerPays === undefined) {
        throw new errors_1.ValidationError('OfferCreate: missing field TakerPays');
    }
    if (typeof tx.TakerGets !== 'string' && !(0, common_1.isAmount)(tx.TakerGets)) {
        throw new errors_1.ValidationError('OfferCreate: invalid TakerGets');
    }
    if (typeof tx.TakerPays !== 'string' && !(0, common_1.isAmount)(tx.TakerPays)) {
        throw new errors_1.ValidationError('OfferCreate: invalid TakerPays');
    }
    if (tx.Expiration !== undefined && typeof tx.Expiration !== 'number') {
        throw new errors_1.ValidationError('OfferCreate: invalid Expiration');
    }
    if (tx.OfferSequence !== undefined && typeof tx.OfferSequence !== 'number') {
        throw new errors_1.ValidationError('OfferCreate: OfferSequence must be a number');
    }
    if (tx.OfferID !== undefined && typeof tx.OfferID !== 'string') {
        throw new errors_1.ValidationError('OfferCreate: OfferID must be a string');
    }
}
exports.validateOfferCreate = validateOfferCreate;
//# sourceMappingURL=offerCreate.js.map

/***/ }),

/***/ 1645:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validatePayment = exports.PaymentFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const utils_1 = __nccwpck_require__(8429);
const common_1 = __nccwpck_require__(170);
var PaymentFlags;
(function (PaymentFlags) {
    PaymentFlags[PaymentFlags["tfNoRippleDirect"] = 65536] = "tfNoRippleDirect";
    PaymentFlags[PaymentFlags["tfPartialPayment"] = 131072] = "tfPartialPayment";
    PaymentFlags[PaymentFlags["tfLimitQuality"] = 262144] = "tfLimitQuality";
})(PaymentFlags || (exports.PaymentFlags = PaymentFlags = {}));
function validatePayment(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Amount === undefined) {
        throw new errors_1.ValidationError('PaymentTransaction: missing field Amount');
    }
    if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError('PaymentTransaction: invalid Amount');
    }
    (0, common_1.validateRequiredField)(tx, 'Destination', common_1.isAccount);
    (0, common_1.validateOptionalField)(tx, 'DestinationTag', common_1.isNumber);
    if (tx.InvoiceID !== undefined && typeof tx.InvoiceID !== 'string') {
        throw new errors_1.ValidationError('PaymentTransaction: InvoiceID must be a string');
    }
    if (tx.Paths !== undefined &&
        !isPaths(tx.Paths)) {
        throw new errors_1.ValidationError('PaymentTransaction: invalid Paths');
    }
    if (tx.SendMax !== undefined && !(0, common_1.isAmount)(tx.SendMax)) {
        throw new errors_1.ValidationError('PaymentTransaction: invalid SendMax');
    }
    checkPartialPayment(tx);
}
exports.validatePayment = validatePayment;
function checkPartialPayment(tx) {
    var _a;
    if (tx.DeliverMin != null) {
        if (tx.Flags == null) {
            throw new errors_1.ValidationError('PaymentTransaction: tfPartialPayment flag required with DeliverMin');
        }
        const flags = tx.Flags;
        const isTfPartialPayment = typeof flags === 'number'
            ? (0, utils_1.isFlagEnabled)(flags, PaymentFlags.tfPartialPayment)
            : (_a = flags.tfPartialPayment) !== null && _a !== void 0 ? _a : false;
        if (!isTfPartialPayment) {
            throw new errors_1.ValidationError('PaymentTransaction: tfPartialPayment flag required with DeliverMin');
        }
        if (!(0, common_1.isAmount)(tx.DeliverMin)) {
            throw new errors_1.ValidationError('PaymentTransaction: invalid DeliverMin');
        }
    }
}
function isPathStep(pathStep) {
    if (pathStep.account !== undefined && typeof pathStep.account !== 'string') {
        return false;
    }
    if (pathStep.currency !== undefined &&
        typeof pathStep.currency !== 'string') {
        return false;
    }
    if (pathStep.issuer !== undefined && typeof pathStep.issuer !== 'string') {
        return false;
    }
    if (pathStep.account !== undefined &&
        pathStep.currency === undefined &&
        pathStep.issuer === undefined) {
        return true;
    }
    if (pathStep.currency !== undefined || pathStep.issuer !== undefined) {
        return true;
    }
    return false;
}
function isPath(path) {
    for (const pathStep of path) {
        if (!isPathStep(pathStep)) {
            return false;
        }
    }
    return true;
}
function isPaths(paths) {
    if (!Array.isArray(paths) || paths.length === 0) {
        return false;
    }
    for (const path of paths) {
        if (!Array.isArray(path) || path.length === 0) {
            return false;
        }
        if (!isPath(path)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=payment.js.map

/***/ }),

/***/ 5188:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validatePaymentChannelClaim = exports.PaymentChannelClaimFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
var PaymentChannelClaimFlags;
(function (PaymentChannelClaimFlags) {
    PaymentChannelClaimFlags[PaymentChannelClaimFlags["tfRenew"] = 65536] = "tfRenew";
    PaymentChannelClaimFlags[PaymentChannelClaimFlags["tfClose"] = 131072] = "tfClose";
})(PaymentChannelClaimFlags || (exports.PaymentChannelClaimFlags = PaymentChannelClaimFlags = {}));
function validatePaymentChannelClaim(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Channel === undefined) {
        throw new errors_1.ValidationError('PaymentChannelClaim: missing Channel');
    }
    if (typeof tx.Channel !== 'string') {
        throw new errors_1.ValidationError('PaymentChannelClaim: Channel must be a string');
    }
    if (tx.Balance !== undefined && !(0, common_1.isAmount)(tx.Balance)) {
        throw new errors_1.ValidationError('PaymentChannelClaim: Balance must be an Amount');
    }
    if (tx.Amount !== undefined && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError('PaymentChannelClaim: Amount must be an Amount');
    }
    if (tx.Signature !== undefined && typeof tx.Signature !== 'string') {
        throw new errors_1.ValidationError('PaymentChannelClaim: Signature must be a string');
    }
    if (tx.PublicKey !== undefined && typeof tx.PublicKey !== 'string') {
        throw new errors_1.ValidationError('PaymentChannelClaim: PublicKey must be a string');
    }
}
exports.validatePaymentChannelClaim = validatePaymentChannelClaim;
//# sourceMappingURL=paymentChannelClaim.js.map

/***/ }),

/***/ 8423:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validatePaymentChannelCreate = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validatePaymentChannelCreate(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Amount === undefined) {
        throw new errors_1.ValidationError('PaymentChannelCreate: missing Amount');
    }
    if (typeof tx.Amount !== 'string' && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError('PaymentChannelCreate: Amount must be an Amount');
    }
    (0, common_1.validateRequiredField)(tx, 'Destination', common_1.isAccount);
    (0, common_1.validateOptionalField)(tx, 'DestinationTag', common_1.isNumber);
    if (tx.SettleDelay === undefined) {
        throw new errors_1.ValidationError('PaymentChannelCreate: missing SettleDelay');
    }
    if (typeof tx.SettleDelay !== 'number') {
        throw new errors_1.ValidationError('PaymentChannelCreate: SettleDelay must be a number');
    }
    if (tx.PublicKey === undefined) {
        throw new errors_1.ValidationError('PaymentChannelCreate: missing PublicKey');
    }
    if (typeof tx.PublicKey !== 'string') {
        throw new errors_1.ValidationError('PaymentChannelCreate: PublicKey must be a string');
    }
    if (tx.CancelAfter !== undefined && typeof tx.CancelAfter !== 'number') {
        throw new errors_1.ValidationError('PaymentChannelCreate: CancelAfter must be a number');
    }
}
exports.validatePaymentChannelCreate = validatePaymentChannelCreate;
//# sourceMappingURL=paymentChannelCreate.js.map

/***/ }),

/***/ 2541:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validatePaymentChannelFund = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validatePaymentChannelFund(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Channel === undefined) {
        throw new errors_1.ValidationError('PaymentChannelFund: missing Channel');
    }
    if (typeof tx.Channel !== 'string') {
        throw new errors_1.ValidationError('PaymentChannelFund: Channel must be a string');
    }
    if (tx.Amount === undefined) {
        throw new errors_1.ValidationError('PaymentChannelFund: missing Amount');
    }
    if (typeof tx.Amount !== 'string' && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError('PaymentChannelFund: Amount must be an Amount');
    }
    if (tx.Expiration !== undefined && typeof tx.Expiration !== 'number') {
        throw new errors_1.ValidationError('PaymentChannelFund: Expiration must be a number');
    }
}
exports.validatePaymentChannelFund = validatePaymentChannelFund;
//# sourceMappingURL=paymentChannelFund.js.map

/***/ }),

/***/ 946:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateRemit = void 0;
const errors_1 = __nccwpck_require__(842);
const utils_1 = __nccwpck_require__(8429);
const common_1 = __nccwpck_require__(170);
const MAX_URI_LENGTH = 512;
const DIGEST_LENGTH = 64;
const MAX_ARRAY_LENGTH = 32;
const MAX_BLOB_LENGTH = 1024;
function validateRemit(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Amounts !== undefined) {
        checkAmounts(tx);
    }
    if (tx.URITokenIDs !== undefined) {
        checkURITokenIDs(tx);
    }
    if (tx.Destination === tx.Account) {
        throw new errors_1.ValidationError('Remit: Destination must not be equal to the account');
    }
    if (tx.DestinationTag != null && typeof tx.DestinationTag !== 'number') {
        throw new errors_1.ValidationError('Remit: DestinationTag must be a number');
    }
    if (tx.Inform === tx.Account || tx.Inform === tx.Destination) {
        throw new errors_1.ValidationError('Remit: Inform must not be equal to the account or destination');
    }
    if (tx.MintURIToken !== undefined) {
        checkMintURIToken(tx);
    }
    if (tx.Blob !== undefined && typeof tx.Blob !== 'string') {
        throw new errors_1.ValidationError('Remit: Blob must be a string');
    }
    if (tx.Blob !== undefined && typeof tx.Blob === 'string') {
        if (!(0, utils_1.isHex)(tx.Blob)) {
            throw new errors_1.ValidationError('Remit: Blob must be a hex string');
        }
        if (tx.Blob.length > MAX_BLOB_LENGTH) {
            throw new errors_1.ValidationError('Remit: max size Blob');
        }
    }
}
exports.validateRemit = validateRemit;
function checkAmounts(tx) {
    if (!Array.isArray(tx.Amounts)) {
        throw new errors_1.ValidationError('Remit: Amounts must be an array');
    }
    if (tx.Amounts.length < 1) {
        throw new errors_1.ValidationError('Remit: empty field Amounts');
    }
    if (tx.Amounts.length > MAX_ARRAY_LENGTH) {
        throw new errors_1.ValidationError('Remit: max field Amounts');
    }
    const seen = new Set();
    let seenXrp = false;
    for (const amount of tx.Amounts) {
        if (amount.AmountEntry === undefined ||
            typeof amount.AmountEntry !== 'object') {
            throw new errors_1.ValidationError('Remit: invalid Amounts.AmountEntry');
        }
        if (!(0, common_1.isAmount)(amount.AmountEntry.Amount)) {
            throw new errors_1.ValidationError('Remit: invalid Amounts.AmountEntry.Amount');
        }
        if (typeof amount.AmountEntry.Amount === 'string') {
            if (seenXrp) {
                throw new errors_1.ValidationError('Remit: Duplicate Native amounts are not allowed');
            }
            seenXrp = true;
        }
        else {
            const amountKey = `${amount.AmountEntry.Amount.currency}:${amount.AmountEntry.Amount.issuer}`;
            if (seen.has(amountKey)) {
                throw new errors_1.ValidationError('Remit: Duplicate amounts are not allowed');
            }
            seen.add(amountKey);
        }
    }
}
function checkURITokenIDs(tx) {
    if (!Array.isArray(tx.URITokenIDs)) {
        throw new errors_1.ValidationError('Remit: invalid field URITokenIDs');
    }
    if (tx.URITokenIDs.length < 1) {
        throw new errors_1.ValidationError('Remit: empty field URITokenIDs');
    }
    if (tx.URITokenIDs.length > MAX_ARRAY_LENGTH) {
        throw new errors_1.ValidationError('Remit: max field URITokenIDs');
    }
    const seen = new Set();
    for (const token of tx.URITokenIDs) {
        if (typeof token !== 'string' || !(0, utils_1.isHex)(token)) {
            throw new errors_1.ValidationError('Remit: URITokenID must be a hex string');
        }
        if (token.length !== DIGEST_LENGTH) {
            throw new errors_1.ValidationError(`Remit: URITokenID must be exactly ${DIGEST_LENGTH} characters`);
        }
        if (seen.has(token)) {
            throw new errors_1.ValidationError('Remit: Duplicate URITokens are not allowed');
        }
        seen.add(token);
    }
}
function checkMintURIToken(tx) {
    function isRecord(value) {
        return value !== null && typeof value === 'object';
    }
    if (!isRecord(tx.MintURIToken)) {
        throw new errors_1.ValidationError('Remit: invalid MintURIToken');
    }
    if (tx.MintURIToken.URI === undefined) {
        throw new errors_1.ValidationError('Remit: missing field MintURIToken.URI');
    }
    if (typeof tx.MintURIToken.URI !== 'string' || !(0, utils_1.isHex)(tx.MintURIToken.URI)) {
        throw new errors_1.ValidationError('Remit: MintURIToken.URI must be a hex string');
    }
    if (tx.MintURIToken.URI.length > MAX_URI_LENGTH) {
        throw new errors_1.ValidationError(`Remit: URI must be less than ${MAX_URI_LENGTH} characters`);
    }
    if (tx.MintURIToken.Digest !== undefined &&
        typeof tx.MintURIToken.Digest !== 'string') {
        throw new errors_1.ValidationError(`Remit: MintURIToken.Digest must be a string`);
    }
    if (tx.MintURIToken.Digest !== undefined &&
        !(0, utils_1.isHex)(tx.MintURIToken.Digest) &&
        tx.MintURIToken.Digest.length !== DIGEST_LENGTH) {
        throw new errors_1.ValidationError(`Remit: Digest must be exactly ${DIGEST_LENGTH} characters`);
    }
}
//# sourceMappingURL=remit.js.map

/***/ }),

/***/ 1763:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSetHook = exports.SetHookFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
var SetHookFlags;
(function (SetHookFlags) {
    SetHookFlags[SetHookFlags["hsfOverride"] = 1] = "hsfOverride";
    SetHookFlags[SetHookFlags["hsfNSDelete"] = 2] = "hsfNSDelete";
    SetHookFlags[SetHookFlags["hsfCollect"] = 4] = "hsfCollect";
})(SetHookFlags || (exports.SetHookFlags = SetHookFlags = {}));
const MAX_HOOKS = 10;
const HEX_REGEX = /^[0-9A-Fa-f]{64}$/u;
function validateSetHook(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (!Array.isArray(tx.Hooks)) {
        throw new errors_1.ValidationError('SetHook: invalid Hooks');
    }
    if (tx.Hooks.length > MAX_HOOKS) {
        throw new errors_1.ValidationError(`SetHook: maximum of ${MAX_HOOKS} hooks allowed in Hooks`);
    }
    for (const hook of tx.Hooks) {
        const hookObject = hook;
        const { HookOn, HookCanEmit, HookNamespace } = hookObject.Hook;
        if (HookOn !== undefined && !HEX_REGEX.test(HookOn)) {
            throw new errors_1.ValidationError(`SetHook: HookOn in Hook must be a 256-bit (32-byte) hexadecimal value`);
        }
        if (HookCanEmit !== undefined && !HEX_REGEX.test(HookCanEmit)) {
            throw new errors_1.ValidationError(`SetHook: HookCanEmit in Hook must be a 256-bit (32-byte) hexadecimal value`);
        }
        if (HookNamespace !== undefined && !HEX_REGEX.test(HookNamespace)) {
            throw new errors_1.ValidationError(`SetHook: HookNamespace in Hook must be a 256-bit (32-byte) hexadecimal value`);
        }
    }
}
exports.validateSetHook = validateSetHook;
//# sourceMappingURL=setHook.js.map

/***/ }),

/***/ 6868:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSetRegularKey = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateSetRegularKey(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.RegularKey !== undefined && typeof tx.RegularKey !== 'string') {
        throw new errors_1.ValidationError('SetRegularKey: RegularKey must be a string');
    }
}
exports.validateSetRegularKey = validateSetRegularKey;
//# sourceMappingURL=setRegularKey.js.map

/***/ }),

/***/ 9145:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSetRemarks = exports.RemarkFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
var RemarkFlags;
(function (RemarkFlags) {
    RemarkFlags[RemarkFlags["tfImmutable"] = 1] = "tfImmutable";
})(RemarkFlags || (exports.RemarkFlags = RemarkFlags = {}));
const HEX_REGEX = /^[0-9A-Fa-f]{64}$/u;
const MAX_REMARKS = 32;
const MAX_REMARK_NAME_LENGTH = 256;
const MAX_REMARK_VALUE_LENGTH = 256;
function validateSetRemarks(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.ObjectID == null) {
        throw new errors_1.ValidationError('SetRemarks: ObjectID is required');
    }
    if (typeof tx.ObjectID !== 'string' || !HEX_REGEX.test(tx.ObjectID)) {
        throw new errors_1.ValidationError('SetRemarks: ObjectID must be a 256-bit (32-byte) hexadecimal value');
    }
    if (tx.Remarks == null) {
        throw new errors_1.ValidationError('SetRemarks: Remarks is required');
    }
    if (!Array.isArray(tx.Remarks)) {
        throw new errors_1.ValidationError('SetRemarks: Remarks must be an array');
    }
    if (tx.Remarks.length > MAX_REMARKS) {
        throw new errors_1.ValidationError(`SetRemarks: maximum of ${MAX_REMARKS} remarks allowed in Remarks`);
    }
    for (const remark of tx.Remarks) {
        const remarkObject = remark;
        const { RemarkName, RemarkValue } = remarkObject.Remark;
        if (RemarkName.length > MAX_REMARK_NAME_LENGTH * 2) {
            throw new errors_1.ValidationError(`SetRemarks: maximum of ${MAX_REMARK_NAME_LENGTH} bytes allowed in RemarkName`);
        }
        if (RemarkValue != null &&
            RemarkValue.length > MAX_REMARK_VALUE_LENGTH * 2) {
            throw new errors_1.ValidationError(`SetRemarks: maximum of ${MAX_REMARK_VALUE_LENGTH} bytes allowed in RemarkValue`);
        }
    }
}
exports.validateSetRemarks = validateSetRemarks;
//# sourceMappingURL=setRemarks.js.map

/***/ }),

/***/ 2342:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSignerListSet = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
const MAX_SIGNERS = 32;
const HEX_WALLET_LOCATOR_REGEX = /^[0-9A-Fa-f]{64}$/u;
function validateSignerListSet(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.SignerQuorum === undefined) {
        throw new errors_1.ValidationError('SignerListSet: missing field SignerQuorum');
    }
    if (typeof tx.SignerQuorum !== 'number') {
        throw new errors_1.ValidationError('SignerListSet: invalid SignerQuorum');
    }
    if (tx.SignerQuorum === 0) {
        return;
    }
    if (tx.SignerEntries === undefined) {
        throw new errors_1.ValidationError('SignerListSet: missing field SignerEntries');
    }
    if (!Array.isArray(tx.SignerEntries)) {
        throw new errors_1.ValidationError('SignerListSet: invalid SignerEntries');
    }
    if (tx.SignerEntries.length === 0) {
        throw new errors_1.ValidationError('SignerListSet: need at least 1 member in SignerEntries');
    }
    if (tx.SignerEntries.length > MAX_SIGNERS) {
        throw new errors_1.ValidationError(`SignerListSet: maximum of ${MAX_SIGNERS} members allowed in SignerEntries`);
    }
    for (const entry of tx.SignerEntries) {
        const signerEntry = entry;
        const { WalletLocator } = signerEntry.SignerEntry;
        if (WalletLocator !== undefined &&
            !HEX_WALLET_LOCATOR_REGEX.test(WalletLocator)) {
            throw new errors_1.ValidationError(`SignerListSet: WalletLocator in SignerEntry must be a 256-bit (32-byte) hexadecimal value`);
        }
    }
}
exports.validateSignerListSet = validateSignerListSet;
//# sourceMappingURL=signerListSet.js.map

/***/ }),

/***/ 4030:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTicketCreate = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
const MAX_TICKETS = 250;
function validateTicketCreate(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    const { TicketCount } = tx;
    if (TicketCount === undefined) {
        throw new errors_1.ValidationError('TicketCreate: missing field TicketCount');
    }
    if (typeof TicketCount !== 'number') {
        throw new errors_1.ValidationError('TicketCreate: TicketCount must be a number');
    }
    if (!Number.isInteger(TicketCount) ||
        TicketCount < 1 ||
        TicketCount > MAX_TICKETS) {
        throw new errors_1.ValidationError('TicketCreate: TicketCount must be an integer from 1 to 250');
    }
}
exports.validateTicketCreate = validateTicketCreate;
//# sourceMappingURL=ticketCreate.js.map

/***/ }),

/***/ 4508:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validate = void 0;
const errors_1 = __nccwpck_require__(842);
const utils_1 = __nccwpck_require__(8429);
const flags_1 = __nccwpck_require__(7945);
const accountSet_1 = __nccwpck_require__(5400);
const checkCancel_1 = __nccwpck_require__(58);
const checkCash_1 = __nccwpck_require__(372);
const checkCreate_1 = __nccwpck_require__(9105);
const claimReward_1 = __nccwpck_require__(1973);
const clawback_1 = __nccwpck_require__(6281);
const common_1 = __nccwpck_require__(170);
const cronSet_1 = __nccwpck_require__(4965);
const depositPreauth_1 = __nccwpck_require__(5664);
const escrowCancel_1 = __nccwpck_require__(4916);
const escrowCreate_1 = __nccwpck_require__(8699);
const escrowFinish_1 = __nccwpck_require__(1161);
const import_1 = __nccwpck_require__(7543);
const invoke_1 = __nccwpck_require__(9748);
const offerCancel_1 = __nccwpck_require__(9173);
const offerCreate_1 = __nccwpck_require__(8067);
const payment_1 = __nccwpck_require__(1645);
const paymentChannelClaim_1 = __nccwpck_require__(5188);
const paymentChannelCreate_1 = __nccwpck_require__(8423);
const paymentChannelFund_1 = __nccwpck_require__(2541);
const remit_1 = __nccwpck_require__(946);
const setHook_1 = __nccwpck_require__(1763);
const setRegularKey_1 = __nccwpck_require__(6868);
const setRemarks_1 = __nccwpck_require__(9145);
const signerListSet_1 = __nccwpck_require__(2342);
const ticketCreate_1 = __nccwpck_require__(4030);
const trustSet_1 = __nccwpck_require__(7745);
const uriTokenBurn_1 = __nccwpck_require__(9600);
const uriTokenBuy_1 = __nccwpck_require__(762);
const uriTokenCancelSellOffer_1 = __nccwpck_require__(3823);
const uriTokenCreateSellOffer_1 = __nccwpck_require__(833);
const uriTokenMint_1 = __nccwpck_require__(1022);
function validate(transaction) {
    const tx = Object.assign({}, transaction);
    if (tx.TransactionType == null) {
        throw new errors_1.ValidationError('Object does not have a `TransactionType`');
    }
    if (typeof tx.TransactionType !== 'string') {
        throw new errors_1.ValidationError("Object's `TransactionType` is not a string");
    }
    if (tx.Memos != null && typeof tx.Memos !== 'object') {
        throw new errors_1.ValidationError('Memo must be array');
    }
    if (tx.Memos != null) {
        ;
        tx.Memos.forEach((memo) => {
            if ((memo === null || memo === void 0 ? void 0 : memo.Memo) == null) {
                throw new errors_1.ValidationError('Memo data must be in a `Memo` field');
            }
            if (memo.Memo.MemoData) {
                if (!(0, utils_1.isHex)(memo.Memo.MemoData)) {
                    throw new errors_1.ValidationError('MemoData field must be a hex value');
                }
            }
            if (memo.Memo.MemoType) {
                if (!(0, utils_1.isHex)(memo.Memo.MemoType)) {
                    throw new errors_1.ValidationError('MemoType field must be a hex value');
                }
            }
            if (memo.Memo.MemoFormat) {
                if (!(0, utils_1.isHex)(memo.Memo.MemoFormat)) {
                    throw new errors_1.ValidationError('MemoFormat field must be a hex value');
                }
            }
        });
    }
    Object.keys(tx).forEach((key) => {
        const standard_currency_code_len = 3;
        if (tx[key] && (0, common_1.isIssuedCurrency)(tx[key])) {
            const txCurrency = tx[key].currency;
            if (txCurrency.length === standard_currency_code_len &&
                txCurrency.toUpperCase() === 'XAH') {
                throw new errors_1.ValidationError(`Cannot have an issued currency with a similar standard code to XAH (received '${txCurrency}'). XAH is not an issued currency.`);
            }
        }
    });
    (0, flags_1.setTransactionFlagsToNumber)(tx);
    switch (tx.TransactionType) {
        case 'AccountSet':
            (0, accountSet_1.validateAccountSet)(tx);
            break;
        case 'CheckCancel':
            (0, checkCancel_1.validateCheckCancel)(tx);
            break;
        case 'CheckCash':
            (0, checkCash_1.validateCheckCash)(tx);
            break;
        case 'CheckCreate':
            (0, checkCreate_1.validateCheckCreate)(tx);
            break;
        case 'ClaimReward':
            (0, claimReward_1.validateClaimReward)(tx);
            break;
        case 'Clawback':
            (0, clawback_1.validateClawback)(tx);
            break;
        case 'CronSet':
            (0, cronSet_1.validateCronSet)(tx);
            break;
        case 'DepositPreauth':
            (0, depositPreauth_1.validateDepositPreauth)(tx);
            break;
        case 'EscrowCancel':
            (0, escrowCancel_1.validateEscrowCancel)(tx);
            break;
        case 'EscrowCreate':
            (0, escrowCreate_1.validateEscrowCreate)(tx);
            break;
        case 'EscrowFinish':
            (0, escrowFinish_1.validateEscrowFinish)(tx);
            break;
        case 'Import':
            (0, import_1.validateImport)(tx);
            break;
        case 'Invoke':
            (0, invoke_1.validateInvoke)(tx);
            break;
        case 'OfferCancel':
            (0, offerCancel_1.validateOfferCancel)(tx);
            break;
        case 'OfferCreate':
            (0, offerCreate_1.validateOfferCreate)(tx);
            break;
        case 'Payment':
            (0, payment_1.validatePayment)(tx);
            break;
        case 'PaymentChannelClaim':
            (0, paymentChannelClaim_1.validatePaymentChannelClaim)(tx);
            break;
        case 'PaymentChannelCreate':
            (0, paymentChannelCreate_1.validatePaymentChannelCreate)(tx);
            break;
        case 'PaymentChannelFund':
            (0, paymentChannelFund_1.validatePaymentChannelFund)(tx);
            break;
        case 'Remit':
            (0, remit_1.validateRemit)(tx);
            break;
        case 'SetHook':
            (0, setHook_1.validateSetHook)(tx);
            break;
        case 'SetRegularKey':
            (0, setRegularKey_1.validateSetRegularKey)(tx);
            break;
        case 'SetRemarks':
            (0, setRemarks_1.validateSetRemarks)(tx);
            break;
        case 'SignerListSet':
            (0, signerListSet_1.validateSignerListSet)(tx);
            break;
        case 'TicketCreate':
            (0, ticketCreate_1.validateTicketCreate)(tx);
            break;
        case 'TrustSet':
            (0, trustSet_1.validateTrustSet)(tx);
            break;
        case 'URITokenMint':
            (0, uriTokenMint_1.validateURITokenMint)(tx);
            break;
        case 'URITokenBurn':
            (0, uriTokenBurn_1.validateURITokenBurn)(tx);
            break;
        case 'URITokenCreateSellOffer':
            (0, uriTokenCreateSellOffer_1.validateURITokenCreateSellOffer)(tx);
            break;
        case 'URITokenBuy':
            (0, uriTokenBuy_1.validateURITokenBuy)(tx);
            break;
        case 'URITokenCancelSellOffer':
            (0, uriTokenCancelSellOffer_1.validateURITokenCancelSellOffer)(tx);
            break;
        default:
            throw new errors_1.ValidationError(`Invalid field TransactionType: ${tx.TransactionType}`);
    }
}
exports.validate = validate;
//# sourceMappingURL=transaction.js.map

/***/ }),

/***/ 7745:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTrustSet = exports.TrustSetFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
var TrustSetFlags;
(function (TrustSetFlags) {
    TrustSetFlags[TrustSetFlags["tfSetfAuth"] = 65536] = "tfSetfAuth";
    TrustSetFlags[TrustSetFlags["tfSetNoRipple"] = 131072] = "tfSetNoRipple";
    TrustSetFlags[TrustSetFlags["tfClearNoRipple"] = 262144] = "tfClearNoRipple";
    TrustSetFlags[TrustSetFlags["tfSetFreeze"] = 1048576] = "tfSetFreeze";
    TrustSetFlags[TrustSetFlags["tfClearFreeze"] = 2097152] = "tfClearFreeze";
    TrustSetFlags[TrustSetFlags["tfSetDeepFreeze"] = 4194304] = "tfSetDeepFreeze";
    TrustSetFlags[TrustSetFlags["tfClearDeepFreeze"] = 8388608] = "tfClearDeepFreeze";
})(TrustSetFlags || (exports.TrustSetFlags = TrustSetFlags = {}));
function validateTrustSet(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    const { LimitAmount, QualityIn, QualityOut } = tx;
    if (LimitAmount === undefined) {
        throw new errors_1.ValidationError('TrustSet: missing field LimitAmount');
    }
    if (!(0, common_1.isAmount)(LimitAmount)) {
        throw new errors_1.ValidationError('TrustSet: invalid LimitAmount');
    }
    if (QualityIn !== undefined && typeof QualityIn !== 'number') {
        throw new errors_1.ValidationError('TrustSet: QualityIn must be a number');
    }
    if (QualityOut !== undefined && typeof QualityOut !== 'number') {
        throw new errors_1.ValidationError('TrustSet: QualityOut must be a number');
    }
}
exports.validateTrustSet = validateTrustSet;
//# sourceMappingURL=trustSet.js.map

/***/ }),

/***/ 9600:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateURITokenBurn = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateURITokenBurn(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.URITokenID == null) {
        throw new errors_1.ValidationError('NFTokenBurn: missing field URITokenID');
    }
}
exports.validateURITokenBurn = validateURITokenBurn;
//# sourceMappingURL=uriTokenBurn.js.map

/***/ }),

/***/ 762:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateURITokenBuy = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateURITokenBuy(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Account === tx.Destination) {
        throw new errors_1.ValidationError('URITokenBuy: Destination and Account must not be equal');
    }
    if (tx.URITokenID == null) {
        throw new errors_1.ValidationError('URITokenBuy: missing field URITokenID');
    }
    if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError('URITokenBuy: invalid Amount');
    }
}
exports.validateURITokenBuy = validateURITokenBuy;
//# sourceMappingURL=uriTokenBuy.js.map

/***/ }),

/***/ 3823:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateURITokenCancelSellOffer = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateURITokenCancelSellOffer(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.URITokenID == null) {
        throw new errors_1.ValidationError('URITokenCancelSellOffer: missing field URITokenID');
    }
}
exports.validateURITokenCancelSellOffer = validateURITokenCancelSellOffer;
//# sourceMappingURL=uriTokenCancelSellOffer.js.map

/***/ }),

/***/ 833:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateURITokenCreateSellOffer = void 0;
const errors_1 = __nccwpck_require__(842);
const common_1 = __nccwpck_require__(170);
function validateURITokenCreateSellOffer(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Account === tx.Destination) {
        throw new errors_1.ValidationError('URITokenCreateSellOffer: Destination and Account must not be equal');
    }
    if (tx.URITokenID == null) {
        throw new errors_1.ValidationError('URITokenCreateSellOffer: missing field URITokenID');
    }
    if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError('URITokenCreateSellOffer: invalid Amount');
    }
}
exports.validateURITokenCreateSellOffer = validateURITokenCreateSellOffer;
//# sourceMappingURL=uriTokenCreateSellOffer.js.map

/***/ }),

/***/ 1022:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateURITokenMint = exports.URITokenMintFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const utils_1 = __nccwpck_require__(8429);
const common_1 = __nccwpck_require__(170);
var URITokenMintFlags;
(function (URITokenMintFlags) {
    URITokenMintFlags[URITokenMintFlags["tfBurnable"] = 1] = "tfBurnable";
})(URITokenMintFlags || (exports.URITokenMintFlags = URITokenMintFlags = {}));
function validateURITokenMint(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (typeof tx.URI === 'string' && !(0, utils_1.isHex)(tx.URI)) {
        throw new errors_1.ValidationError('URITokenMint: URI must be in hex format');
    }
}
exports.validateURITokenMint = validateURITokenMint;
//# sourceMappingURL=uriTokenMint.js.map

/***/ }),

/***/ 7945:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseTransactionFlags = exports.setTransactionFlagsToNumber = exports.parseAccountRootFlags = void 0;
const errors_1 = __nccwpck_require__(842);
const AccountRoot_1 = __nccwpck_require__(9341);
const accountSet_1 = __nccwpck_require__(5400);
const cronSet_1 = __nccwpck_require__(4965);
const offerCreate_1 = __nccwpck_require__(8067);
const payment_1 = __nccwpck_require__(1645);
const paymentChannelClaim_1 = __nccwpck_require__(5188);
const setHook_1 = __nccwpck_require__(1763);
const setRemarks_1 = __nccwpck_require__(9145);
const trustSet_1 = __nccwpck_require__(7745);
const _1 = __nccwpck_require__(8429);
function parseAccountRootFlags(flags) {
    const flagsInterface = {};
    Object.values(AccountRoot_1.AccountRootFlags).forEach((flag) => {
        if (typeof flag === 'string' &&
            (0, _1.isFlagEnabled)(flags, AccountRoot_1.AccountRootFlags[flag])) {
            flagsInterface[flag] = true;
        }
    });
    return flagsInterface;
}
exports.parseAccountRootFlags = parseAccountRootFlags;
const txToFlag = {
    AccountSet: accountSet_1.AccountSetTfFlags,
    OfferCreate: offerCreate_1.OfferCreateFlags,
    PaymentChannelClaim: paymentChannelClaim_1.PaymentChannelClaimFlags,
    Payment: payment_1.PaymentFlags,
    TrustSet: trustSet_1.TrustSetFlags,
    CronSet: cronSet_1.CronSetFlags,
};
function setTransactionFlagsToNumber(tx) {
    if (tx.Flags == null) {
        tx.Flags = 0;
        return;
    }
    if (typeof tx.Flags === 'number') {
        return;
    }
    if (tx.TransactionType === 'SetHook') {
        tx.Flags = convertFlagsToNumber(tx.Flags, setHook_1.SetHookFlags);
        tx.Hooks.forEach((hook) => {
            hook.Hook.Flags = convertFlagsToNumber(hook.Hook.Flags, setHook_1.SetHookFlags);
        });
    }
    else if (tx.TransactionType === 'SetRemarks') {
        tx.Remarks.forEach((remark) => {
            remark.Remark.Flags = convertFlagsToNumber(remark.Remark.Flags, setRemarks_1.RemarkFlags);
        });
    }
    tx.Flags = txToFlag[tx.TransactionType]
        ? convertFlagsToNumber(tx.Flags, txToFlag[tx.TransactionType])
        : 0;
}
exports.setTransactionFlagsToNumber = setTransactionFlagsToNumber;
function convertFlagsToNumber(flags, flagEnum) {
    return Object.keys(flags).reduce((resultFlags, flag) => {
        if (flagEnum[flag] == null) {
            throw new errors_1.ValidationError(`flag ${flag} doesn't exist in flagEnum: ${JSON.stringify(flagEnum)}`);
        }
        return flags[flag] ? resultFlags | flagEnum[flag] : resultFlags;
    }, 0);
}
function parseTransactionFlags(tx) {
    setTransactionFlagsToNumber(tx);
    if (typeof tx.Flags !== 'number' || !tx.Flags || tx.Flags === 0) {
        return {};
    }
    const flags = tx.Flags;
    const flagsMap = {};
    const flagEnum = txToFlag[tx.TransactionType];
    Object.values(flagEnum).forEach((flag) => {
        if (typeof flag === 'string' && (0, _1.isFlagEnabled)(flags, flagEnum[flag])) {
            flagsMap[flag] = true;
        }
    });
    return flagsMap;
}
exports.parseTransactionFlags = parseTransactionFlags;
//# sourceMappingURL=flags.js.map

/***/ }),

/***/ 8429:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHex = exports.isFlagEnabled = exports.onlyHasFields = void 0;
const HEX_REGEX = /^[0-9A-Fa-f]+$/u;
function onlyHasFields(obj, fields) {
    return Object.keys(obj).every((key) => fields.includes(key));
}
exports.onlyHasFields = onlyHasFields;
function isFlagEnabled(Flags, checkFlag) {
    return (BigInt(checkFlag) & BigInt(Flags)) === BigInt(checkFlag);
}
exports.isFlagEnabled = isFlagEnabled;
function isHex(str) {
    return HEX_REGEX.test(str);
}
exports.isHex = isHex;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7522:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setLatestValidatedLedgerSequence = exports.calculateFeePerTransactionType = exports.setNextValidSequenceNumber = exports.setValidAddresses = exports.txNeedsNetworkID = void 0;
const xahau_address_codec_1 = __nccwpck_require__(647);
const xahau_binary_codec_1 = __nccwpck_require__(67);
const errors_1 = __nccwpck_require__(842);
const getFeeXah_1 = __nccwpck_require__(8002);
const LEDGER_OFFSET = 20;
const RESTRICTED_NETWORKS = 1024;
function txNeedsNetworkID(client) {
    if (client.networkID !== undefined &&
        client.networkID > RESTRICTED_NETWORKS) {
        return true;
    }
    return false;
}
exports.txNeedsNetworkID = txNeedsNetworkID;
function setValidAddresses(tx) {
    validateAccountAddress(tx, 'Account', 'SourceTag');
    if (tx['Destination'] != null) {
        validateAccountAddress(tx, 'Destination', 'DestinationTag');
    }
    convertToClassicAddress(tx, 'Authorize');
    convertToClassicAddress(tx, 'Unauthorize');
    convertToClassicAddress(tx, 'Owner');
    convertToClassicAddress(tx, 'RegularKey');
}
exports.setValidAddresses = setValidAddresses;
function validateAccountAddress(tx, accountField, tagField) {
    const { classicAccount, tag } = getClassicAccountAndTag(tx[accountField]);
    tx[accountField] = classicAccount;
    if (tag != null && tag !== false) {
        if (tx[tagField] && tx[tagField] !== tag) {
            throw new errors_1.ValidationError(`The ${tagField}, if present, must match the tag of the ${accountField} X-address`);
        }
        tx[tagField] = tag;
    }
}
function getClassicAccountAndTag(Account, expectedTag) {
    if ((0, xahau_address_codec_1.isValidXAddress)(Account)) {
        const classic = (0, xahau_address_codec_1.xAddressToClassicAddress)(Account);
        if (expectedTag != null && classic.tag !== expectedTag) {
            throw new errors_1.ValidationError('address includes a tag that does not match the tag specified in the transaction');
        }
        return {
            classicAccount: classic.classicAddress,
            tag: classic.tag,
        };
    }
    return {
        classicAccount: Account,
        tag: expectedTag,
    };
}
function convertToClassicAddress(tx, fieldName) {
    const account = tx[fieldName];
    if (typeof account === 'string') {
        const { classicAccount } = getClassicAccountAndTag(account);
        tx[fieldName] = classicAccount;
    }
}
function setNextValidSequenceNumber(client, tx) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = {
            command: 'account_info',
            account: tx.Account,
            ledger_index: 'current',
        };
        const data = yield client.request(request);
        tx.Sequence = data.result.account_data.Sequence;
    });
}
exports.setNextValidSequenceNumber = setNextValidSequenceNumber;
function calculateFeePerTransactionType(client, tx, signersCount = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        const copyTx = Object.assign({}, tx);
        copyTx.SigningPubKey = ``;
        copyTx.Fee = `0`;
        const tx_blob = (0, xahau_binary_codec_1.encode)(copyTx);
        tx.Fee = yield (0, getFeeXah_1.getFeeEstimateXrp)(client, tx_blob, signersCount);
    });
}
exports.calculateFeePerTransactionType = calculateFeePerTransactionType;
function setLatestValidatedLedgerSequence(client, tx) {
    return __awaiter(this, void 0, void 0, function* () {
        const ledgerSequence = yield client.getLedgerIndex();
        tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET;
    });
}
exports.setLatestValidatedLedgerSequence = setLatestValidatedLedgerSequence;
//# sourceMappingURL=autofill.js.map

/***/ }),

/***/ 6680:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatBalances = void 0;
function formatBalances(trustlines) {
    return trustlines.map((trustline) => ({
        value: trustline.balance,
        currency: trustline.currency,
        issuer: trustline.account,
    }));
}
exports.formatBalances = formatBalances;
//# sourceMappingURL=balances.js.map

/***/ }),

/***/ 8002:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFeeEstimateXrp = void 0;
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const errors_1 = __nccwpck_require__(842);
const NUM_DECIMAL_PLACES = 6;
const BASE_10 = 10;
function getFeeXrp(client, cushion) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const feeCushion = cushion !== null && cushion !== void 0 ? cushion : client.feeCushion;
        const serverInfo = (yield client.request({
            command: 'server_info',
        })).result.info;
        const baseFee = (_a = serverInfo.validated_ledger) === null || _a === void 0 ? void 0 : _a.base_fee_xrp;
        if (baseFee == null) {
            throw new errors_1.XahlError('getFeeXrp: Could not get base_fee_xrp from server_info');
        }
        const baseFeeXrp = new bignumber_js_1.default(baseFee);
        if (serverInfo.load_factor == null) {
            serverInfo.load_factor = 1;
        }
        let fee = baseFeeXrp.times(serverInfo.load_factor).times(feeCushion);
        fee = bignumber_js_1.default.min(fee, client.maxFeeXAH);
        return new bignumber_js_1.default(fee.toFixed(NUM_DECIMAL_PLACES)).toString(BASE_10);
    });
}
exports["default"] = getFeeXrp;
function getFeeEstimateXrp(client, txBlob, signersCount = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield client.request({
            command: 'fee',
            tx_blob: txBlob,
        });
        const openLedgerFee = response.result.drops.open_ledger_fee;
        const noHookFee = response.result.drops.base_fee_no_hooks;
        let baseFee = new bignumber_js_1.default(response.result.drops.base_fee);
        if (signersCount > 0) {
            baseFee = bignumber_js_1.default.sum(openLedgerFee, scaleValue(noHookFee, 1 + signersCount));
        }
        return new bignumber_js_1.default(baseFee.toFixed(NUM_DECIMAL_PLACES)).toString(BASE_10);
    });
}
exports.getFeeEstimateXrp = getFeeEstimateXrp;
function scaleValue(value, multiplier) {
    return new bignumber_js_1.default(value).times(multiplier).toString();
}
//# sourceMappingURL=getFeeXah.js.map

/***/ }),

/***/ 5685:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sortAndLimitOffers = exports.separateBuySellOrders = exports.combineOrders = exports.extractOffers = exports.reverseRequest = exports.requestAllOffers = exports.createBookOffersRequest = exports.validateOrderbookOptions = void 0;
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const errors_1 = __nccwpck_require__(842);
const Offer_1 = __nccwpck_require__(3178);
const DEFAULT_LIMIT = 20;
function sortOffers(offers) {
    return offers.sort((offerA, offerB) => {
        var _a, _b;
        const qualityA = (_a = offerA.quality) !== null && _a !== void 0 ? _a : 0;
        const qualityB = (_b = offerB.quality) !== null && _b !== void 0 ? _b : 0;
        return new bignumber_js_1.default(qualityA).comparedTo(qualityB);
    });
}
const getOrderbookOptionsSet = new Set([
    'limit',
    'ledger_index',
    'ledger_hash',
    'taker',
]);
function validateOrderbookOptions(options) {
    for (const key of Object.keys(options)) {
        if (!getOrderbookOptionsSet.has(key)) {
            throw new errors_1.ValidationError(`Unexpected option: ${key}`, options);
        }
    }
    if (options.limit && typeof options.limit !== 'number') {
        throw new errors_1.ValidationError('limit must be a number', options.limit);
    }
    if (options.ledger_index &&
        !(typeof options.ledger_index === 'number' ||
            (typeof options.ledger_index === 'string' &&
                ['validated', 'closed', 'current'].includes(options.ledger_index)))) {
        throw new errors_1.ValidationError('ledger_index must be a number or a string of "validated", "closed", or "current"', options.ledger_index);
    }
    if (options.ledger_hash !== undefined &&
        options.ledger_hash !== null &&
        typeof options.ledger_hash !== 'string') {
        throw new errors_1.ValidationError('ledger_hash must be a string', options.ledger_hash);
    }
    if (options.taker !== undefined && typeof options.taker !== 'string') {
        throw new errors_1.ValidationError('taker must be a string', options.taker);
    }
}
exports.validateOrderbookOptions = validateOrderbookOptions;
function createBookOffersRequest(currency1, currency2, options) {
    var _a, _b;
    const request = {
        command: 'book_offers',
        taker_pays: currency1,
        taker_gets: currency2,
        ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',
        ledger_hash: options.ledger_hash === null ? undefined : options.ledger_hash,
        limit: (_b = options.limit) !== null && _b !== void 0 ? _b : DEFAULT_LIMIT,
        taker: options.taker ? options.taker : undefined,
    };
    return request;
}
exports.createBookOffersRequest = createBookOffersRequest;
function requestAllOffers(client, request) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = yield client.requestAll(request);
        return results.map((result) => result.result.offers);
    });
}
exports.requestAllOffers = requestAllOffers;
function reverseRequest(request) {
    return Object.assign(Object.assign({}, request), { taker_pays: request.taker_gets, taker_gets: request.taker_pays });
}
exports.reverseRequest = reverseRequest;
function extractOffers(offerResults) {
    return offerResults.flatMap((offerResult) => offerResult);
}
exports.extractOffers = extractOffers;
function combineOrders(directOffers, reverseOffers) {
    return [...directOffers, ...reverseOffers];
}
exports.combineOrders = combineOrders;
function separateBuySellOrders(orders) {
    const buy = [];
    const sell = [];
    orders.forEach((order) => {
        if ((order.Flags & Offer_1.OfferFlags.lsfSell) === 0) {
            buy.push(order);
        }
        else {
            sell.push(order);
        }
    });
    return { buy, sell };
}
exports.separateBuySellOrders = separateBuySellOrders;
function sortAndLimitOffers(offers, limit) {
    const sortedOffers = sortOffers(offers);
    return sortedOffers.slice(0, limit);
}
exports.sortAndLimitOffers = sortAndLimitOffers;
//# sourceMappingURL=getOrderbook.js.map

/***/ }),

/***/ 2028:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__nccwpck_require__(1354), exports);
__exportStar(__nccwpck_require__(9659), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1354:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLastLedgerSequence = exports.getSignedTx = exports.waitForFinalTransactionOutcome = exports.submitRequest = void 0;
const xahau_binary_codec_1 = __nccwpck_require__(67);
const errors_1 = __nccwpck_require__(842);
const LEDGER_CLOSE_TIME = 1000;
function sleep(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    });
}
function submitRequest(client, signedTransaction, failHard = false) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isSigned(signedTransaction)) {
            throw new errors_1.ValidationError('Transaction must be signed');
        }
        const signedTxEncoded = typeof signedTransaction === 'string'
            ? signedTransaction
            : (0, xahau_binary_codec_1.encode)(signedTransaction);
        const request = {
            command: 'submit',
            tx_blob: signedTxEncoded,
            fail_hard: isAccountDelete(signedTransaction) || failHard,
        };
        return client.request(request);
    });
}
exports.submitRequest = submitRequest;
function waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult) {
    return __awaiter(this, void 0, void 0, function* () {
        yield sleep(LEDGER_CLOSE_TIME);
        const latestLedger = yield client.getLedgerIndex();
        if (lastLedger < latestLedger) {
            throw new errors_1.XahlError(`The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).\n` +
                `Preliminary result: ${submissionResult}`);
        }
        const txResponse = yield client
            .request({
            command: 'tx',
            transaction: txHash,
        })
            .catch((error) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const message = (_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.error;
            if (message === 'txnNotFound') {
                return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);
            }
            throw new Error(`${message} \n Preliminary result: ${submissionResult}.\nFull error details: ${String(error)}`);
        }));
        if (txResponse.result.validated) {
            return txResponse;
        }
        return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);
    });
}
exports.waitForFinalTransactionOutcome = waitForFinalTransactionOutcome;
function isSigned(transaction) {
    const tx = typeof transaction === 'string' ? (0, xahau_binary_codec_1.decode)(transaction) : transaction;
    if (typeof tx === 'string') {
        return false;
    }
    if (tx.Signers != null) {
        const signers = tx.Signers;
        for (const signer of signers) {
            if (signer.Signer.SigningPubKey == null ||
                signer.Signer.TxnSignature == null) {
                return false;
            }
        }
        return true;
    }
    return tx.SigningPubKey != null && tx.TxnSignature != null;
}
function getSignedTx(client, transaction, { autofill = true, wallet, } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isSigned(transaction)) {
            return transaction;
        }
        if (!wallet) {
            throw new errors_1.ValidationError('Wallet must be provided when submitting an unsigned transaction');
        }
        let tx = typeof transaction === 'string'
            ?
                (0, xahau_binary_codec_1.decode)(transaction)
            : transaction;
        if (autofill) {
            tx = yield client.autofill(tx);
        }
        return wallet.sign(tx).tx_blob;
    });
}
exports.getSignedTx = getSignedTx;
function getLastLedgerSequence(transaction) {
    const tx = typeof transaction === 'string' ? (0, xahau_binary_codec_1.decode)(transaction) : transaction;
    return tx.LastLedgerSequence;
}
exports.getLastLedgerSequence = getLastLedgerSequence;
function isAccountDelete(transaction) {
    const tx = typeof transaction === 'string' ? (0, xahau_binary_codec_1.decode)(transaction) : transaction;
    return tx.TransactionType === 'AccountDelete';
}
//# sourceMappingURL=submit.js.map

/***/ }),

/***/ 9659:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ensureClassicAddress = void 0;
const xahau_address_codec_1 = __nccwpck_require__(647);
function ensureClassicAddress(account) {
    if ((0, xahau_address_codec_1.isValidXAddress)(account)) {
        const { classicAddress, tag } = (0, xahau_address_codec_1.xAddressToClassicAddress)(account);
        if (tag !== false) {
            throw new Error('This command does not support the use of a tag. Use an address without a tag.');
        }
        return classicAddress;
    }
    return account;
}
exports.ensureClassicAddress = ensureClassicAddress;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 991:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.omitBy = exports.groupBy = void 0;
function groupBy(array, iteratee) {
    function predicate(acc, value, index, arrayReference) {
        const key = iteratee(value, index, arrayReference) || 0;
        const group = acc[key] || [];
        group.push(value);
        acc[key] = group;
        return acc;
    }
    return array.reduce(predicate, {});
}
exports.groupBy = groupBy;
function omitBy(obj, predicate) {
    const keys = Object.keys(obj);
    const keysToKeep = keys.filter((kb) => !predicate(obj[kb], kb));
    return keysToKeep.reduce((acc, key) => {
        acc[key] = obj[key];
        return acc;
    }, {});
}
exports.omitBy = omitBy;
//# sourceMappingURL=collections.js.map

/***/ }),

/***/ 7183:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = void 0;
const xahau_address_codec_1 = __nccwpck_require__(647);
const xahau_keypairs_1 = __nccwpck_require__(4095);
Object.defineProperty(exports, "deriveKeypair", ({ enumerable: true, get: function () { return xahau_keypairs_1.deriveKeypair; } }));
Object.defineProperty(exports, "deriveAddress", ({ enumerable: true, get: function () { return xahau_keypairs_1.deriveAddress; } }));
function deriveXAddress(options) {
    const classicAddress = (0, xahau_keypairs_1.deriveAddress)(options.publicKey);
    return (0, xahau_address_codec_1.classicAddressToXAddress)(classicAddress, options.tag, options.test);
}
exports.deriveXAddress = deriveXAddress;
//# sourceMappingURL=derive.js.map

/***/ }),

/***/ 5258:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const collections_1 = __nccwpck_require__(991);
const xahConversion_1 = __nccwpck_require__(6216);
function normalizeNode(affectedNode) {
    const diffType = Object.keys(affectedNode)[0];
    const node = affectedNode[diffType];
    return Object.assign(Object.assign({}, node), { NodeType: diffType, LedgerEntryType: node.LedgerEntryType, LedgerIndex: node.LedgerIndex, NewFields: node.NewFields, FinalFields: node.FinalFields, PreviousFields: node.PreviousFields });
}
function normalizeNodes(metadata) {
    if (metadata.AffectedNodes.length === 0) {
        return [];
    }
    return metadata.AffectedNodes.map(normalizeNode);
}
function groupByAccount(balanceChanges) {
    const grouped = (0, collections_1.groupBy)(balanceChanges, (node) => node.account);
    return Object.entries(grouped).map(([account, items]) => {
        return { account, balances: items.map((item) => item.balance) };
    });
}
function getValue(balance) {
    if (typeof balance === 'string') {
        return new bignumber_js_1.default(balance);
    }
    return new bignumber_js_1.default(balance.value);
}
function computeBalanceChange(node) {
    var _a, _b, _c;
    let value = null;
    if ((_a = node.NewFields) === null || _a === void 0 ? void 0 : _a.Balance) {
        value = getValue(node.NewFields.Balance);
    }
    else if (((_b = node.PreviousFields) === null || _b === void 0 ? void 0 : _b.Balance) && ((_c = node.FinalFields) === null || _c === void 0 ? void 0 : _c.Balance)) {
        value = getValue(node.FinalFields.Balance).minus(getValue(node.PreviousFields.Balance));
    }
    if (value === null || value.isZero()) {
        return null;
    }
    return value;
}
function getXAHQuantity(node) {
    var _a, _b, _c;
    const value = computeBalanceChange(node);
    if (value === null) {
        return null;
    }
    return {
        account: ((_b = (_a = node.FinalFields) === null || _a === void 0 ? void 0 : _a.Account) !== null && _b !== void 0 ? _b : (_c = node.NewFields) === null || _c === void 0 ? void 0 : _c.Account),
        balance: {
            currency: 'XAH',
            value: (0, xahConversion_1.dropsToXah)(value).toString(),
        },
    };
}
function flipTrustlinePerspective(balanceChange) {
    const negatedBalance = new bignumber_js_1.default(balanceChange.balance.value).negated();
    return {
        account: balanceChange.balance.issuer,
        balance: {
            issuer: balanceChange.account,
            currency: balanceChange.balance.currency,
            value: negatedBalance.toString(),
        },
    };
}
function getTrustlineQuantity(node) {
    var _a, _b;
    const value = computeBalanceChange(node);
    if (value === null) {
        return null;
    }
    const fields = node.NewFields == null ? node.FinalFields : node.NewFields;
    const result = {
        account: (_a = fields === null || fields === void 0 ? void 0 : fields.LowLimit) === null || _a === void 0 ? void 0 : _a.issuer,
        balance: {
            issuer: (_b = fields === null || fields === void 0 ? void 0 : fields.HighLimit) === null || _b === void 0 ? void 0 : _b.issuer,
            currency: (fields === null || fields === void 0 ? void 0 : fields.Balance).currency,
            value: value.toString(),
        },
    };
    return [result, flipTrustlinePerspective(result)];
}
function getBalanceChanges(metadata) {
    const quantities = normalizeNodes(metadata).map((node) => {
        if (node.LedgerEntryType === 'AccountRoot') {
            const xrpQuantity = getXAHQuantity(node);
            if (xrpQuantity == null) {
                return [];
            }
            return [xrpQuantity];
        }
        if (node.LedgerEntryType === 'RippleState') {
            const trustlineQuantity = getTrustlineQuantity(node);
            if (trustlineQuantity == null) {
                return [];
            }
            return trustlineQuantity;
        }
        return [];
    });
    return groupByAccount(quantities.flat());
}
exports["default"] = getBalanceChanges;
//# sourceMappingURL=getBalanceChanges.js.map

/***/ }),

/***/ 9180:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var HashPrefix;
(function (HashPrefix) {
    HashPrefix[HashPrefix["TRANSACTION_ID"] = 1415073280] = "TRANSACTION_ID";
    HashPrefix[HashPrefix["TRANSACTION_NODE"] = 1397638144] = "TRANSACTION_NODE";
    HashPrefix[HashPrefix["INNER_NODE"] = 1296649728] = "INNER_NODE";
    HashPrefix[HashPrefix["LEAF_NODE"] = 1296846336] = "LEAF_NODE";
    HashPrefix[HashPrefix["TRANSACTION_SIGN"] = 1398036480] = "TRANSACTION_SIGN";
    HashPrefix[HashPrefix["TRANSACTION_SIGN_TESTNET"] = 1937012736] = "TRANSACTION_SIGN_TESTNET";
    HashPrefix[HashPrefix["TRANSACTION_MULTISIGN"] = 1397576704] = "TRANSACTION_MULTISIGN";
    HashPrefix[HashPrefix["LEDGER"] = 1280791040] = "LEDGER";
})(HashPrefix || (HashPrefix = {}));
exports["default"] = HashPrefix;
//# sourceMappingURL=HashPrefix.js.map

/***/ }),

/***/ 1770:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const errors_1 = __nccwpck_require__(842);
const HashPrefix_1 = __importDefault(__nccwpck_require__(9180));
const sha512Half_1 = __importDefault(__nccwpck_require__(382));
const LeafNode_1 = __importDefault(__nccwpck_require__(4917));
const node_1 = __nccwpck_require__(84);
const HEX_ZERO = '0000000000000000000000000000000000000000000000000000000000000000';
const SLOT_MAX = 15;
const HEX = 16;
class InnerNode extends node_1.Node {
    constructor(depth = 0) {
        super();
        this.leaves = {};
        this.type = node_1.NodeType.INNER;
        this.depth = depth;
        this.empty = true;
    }
    get hash() {
        if (this.empty) {
            return HEX_ZERO;
        }
        let hex = '';
        for (let iter = 0; iter <= SLOT_MAX; iter++) {
            const child = this.leaves[iter];
            const hash = child == null ? HEX_ZERO : child.hash;
            hex += hash;
        }
        const prefix = HashPrefix_1.default.INNER_NODE.toString(HEX);
        return (0, sha512Half_1.default)(prefix + hex);
    }
    addItem(tag, node) {
        const existingNode = this.getNode(parseInt(tag[this.depth], HEX));
        if (existingNode === undefined) {
            this.setNode(parseInt(tag[this.depth], HEX), node);
            return;
        }
        if (existingNode instanceof InnerNode) {
            existingNode.addItem(tag, node);
        }
        else if (existingNode instanceof LeafNode_1.default) {
            if (existingNode.tag === tag) {
                throw new errors_1.XahlError('Tried to add a node to a SHAMap that was already in there.');
            }
            else {
                const newInnerNode = new InnerNode(this.depth + 1);
                newInnerNode.addItem(existingNode.tag, existingNode);
                newInnerNode.addItem(tag, node);
                this.setNode(parseInt(tag[this.depth], HEX), newInnerNode);
            }
        }
    }
    setNode(slot, node) {
        if (slot < 0 || slot > SLOT_MAX) {
            throw new errors_1.XahlError('Invalid slot: slot must be between 0-15.');
        }
        this.leaves[slot] = node;
        this.empty = false;
    }
    getNode(slot) {
        if (slot < 0 || slot > SLOT_MAX) {
            throw new errors_1.XahlError('Invalid slot: slot must be between 0-15.');
        }
        return this.leaves[slot];
    }
}
exports["default"] = InnerNode;
//# sourceMappingURL=InnerNode.js.map

/***/ }),

/***/ 4917:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const errors_1 = __nccwpck_require__(842);
const HashPrefix_1 = __importDefault(__nccwpck_require__(9180));
const sha512Half_1 = __importDefault(__nccwpck_require__(382));
const node_1 = __nccwpck_require__(84);
const HEX = 16;
class LeafNode extends node_1.Node {
    constructor(tag, data, type) {
        super();
        this.tag = tag;
        this.type = type;
        this.data = data;
    }
    get hash() {
        switch (this.type) {
            case node_1.NodeType.ACCOUNT_STATE: {
                const leafPrefix = HashPrefix_1.default.LEAF_NODE.toString(HEX);
                return (0, sha512Half_1.default)(leafPrefix + this.data + this.tag);
            }
            case node_1.NodeType.TRANSACTION_NO_METADATA: {
                const txIDPrefix = HashPrefix_1.default.TRANSACTION_ID.toString(HEX);
                return (0, sha512Half_1.default)(txIDPrefix + this.data);
            }
            case node_1.NodeType.TRANSACTION_METADATA: {
                const txNodePrefix = HashPrefix_1.default.TRANSACTION_NODE.toString(HEX);
                return (0, sha512Half_1.default)(txNodePrefix + this.data + this.tag);
            }
            default:
                throw new errors_1.XahlError('Tried to hash a SHAMap node of unknown type.');
        }
    }
    addItem(tag, node) {
        throw new errors_1.XahlError('Cannot call addItem on a LeafNode');
        this.addItem(tag, node);
    }
}
exports["default"] = LeafNode;
//# sourceMappingURL=LeafNode.js.map

/***/ }),

/***/ 2037:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const InnerNode_1 = __importDefault(__nccwpck_require__(1770));
const LeafNode_1 = __importDefault(__nccwpck_require__(4917));
class SHAMap {
    constructor() {
        this.root = new InnerNode_1.default(0);
    }
    get hash() {
        return this.root.hash;
    }
    addItem(tag, data, type) {
        this.root.addItem(tag, new LeafNode_1.default(tag, data, type));
    }
}
__exportStar(__nccwpck_require__(84), exports);
exports["default"] = SHAMap;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 84:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Node = exports.NodeType = void 0;
var NodeType;
(function (NodeType) {
    NodeType[NodeType["INNER"] = 1] = "INNER";
    NodeType[NodeType["TRANSACTION_NO_METADATA"] = 2] = "TRANSACTION_NO_METADATA";
    NodeType[NodeType["TRANSACTION_METADATA"] = 3] = "TRANSACTION_METADATA";
    NodeType[NodeType["ACCOUNT_STATE"] = 4] = "ACCOUNT_STATE";
})(NodeType || (exports.NodeType = NodeType = {}));
class Node {
}
exports.Node = Node;
//# sourceMappingURL=node.js.map

/***/ }),

/***/ 9716:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashStateTree = exports.hashTxTree = exports.hashLedgerHeader = exports.hashSignedTx = void 0;
const utils_1 = __nccwpck_require__(3617);
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const xahau_binary_codec_1 = __nccwpck_require__(67);
const errors_1 = __nccwpck_require__(842);
const HashPrefix_1 = __importDefault(__nccwpck_require__(9180));
const sha512Half_1 = __importDefault(__nccwpck_require__(382));
const SHAMap_1 = __importStar(__nccwpck_require__(2037));
const HEX = 16;
function intToHex(integer, byteLength) {
    const foo = Number(integer)
        .toString(HEX)
        .padStart(byteLength * 2, '0');
    return foo;
}
function bigintToHex(integerString, byteLength) {
    const hex = new bignumber_js_1.default(integerString).toString(HEX);
    return hex.padStart(byteLength * 2, '0');
}
function addLengthPrefix(hex) {
    const length = hex.length / 2;
    if (length <= 192) {
        return (0, utils_1.bytesToHex)([length]) + hex;
    }
    if (length <= 12480) {
        const prefix = length - 193;
        return (0, utils_1.bytesToHex)([193 + (prefix >>> 8), prefix & 0xff]) + hex;
    }
    if (length <= 918744) {
        const prefix = length - 12481;
        return ((0, utils_1.bytesToHex)([
            241 + (prefix >>> 16),
            (prefix >>> 8) & 0xff,
            prefix & 0xff,
        ]) + hex);
    }
    throw new errors_1.XahlError('Variable integer overflow.');
}
function hashSignedTx(tx) {
    let txBlob;
    let txObject;
    if (typeof tx === 'string') {
        txBlob = tx;
        txObject = (0, xahau_binary_codec_1.decode)(tx);
    }
    else {
        txBlob = (0, xahau_binary_codec_1.encode)(tx);
        txObject = tx;
    }
    if (!txObject.EmitDetails &&
        txObject.TxnSignature === undefined &&
        txObject.Signers === undefined &&
        txObject.SigningPubKey === undefined) {
        throw new errors_1.ValidationError('The transaction must be signed to hash it.');
    }
    const prefix = HashPrefix_1.default.TRANSACTION_ID.toString(16).toUpperCase();
    return (0, sha512Half_1.default)(prefix.concat(txBlob));
}
exports.hashSignedTx = hashSignedTx;
function hashLedgerHeader(ledgerHeader) {
    const prefix = HashPrefix_1.default.LEDGER.toString(HEX).toUpperCase();
    const ledger = prefix +
        intToHex(Number(ledgerHeader.ledger_index), 4) +
        bigintToHex(ledgerHeader.total_coins, 8) +
        ledgerHeader.parent_hash +
        ledgerHeader.transaction_hash +
        ledgerHeader.account_hash +
        intToHex(ledgerHeader.parent_close_time, 4) +
        intToHex(ledgerHeader.close_time, 4) +
        intToHex(ledgerHeader.close_time_resolution, 1) +
        intToHex(ledgerHeader.close_flags, 1);
    return (0, sha512Half_1.default)(ledger);
}
exports.hashLedgerHeader = hashLedgerHeader;
function hashTxTree(transactions) {
    var _a;
    const shamap = new SHAMap_1.default();
    for (const txJSON of transactions) {
        const txBlobHex = (0, xahau_binary_codec_1.encode)(txJSON);
        const metaHex = (0, xahau_binary_codec_1.encode)((_a = txJSON.metaData) !== null && _a !== void 0 ? _a : {});
        const txHash = hashSignedTx(txBlobHex);
        const data = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex);
        shamap.addItem(txHash, data, SHAMap_1.NodeType.TRANSACTION_METADATA);
    }
    return shamap.hash;
}
exports.hashTxTree = hashTxTree;
function hashStateTree(entries) {
    const shamap = new SHAMap_1.default();
    entries.forEach((ledgerEntry) => {
        const data = (0, xahau_binary_codec_1.encode)(ledgerEntry);
        shamap.addItem(ledgerEntry.index, data, SHAMap_1.NodeType.ACCOUNT_STATE);
    });
    return shamap.hash;
}
exports.hashStateTree = hashStateTree;
function computeTransactionHash(ledger, options) {
    const { transaction_hash } = ledger;
    if (!options.computeTreeHashes) {
        return transaction_hash;
    }
    if (ledger.transactions == null) {
        throw new errors_1.ValidationError('transactions is missing from the ledger');
    }
    const transactionHash = hashTxTree(ledger.transactions);
    if (transaction_hash !== transactionHash) {
        throw new errors_1.ValidationError('transactionHash in header' +
            ' does not match computed hash of transactions', {
            transactionHashInHeader: transaction_hash,
            computedHashOfTransactions: transactionHash,
        });
    }
    return transactionHash;
}
function computeStateHash(ledger, options) {
    const { account_hash } = ledger;
    if (!options.computeTreeHashes) {
        return account_hash;
    }
    if (ledger.accountState == null) {
        throw new errors_1.ValidationError('accountState is missing from the ledger');
    }
    const stateHash = hashStateTree(ledger.accountState);
    if (account_hash !== stateHash) {
        throw new errors_1.ValidationError('stateHash in header does not match computed hash of state');
    }
    return stateHash;
}
function hashLedger(ledger, options = {}) {
    const subhashes = {
        transaction_hash: computeTransactionHash(ledger, options),
        account_hash: computeStateHash(ledger, options),
    };
    return hashLedgerHeader(Object.assign(Object.assign({}, ledger), subhashes));
}
exports["default"] = hashLedger;
//# sourceMappingURL=hashLedger.js.map

/***/ }),

/***/ 6983:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashTxTree = exports.hashStateTree = exports.hashLedger = exports.hashSignedTx = exports.hashLedgerHeader = exports.hashCron = exports.hashURIToken = exports.hashPaymentChannel = exports.hashEscrow = exports.hashTrustline = exports.hashOfferId = exports.hashSignerListId = exports.hashAccountRoot = exports.hashTx = void 0;
const utils_1 = __nccwpck_require__(3617);
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const xahau_address_codec_1 = __nccwpck_require__(647);
const hashLedger_1 = __importStar(__nccwpck_require__(9716));
exports.hashLedger = hashLedger_1.default;
Object.defineProperty(exports, "hashLedgerHeader", ({ enumerable: true, get: function () { return hashLedger_1.hashLedgerHeader; } }));
Object.defineProperty(exports, "hashSignedTx", ({ enumerable: true, get: function () { return hashLedger_1.hashSignedTx; } }));
Object.defineProperty(exports, "hashTxTree", ({ enumerable: true, get: function () { return hashLedger_1.hashTxTree; } }));
Object.defineProperty(exports, "hashStateTree", ({ enumerable: true, get: function () { return hashLedger_1.hashStateTree; } }));
const HashPrefix_1 = __importDefault(__nccwpck_require__(9180));
const ledgerSpaces_1 = __importDefault(__nccwpck_require__(754));
const sha512Half_1 = __importDefault(__nccwpck_require__(382));
const HEX = 16;
const BYTE_LENGTH = 4;
function addressToHex(address) {
    return (0, utils_1.bytesToHex)((0, xahau_address_codec_1.decodeAccountID)(address));
}
function ledgerSpaceHex(name) {
    return ledgerSpaces_1.default[name].charCodeAt(0).toString(HEX).padStart(4, '0');
}
const MASK = 0xff;
function currencyToHex(currency) {
    if (currency.length !== 3) {
        return currency;
    }
    const bytes = Array(20).fill(0);
    bytes[12] = currency.charCodeAt(0) & MASK;
    bytes[13] = currency.charCodeAt(1) & MASK;
    bytes[14] = currency.charCodeAt(2) & MASK;
    return (0, utils_1.bytesToHex)(Uint8Array.from(bytes));
}
function hashTx(txBlobHex) {
    const prefix = HashPrefix_1.default.TRANSACTION_SIGN.toString(HEX).toUpperCase();
    return (0, sha512Half_1.default)(prefix + txBlobHex);
}
exports.hashTx = hashTx;
function hashAccountRoot(address) {
    return (0, sha512Half_1.default)(ledgerSpaceHex('account') + addressToHex(address));
}
exports.hashAccountRoot = hashAccountRoot;
function hashSignerListId(address) {
    return (0, sha512Half_1.default)(`${ledgerSpaceHex('signerList') + addressToHex(address)}00000000`);
}
exports.hashSignerListId = hashSignerListId;
function hashOfferId(address, sequence) {
    const hexPrefix = ledgerSpaces_1.default.offer
        .charCodeAt(0)
        .toString(HEX)
        .padStart(2, '0');
    const hexSequence = sequence.toString(HEX).padStart(8, '0');
    const prefix = `00${hexPrefix}`;
    return (0, sha512Half_1.default)(prefix + addressToHex(address) + hexSequence);
}
exports.hashOfferId = hashOfferId;
function hashTrustline(address1, address2, currency) {
    const address1Hex = addressToHex(address1);
    const address2Hex = addressToHex(address2);
    const swap = new bignumber_js_1.default(address1Hex, 16).isGreaterThan(new bignumber_js_1.default(address2Hex, 16));
    const lowAddressHex = swap ? address2Hex : address1Hex;
    const highAddressHex = swap ? address1Hex : address2Hex;
    const prefix = ledgerSpaceHex('rippleState');
    return (0, sha512Half_1.default)(prefix + lowAddressHex + highAddressHex + currencyToHex(currency));
}
exports.hashTrustline = hashTrustline;
function hashEscrow(address, sequence) {
    return (0, sha512Half_1.default)(ledgerSpaceHex('escrow') +
        addressToHex(address) +
        sequence.toString(HEX).padStart(BYTE_LENGTH * 2, '0'));
}
exports.hashEscrow = hashEscrow;
function hashPaymentChannel(address, dstAddress, sequence) {
    return (0, sha512Half_1.default)(ledgerSpaceHex('paychan') +
        addressToHex(address) +
        addressToHex(dstAddress) +
        sequence.toString(HEX).padStart(BYTE_LENGTH * 2, '0'));
}
exports.hashPaymentChannel = hashPaymentChannel;
function hashURIToken(issuer, uri) {
    return (0, sha512Half_1.default)(ledgerSpaceHex('uriToken') + addressToHex(issuer) + (0, utils_1.stringToHex)(uri));
}
exports.hashURIToken = hashURIToken;
function hashCron(owner, time) {
    const timeString = (0, utils_1.bytesToHex)([
        (time >> 24) & 0xff,
        (time >> 16) & 0xff,
        (time >> 8) & 0xff,
        (time >> 0) & 0xff,
    ]);
    const nsHash = (0, sha512Half_1.default)(ledgerSpaceHex('cron')).slice(0, 16);
    const accHash = (0, sha512Half_1.default)(ledgerSpaceHex('cron') + timeString + addressToHex(owner)).slice(0, 40);
    return nsHash + timeString + accHash;
}
exports.hashCron = hashCron;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 754:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const ledgerSpaces = {
    account: 'a',
    dirNode: 'd',
    generatorMap: 'g',
    rippleState: 'r',
    offer: 'o',
    ownerDir: 'O',
    bookDir: 'B',
    contract: 'c',
    skipList: 's',
    escrow: 'u',
    amendment: 'f',
    feeSettings: 'e',
    ticket: 'T',
    signerList: 'S',
    paychan: 'x',
    check: 'C',
    depositPreauth: 'p',
    uriToken: 'U',
    cron: 'L',
};
exports["default"] = ledgerSpaces;
//# sourceMappingURL=ledgerSpaces.js.map

/***/ }),

/***/ 382:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const sha512_1 = __nccwpck_require__(65);
const utils_1 = __nccwpck_require__(3617);
const HASH_BYTES = 32;
function sha512Half(hex) {
    return (0, utils_1.bytesToHex)((0, sha512_1.sha512)((0, utils_1.hexToBytes)(hex)).slice(0, HASH_BYTES));
}
exports["default"] = sha512Half;
//# sourceMappingURL=sha512Half.js.map

/***/ }),

/***/ 5044:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexHookParameters = exports.calculateHookCanEmit = exports.calculateHookOn = void 0;
const xahau_binary_codec_1 = __nccwpck_require__(67);
const errors_1 = __nccwpck_require__(842);
function calculateHookOn(arr) {
    let hash = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff';
    arr.forEach((nth) => {
        if (typeof nth !== 'string') {
            throw new errors_1.XahlError(`HookOn transaction type must be string`);
        }
        if (!xahau_binary_codec_1.TRANSACTION_TYPES.includes(String(nth))) {
            throw new errors_1.XahlError(`invalid transaction type '${String(nth)}' in HookOn array`);
        }
        const tts = xahau_binary_codec_1.TRANSACTION_TYPE_MAP;
        let value = BigInt(hash);
        value ^= BigInt(1) << BigInt(tts[nth]);
        hash = `0x${value.toString(16)}`;
    });
    hash = hash.replace('0x', '');
    hash = hash.padStart(64, '0');
    return hash.toUpperCase();
}
exports.calculateHookOn = calculateHookOn;
function calculateHookCanEmit(arr) {
    return calculateHookOn(arr);
}
exports.calculateHookCanEmit = calculateHookCanEmit;
function isHex(value) {
    return /^[0-9A-F]+$/iu.test(value);
}
function hexValue(value) {
    return Buffer.from(value, 'utf8').toString('hex').toUpperCase();
}
function hexHookParameters(data) {
    const hookParameters = [];
    for (const parameter of data) {
        let hookPName = parameter.HookParameter.HookParameterName;
        let hookPValue = parameter.HookParameter.HookParameterValue;
        if (!isHex(hookPName)) {
            hookPName = hexValue(hookPName);
        }
        if (hookPValue && !isHex(hookPValue)) {
            hookPValue = hexValue(hookPValue);
        }
        hookParameters.push({
            HookParameter: {
                HookParameterName: hookPName,
                HookParameterValue: hookPValue,
            },
        });
    }
    return hookParameters;
}
exports.hexHookParameters = hexHookParameters;
//# sourceMappingURL=hooks.js.map

/***/ }),

/***/ 8329:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexHookParameters = exports.calculateHookCanEmit = exports.calculateHookOn = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encodeForMultiSigning = exports.decode = exports.encode = exports.decodeXAddress = exports.encodeXAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.isValidClassicAddress = exports.isValidXAddress = exports.xAddressToClassicAddress = exports.classicAddressToXAddress = exports.convertHexToString = exports.convertStringToHex = exports.verifyPaymentChannelClaim = exports.verifyKeypairSignature = exports.signPaymentChannelClaim = exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = exports.hashes = exports.isValidAddress = exports.isValidSecret = exports.qualityToDecimal = exports.transferRateToDecimal = exports.decimalToTransferRate = exports.percentToTransferRate = exports.decimalToQuality = exports.percentToQuality = exports.unixTimeToRippleTime = exports.rippleTimeToUnixTime = exports.isoTimeToRippleTime = exports.rippleTimeToISOTime = exports.hasNextPage = exports.xahToDrops = exports.dropsToXah = exports.getBalanceChanges = void 0;
const xahau_address_codec_1 = __nccwpck_require__(647);
Object.defineProperty(exports, "classicAddressToXAddress", ({ enumerable: true, get: function () { return xahau_address_codec_1.classicAddressToXAddress; } }));
Object.defineProperty(exports, "decodeAccountID", ({ enumerable: true, get: function () { return xahau_address_codec_1.decodeAccountID; } }));
Object.defineProperty(exports, "decodeAccountPublic", ({ enumerable: true, get: function () { return xahau_address_codec_1.decodeAccountPublic; } }));
Object.defineProperty(exports, "decodeNodePublic", ({ enumerable: true, get: function () { return xahau_address_codec_1.decodeNodePublic; } }));
Object.defineProperty(exports, "decodeSeed", ({ enumerable: true, get: function () { return xahau_address_codec_1.decodeSeed; } }));
Object.defineProperty(exports, "decodeXAddress", ({ enumerable: true, get: function () { return xahau_address_codec_1.decodeXAddress; } }));
Object.defineProperty(exports, "encodeAccountID", ({ enumerable: true, get: function () { return xahau_address_codec_1.encodeAccountID; } }));
Object.defineProperty(exports, "encodeAccountPublic", ({ enumerable: true, get: function () { return xahau_address_codec_1.encodeAccountPublic; } }));
Object.defineProperty(exports, "encodeNodePublic", ({ enumerable: true, get: function () { return xahau_address_codec_1.encodeNodePublic; } }));
Object.defineProperty(exports, "encodeSeed", ({ enumerable: true, get: function () { return xahau_address_codec_1.encodeSeed; } }));
Object.defineProperty(exports, "encodeXAddress", ({ enumerable: true, get: function () { return xahau_address_codec_1.encodeXAddress; } }));
Object.defineProperty(exports, "isValidClassicAddress", ({ enumerable: true, get: function () { return xahau_address_codec_1.isValidClassicAddress; } }));
Object.defineProperty(exports, "isValidXAddress", ({ enumerable: true, get: function () { return xahau_address_codec_1.isValidXAddress; } }));
Object.defineProperty(exports, "xAddressToClassicAddress", ({ enumerable: true, get: function () { return xahau_address_codec_1.xAddressToClassicAddress; } }));
const xahau_binary_codec_1 = __nccwpck_require__(67);
const xahau_keypairs_1 = __nccwpck_require__(4095);
Object.defineProperty(exports, "verifyKeypairSignature", ({ enumerable: true, get: function () { return xahau_keypairs_1.verify; } }));
const derive_1 = __nccwpck_require__(7183);
Object.defineProperty(exports, "deriveKeypair", ({ enumerable: true, get: function () { return derive_1.deriveKeypair; } }));
Object.defineProperty(exports, "deriveAddress", ({ enumerable: true, get: function () { return derive_1.deriveAddress; } }));
Object.defineProperty(exports, "deriveXAddress", ({ enumerable: true, get: function () { return derive_1.deriveXAddress; } }));
const getBalanceChanges_1 = __importDefault(__nccwpck_require__(5258));
exports.getBalanceChanges = getBalanceChanges_1.default;
const hashes_1 = __nccwpck_require__(6983);
const hooks_1 = __nccwpck_require__(5044);
Object.defineProperty(exports, "calculateHookOn", ({ enumerable: true, get: function () { return hooks_1.calculateHookOn; } }));
Object.defineProperty(exports, "calculateHookCanEmit", ({ enumerable: true, get: function () { return hooks_1.calculateHookCanEmit; } }));
Object.defineProperty(exports, "hexHookParameters", ({ enumerable: true, get: function () { return hooks_1.hexHookParameters; } }));
const quality_1 = __nccwpck_require__(8782);
Object.defineProperty(exports, "percentToTransferRate", ({ enumerable: true, get: function () { return quality_1.percentToTransferRate; } }));
Object.defineProperty(exports, "decimalToTransferRate", ({ enumerable: true, get: function () { return quality_1.decimalToTransferRate; } }));
Object.defineProperty(exports, "transferRateToDecimal", ({ enumerable: true, get: function () { return quality_1.transferRateToDecimal; } }));
Object.defineProperty(exports, "percentToQuality", ({ enumerable: true, get: function () { return quality_1.percentToQuality; } }));
Object.defineProperty(exports, "decimalToQuality", ({ enumerable: true, get: function () { return quality_1.decimalToQuality; } }));
Object.defineProperty(exports, "qualityToDecimal", ({ enumerable: true, get: function () { return quality_1.qualityToDecimal; } }));
const signPaymentChannelClaim_1 = __importDefault(__nccwpck_require__(4175));
exports.signPaymentChannelClaim = signPaymentChannelClaim_1.default;
const stringConversion_1 = __nccwpck_require__(1593);
Object.defineProperty(exports, "convertHexToString", ({ enumerable: true, get: function () { return stringConversion_1.convertHexToString; } }));
Object.defineProperty(exports, "convertStringToHex", ({ enumerable: true, get: function () { return stringConversion_1.convertStringToHex; } }));
const timeConversion_1 = __nccwpck_require__(6447);
Object.defineProperty(exports, "rippleTimeToISOTime", ({ enumerable: true, get: function () { return timeConversion_1.rippleTimeToISOTime; } }));
Object.defineProperty(exports, "isoTimeToRippleTime", ({ enumerable: true, get: function () { return timeConversion_1.isoTimeToRippleTime; } }));
Object.defineProperty(exports, "rippleTimeToUnixTime", ({ enumerable: true, get: function () { return timeConversion_1.rippleTimeToUnixTime; } }));
Object.defineProperty(exports, "unixTimeToRippleTime", ({ enumerable: true, get: function () { return timeConversion_1.unixTimeToRippleTime; } }));
const verifyPaymentChannelClaim_1 = __importDefault(__nccwpck_require__(2900));
exports.verifyPaymentChannelClaim = verifyPaymentChannelClaim_1.default;
const xahConversion_1 = __nccwpck_require__(6216);
Object.defineProperty(exports, "xahToDrops", ({ enumerable: true, get: function () { return xahConversion_1.xahToDrops; } }));
Object.defineProperty(exports, "dropsToXah", ({ enumerable: true, get: function () { return xahConversion_1.dropsToXah; } }));
function isValidSecret(secret) {
    try {
        (0, derive_1.deriveKeypair)(secret);
        return true;
    }
    catch (_err) {
        return false;
    }
}
exports.isValidSecret = isValidSecret;
function encode(object) {
    return (0, xahau_binary_codec_1.encode)(object);
}
exports.encode = encode;
function encodeForSigning(object) {
    return (0, xahau_binary_codec_1.encodeForSigning)(object);
}
exports.encodeForSigning = encodeForSigning;
function encodeForSigningClaim(object) {
    return (0, xahau_binary_codec_1.encodeForSigningClaim)(object);
}
exports.encodeForSigningClaim = encodeForSigningClaim;
function encodeForMultiSigning(object, signer) {
    return (0, xahau_binary_codec_1.encodeForMultisigning)(object, signer);
}
exports.encodeForMultiSigning = encodeForMultiSigning;
function decode(hex) {
    return (0, xahau_binary_codec_1.decode)(hex);
}
exports.decode = decode;
function isValidAddress(address) {
    return (0, xahau_address_codec_1.isValidXAddress)(address) || (0, xahau_address_codec_1.isValidClassicAddress)(address);
}
exports.isValidAddress = isValidAddress;
function hasNextPage(response) {
    return Boolean(response.result['marker']);
}
exports.hasNextPage = hasNextPage;
const hashes = {
    hashSignedTx: hashes_1.hashSignedTx,
    hashTx: hashes_1.hashTx,
    hashAccountRoot: hashes_1.hashAccountRoot,
    hashSignerListId: hashes_1.hashSignerListId,
    hashOfferId: hashes_1.hashOfferId,
    hashTrustline: hashes_1.hashTrustline,
    hashTxTree: hashes_1.hashTxTree,
    hashStateTree: hashes_1.hashStateTree,
    hashLedger: hashes_1.hashLedger,
    hashLedgerHeader: hashes_1.hashLedgerHeader,
    hashEscrow: hashes_1.hashEscrow,
    hashPaymentChannel: hashes_1.hashPaymentChannel,
    hashURIToken: hashes_1.hashURIToken,
};
exports.hashes = hashes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8782:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.percentToQuality = exports.transferRateToDecimal = exports.qualityToDecimal = exports.decimalToQuality = exports.percentToTransferRate = exports.decimalToTransferRate = void 0;
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const errors_1 = __nccwpck_require__(842);
const BASE_TEN = 10;
const ONE_BILLION = '1000000000';
const TWO_BILLION = '2000000000';
function percentToDecimal(percent) {
    if (!percent.endsWith('%')) {
        throw new errors_1.ValidationError(`Value ${percent} must end with %`);
    }
    const split = percent.split('%').filter((str) => str !== '');
    if (split.length !== 1) {
        throw new errors_1.ValidationError(`Value ${percent} contains too many % signs`);
    }
    return new bignumber_js_1.default(split[0]).dividedBy('100').toString(BASE_TEN);
}
function decimalToTransferRate(decimal) {
    const rate = new bignumber_js_1.default(decimal).times(ONE_BILLION).plus(ONE_BILLION);
    if (rate.isLessThan(ONE_BILLION) || rate.isGreaterThan(TWO_BILLION)) {
        throw new errors_1.ValidationError(`Decimal value must be between 0 and 1.00.`);
    }
    const billionths = rate.toString(BASE_TEN);
    if (billionths === ONE_BILLION) {
        return 0;
    }
    if (billionths === 'NaN') {
        throw new errors_1.ValidationError(`Value is not a number`);
    }
    if (billionths.includes('.')) {
        throw new errors_1.ValidationError(`Decimal exceeds maximum precision.`);
    }
    return Number(billionths);
}
exports.decimalToTransferRate = decimalToTransferRate;
function percentToTransferRate(percent) {
    return decimalToTransferRate(percentToDecimal(percent));
}
exports.percentToTransferRate = percentToTransferRate;
function decimalToQuality(decimal) {
    const rate = new bignumber_js_1.default(decimal).times(ONE_BILLION);
    const billionths = rate.toString(BASE_TEN);
    if (billionths === 'NaN') {
        throw new errors_1.ValidationError(`Value is not a number`);
    }
    if (billionths.includes('-')) {
        throw new errors_1.ValidationError('Cannot have negative Quality');
    }
    if (billionths === ONE_BILLION) {
        return 0;
    }
    if (billionths.includes('.')) {
        throw new errors_1.ValidationError(`Decimal exceeds maximum precision.`);
    }
    return Number(billionths);
}
exports.decimalToQuality = decimalToQuality;
function qualityToDecimal(quality) {
    if (!Number.isInteger(quality)) {
        throw new errors_1.ValidationError('Quality must be an integer');
    }
    if (quality < 0) {
        throw new errors_1.ValidationError('Negative quality not allowed');
    }
    if (quality === 0) {
        return '1';
    }
    const decimal = new bignumber_js_1.default(quality).dividedBy(ONE_BILLION);
    return decimal.toString(BASE_TEN);
}
exports.qualityToDecimal = qualityToDecimal;
function transferRateToDecimal(rate) {
    if (!Number.isInteger(rate)) {
        throw new errors_1.ValidationError('Error decoding, transfer Rate must be an integer');
    }
    if (rate === 0) {
        return '0';
    }
    const decimal = new bignumber_js_1.default(rate).minus(ONE_BILLION).dividedBy(ONE_BILLION);
    if (decimal.isLessThan(0)) {
        throw new errors_1.ValidationError('Error decoding, negative transfer rate');
    }
    return decimal.toString(BASE_TEN);
}
exports.transferRateToDecimal = transferRateToDecimal;
function percentToQuality(percent) {
    return decimalToQuality(percentToDecimal(percent));
}
exports.percentToQuality = percentToQuality;
//# sourceMappingURL=quality.js.map

/***/ }),

/***/ 4175:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const xahau_binary_codec_1 = __nccwpck_require__(67);
const xahau_keypairs_1 = __nccwpck_require__(4095);
const xahConversion_1 = __nccwpck_require__(6216);
function signPaymentChannelClaim(channel, xrpAmount, privateKey) {
    const signingData = (0, xahau_binary_codec_1.encodeForSigningClaim)({
        channel,
        amount: (0, xahConversion_1.xahToDrops)(xrpAmount),
    });
    return (0, xahau_keypairs_1.sign)(signingData, privateKey);
}
exports["default"] = signPaymentChannelClaim;
//# sourceMappingURL=signPaymentChannelClaim.js.map

/***/ }),

/***/ 1593:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertStringToHex = exports.convertHexToString = void 0;
const utils_1 = __nccwpck_require__(3617);
function convertStringToHex(string) {
    return (0, utils_1.stringToHex)(string);
}
exports.convertStringToHex = convertStringToHex;
function convertHexToString(hex, encoding = 'utf8') {
    return (0, utils_1.hexToString)(hex, encoding);
}
exports.convertHexToString = convertHexToString;
//# sourceMappingURL=stringConversion.js.map

/***/ }),

/***/ 6447:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isoTimeToRippleTime = exports.rippleTimeToISOTime = exports.unixTimeToRippleTime = exports.rippleTimeToUnixTime = void 0;
const RIPPLE_EPOCH_DIFF = 0x386d4380;
function rippleTimeToUnixTime(rpepoch) {
    return (rpepoch + RIPPLE_EPOCH_DIFF) * 1000;
}
exports.rippleTimeToUnixTime = rippleTimeToUnixTime;
function unixTimeToRippleTime(timestamp) {
    return Math.round(timestamp / 1000) - RIPPLE_EPOCH_DIFF;
}
exports.unixTimeToRippleTime = unixTimeToRippleTime;
function rippleTimeToISOTime(xahauTime) {
    return new Date(rippleTimeToUnixTime(xahauTime)).toISOString();
}
exports.rippleTimeToISOTime = rippleTimeToISOTime;
function isoTimeToRippleTime(iso8601) {
    const isoDate = typeof iso8601 === 'string' ? new Date(iso8601) : iso8601;
    return unixTimeToRippleTime(isoDate.getTime());
}
exports.isoTimeToRippleTime = isoTimeToRippleTime;
//# sourceMappingURL=timeConversion.js.map

/***/ }),

/***/ 2900:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const xahau_binary_codec_1 = __nccwpck_require__(67);
const xahau_keypairs_1 = __nccwpck_require__(4095);
const xahConversion_1 = __nccwpck_require__(6216);
function verifyPaymentChannelClaim(channel, xrpAmount, signature, publicKey) {
    const signingData = (0, xahau_binary_codec_1.encodeForSigningClaim)({
        channel,
        amount: (0, xahConversion_1.xahToDrops)(xrpAmount),
    });
    return (0, xahau_keypairs_1.verify)(signingData, signature, publicKey);
}
exports["default"] = verifyPaymentChannelClaim;
//# sourceMappingURL=verifyPaymentChannelClaim.js.map

/***/ }),

/***/ 6216:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.xahToDrops = exports.dropsToXah = void 0;
const bignumber_js_1 = __importDefault(__nccwpck_require__(7558));
const errors_1 = __nccwpck_require__(842);
const DROPS_PER_XAH = 1000000.0;
const MAX_FRACTION_LENGTH = 6;
const BASE_TEN = 10;
const SANITY_CHECK = /^-?[0-9.]+$/u;
function dropsToXah(dropsToConvert) {
    const drops = new bignumber_js_1.default(dropsToConvert).toString(BASE_TEN);
    if (typeof dropsToConvert === 'string' && drops === 'NaN') {
        throw new errors_1.ValidationError(`dropsToXah: invalid value '${dropsToConvert}', should be a BigNumber or string-encoded number.`);
    }
    if (drops.includes('.')) {
        throw new errors_1.ValidationError(`dropsToXah: value '${drops}' has too many decimal places.`);
    }
    if (!SANITY_CHECK.exec(drops)) {
        throw new errors_1.ValidationError(`dropsToXah: failed sanity check -` +
            ` value '${drops}',` +
            ` does not match (^-?[0-9]+$).`);
    }
    return new bignumber_js_1.default(drops).dividedBy(DROPS_PER_XAH).toNumber();
}
exports.dropsToXah = dropsToXah;
function xahToDrops(xrpToConvert) {
    const xrp = new bignumber_js_1.default(xrpToConvert).toString(BASE_TEN);
    if (typeof xrpToConvert === 'string' && xrp === 'NaN') {
        throw new errors_1.ValidationError(`xahToDrops: invalid value '${xrpToConvert}', should be a BigNumber or string-encoded number.`);
    }
    if (!SANITY_CHECK.exec(xrp)) {
        throw new errors_1.ValidationError(`xahToDrops: failed sanity check - value '${xrp}', does not match (^-?[0-9.]+$).`);
    }
    const components = xrp.split('.');
    if (components.length > 2) {
        throw new errors_1.ValidationError(`xahToDrops: failed sanity check - value '${xrp}' has too many decimal points.`);
    }
    const fraction = components[1] || '0';
    if (fraction.length > MAX_FRACTION_LENGTH) {
        throw new errors_1.ValidationError(`xahToDrops: value '${xrp}' has too many decimal places.`);
    }
    return new bignumber_js_1.default(xrp)
        .times(DROPS_PER_XAH)
        .integerValue(bignumber_js_1.default.ROUND_FLOOR)
        .toString(BASE_TEN);
}
exports.xahToDrops = xahToDrops;
//# sourceMappingURL=xahConversion.js.map

/***/ }),

/***/ 2594:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__nccwpck_require__(6798), exports);
__exportStar(__nccwpck_require__(4790), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6798:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Account = void 0;
const ripple_keypairs_1 = __nccwpck_require__(1551);
const utils_1 = __nccwpck_require__(4790);
class Account {
    constructor(secretNumbers) {
        this._account = {
            familySeed: '',
            address: '',
            keypair: {
                publicKey: '',
                privateKey: '',
            },
        };
        if (typeof secretNumbers === 'string') {
            this._secret = (0, utils_1.parseSecretString)(secretNumbers);
        }
        else if (Array.isArray(secretNumbers)) {
            this._secret = secretNumbers;
        }
        else if (secretNumbers instanceof Uint8Array) {
            this._secret = (0, utils_1.entropyToSecret)(secretNumbers);
        }
        else {
            this._secret = (0, utils_1.randomSecret)();
        }
        validateLengths(this._secret);
        this.derive();
    }
    getSecret() {
        return this._secret;
    }
    getSecretString() {
        return this._secret.join(' ');
    }
    getAddress() {
        return this._account.address;
    }
    getFamilySeed() {
        return this._account.familySeed;
    }
    getKeypair() {
        return this._account.keypair;
    }
    toString() {
        return this.getSecretString();
    }
    derive() {
        try {
            const entropy = (0, utils_1.secretToEntropy)(this._secret);
            this._account.familySeed = (0, ripple_keypairs_1.generateSeed)({ entropy });
            this._account.keypair = (0, ripple_keypairs_1.deriveKeypair)(this._account.familySeed);
            this._account.address = (0, ripple_keypairs_1.deriveAddress)(this._account.keypair.publicKey);
        }
        catch (error) {
            let message = 'Unknown Error';
            if (error instanceof Error) {
                message = error.message;
            }
            throw new Error(message);
        }
    }
}
exports.Account = Account;
function validateLengths(secretNumbers) {
    if (secretNumbers.length !== 8) {
        throw new Error('Secret must have 8 numbers');
    }
    secretNumbers.forEach((num) => {
        if (num.length !== 6) {
            throw new Error('Each secret number must be 6 digits');
        }
    });
}
//# sourceMappingURL=Account.js.map

/***/ }),

/***/ 4790:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSecretString = exports.checkChecksum = exports.calculateChecksum = exports.secretToEntropy = exports.entropyToSecret = exports.randomSecret = exports.randomEntropy = void 0;
const utils_1 = __nccwpck_require__(3617);
function randomEntropy() {
    return (0, utils_1.randomBytes)(16);
}
exports.randomEntropy = randomEntropy;
function calculateChecksum(position, value) {
    return (value * (position * 2 + 1)) % 9;
}
exports.calculateChecksum = calculateChecksum;
function checkChecksum(position, value, checksum) {
    let normalizedChecksum;
    let normalizedValue;
    if (typeof value === 'string') {
        if (value.length !== 6) {
            throw new Error('value must have a length of 6');
        }
        normalizedChecksum = parseInt(value.slice(5), 10);
        normalizedValue = parseInt(value.slice(0, 5), 10);
    }
    else {
        if (typeof checksum !== 'number') {
            throw new Error('checksum must be a number when value is a number');
        }
        normalizedChecksum = checksum;
        normalizedValue = value;
    }
    return (normalizedValue * (position * 2 + 1)) % 9 === normalizedChecksum;
}
exports.checkChecksum = checkChecksum;
function entropyToSecret(entropy) {
    const len = new Array(Math.ceil(entropy.length / 2));
    const chunks = Array.from(len, (_a, chunk) => {
        const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2);
        const no = parseInt((0, utils_1.bytesToHex)(buffChunk), 16);
        const fill = '0'.repeat(5 - String(no).length);
        return fill + String(no) + String(calculateChecksum(chunk, no));
    });
    if (chunks.length !== 8) {
        throw new Error('Chucks must have 8 digits');
    }
    return chunks;
}
exports.entropyToSecret = entropyToSecret;
function randomSecret() {
    return entropyToSecret(randomEntropy());
}
exports.randomSecret = randomSecret;
function secretToEntropy(secret) {
    return (0, utils_1.concat)(secret.map((chunk, i) => {
        const no = Number(chunk.slice(0, 5));
        const checksum = Number(chunk.slice(5));
        if (chunk.length !== 6) {
            throw new Error('Invalid secret: number invalid');
        }
        if (!checkChecksum(i, no, checksum)) {
            throw new Error('Invalid secret part: checksum invalid');
        }
        const hex = `0000${no.toString(16)}`.slice(-4);
        return (0, utils_1.hexToBytes)(hex);
    }));
}
exports.secretToEntropy = secretToEntropy;
function parseSecretString(secret) {
    const normalizedSecret = secret.replace(/[^0-9]/gu, '');
    if (normalizedSecret.length !== 48) {
        throw new Error('Invalid secret string (should contain 8 blocks of 6 digits');
    }
    return Array.from(new Array(8), (_a, index) => {
        return normalizedSecret.slice(index * 6, (index + 1) * 6);
    });
}
exports.parseSecretString = parseSecretString;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4300:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("buffer");

/***/ }),

/***/ 6113:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("net");

/***/ }),

/***/ 6005:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:crypto");

/***/ }),

/***/ 9563:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("path");

/***/ }),

/***/ 2781:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("stream");

/***/ }),

/***/ 4404:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("tls");

/***/ }),

/***/ 7310:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("url");

/***/ }),

/***/ 9796:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("zlib");

/***/ }),

/***/ 3892:
/***/ ((module) => {

module.exports = JSON.parse('{"TYPES":{"Done":-1,"Unknown":-2,"NotPresent":0,"UInt16":1,"UInt32":2,"UInt64":3,"Hash128":4,"Hash256":5,"Amount":6,"Blob":7,"AccountID":8,"STObject":14,"STArray":15,"UInt8":16,"Hash160":17,"PathSet":18,"Vector256":19,"UInt96":20,"UInt192":21,"UInt384":22,"UInt512":23,"Transaction":10001,"LedgerEntry":10002,"Validation":10003,"Metadata":10004},"LEDGER_ENTRY_TYPES":{"Invalid":-1,"AccountRoot":97,"Cron":65,"DirectoryNode":100,"RippleState":114,"Ticket":84,"SignerList":83,"Offer":111,"LedgerHashes":104,"Amendments":102,"FeeSettings":115,"ImportVLSequence":73,"Escrow":117,"PayChannel":120,"Check":67,"DepositPreauth":112,"NegativeUNL":78,"NFTokenPage":80,"NFTokenOffer":55,"URIToken":85,"UNLReport":82,"Any":-3,"Child":-2,"Nickname":110,"Contract":99,"GeneratorMap":103,"Hook":72,"HookState":118,"HookDefinition":68,"EmittedTxn":69},"FIELDS":[["Generic",{"nth":0,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Unknown"}],["Invalid",{"nth":-1,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Unknown"}],["ObjectEndMarker",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["ArrayEndMarker",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["hash",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Hash256"}],["index",{"nth":258,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Hash256"}],["taker_gets_funded",{"nth":258,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Amount"}],["taker_pays_funded",{"nth":259,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Amount"}],["LedgerEntry",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"LedgerEntry"}],["Transaction",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Transaction"}],["Validation",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Validation"}],["Metadata",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Metadata"}],["CloseResolution",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["Method",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["TransactionResult",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["TickSize",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["UNLModifyDisabling",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["HookResult",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["LedgerEntryType",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["TransactionType",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["SignerWeight",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["TransferFee",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["Version",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookStateChangeCount",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookEmitCount",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookExecutionIndex",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookApiVersion",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookStateScale",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["NetworkID",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Flags",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SourceTag",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Sequence",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["PreviousTxnLgrSeq",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LedgerSequence",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["CloseTime",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ParentCloseTime",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SigningTime",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Expiration",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TransferRate",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["WalletSize",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OwnerCount",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["DestinationTag",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HighQualityIn",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HighQualityOut",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LowQualityIn",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LowQualityOut",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["QualityIn",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["QualityOut",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["StampEscrow",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["BondAmount",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LoadFee",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OfferSequence",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FirstLedgerSequence",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LastLedgerSequence",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TransactionIndex",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OperationLimit",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReferenceFeeUnits",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReserveBase",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReserveIncrement",{"nth":32,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SetFlag",{"nth":33,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ClearFlag",{"nth":34,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SignerQuorum",{"nth":35,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["CancelAfter",{"nth":36,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FinishAfter",{"nth":37,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SignerListID",{"nth":38,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SettleDelay",{"nth":39,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TicketCount",{"nth":40,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TicketSequence",{"nth":41,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["NFTokenTaxon",{"nth":42,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["MintedNFTokens",{"nth":43,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["BurnedNFTokens",{"nth":44,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HookStateCount",{"nth":45,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["EmitGeneration",{"nth":46,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LockCount",{"nth":49,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FirstNFTokenSequence",{"nth":50,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["StartTime",{"nth":93,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["RepeatCount",{"nth":94,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["DelaySeconds",{"nth":95,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["XahauActivationLgrSeq",{"nth":96,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ImportSequence",{"nth":97,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["RewardTime",{"nth":98,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["RewardLgrFirst",{"nth":99,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["RewardLgrLast",{"nth":100,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["IndexNext",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["IndexPrevious",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["BookNode",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["OwnerNode",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["BaseFee",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ExchangeRate",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["LowNode",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HighNode",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["DestinationNode",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["Cookie",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ServerVersion",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["NFTokenOfferNode",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["EmitBurden",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HookInstructionCount",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HookReturnCode",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ReferenceCount",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["TouchCount",{"nth":97,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["AccountIndex",{"nth":98,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["AccountCount",{"nth":99,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["RewardAccumulator",{"nth":100,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["EmailHash",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash128"}],["TakerPaysCurrency",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerPaysIssuer",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerGetsCurrency",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerGetsIssuer",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["LedgerHash",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ParentHash",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["TransactionHash",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["AccountHash",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["PreviousTxnID",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["LedgerIndex",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["WalletLocator",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["RootIndex",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["AccountTxnID",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenID",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitParentTxnID",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitNonce",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitHookHash",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ObjectID",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["BookDirectory",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["InvoiceID",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Nickname",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Amendment",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookOn",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Digest",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Channel",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ConsensusHash",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["CheckID",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ValidatedHash",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["PreviousPageMin",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NextPageMin",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenBuyOffer",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenSellOffer",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookStateKey",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookHash",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookNamespace",{"nth":32,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookSetTxnID",{"nth":33,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["OfferID",{"nth":34,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EscrowID",{"nth":35,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["URITokenID",{"nth":36,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["GovernanceFlags",{"nth":99,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["GovernanceMarks",{"nth":98,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmittedTxnID",{"nth":97,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookCanEmit",{"nth":96,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Cron",{"nth":95,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Amount",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Balance",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LimitAmount",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["TakerPays",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["TakerGets",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LowLimit",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["HighLimit",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Fee",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["SendMax",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["DeliverMin",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["MinimumOffer",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["RippleEscrow",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["DeliveredAmount",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["NFTokenBrokerFee",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["HookCallbackFee",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LockedBalance",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["BaseFeeDrops",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["ReserveBaseDrops",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["ReserveIncrementDrops",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["PublicKey",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MessageKey",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["SigningPubKey",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["TxnSignature",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["URI",{"nth":5,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Signature",{"nth":6,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["Domain",{"nth":7,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["FundCode",{"nth":8,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["RemoveCode",{"nth":9,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ExpireCode",{"nth":10,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["CreateCode",{"nth":11,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoType",{"nth":12,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoData",{"nth":13,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoFormat",{"nth":14,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Fulfillment",{"nth":16,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Condition",{"nth":17,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MasterSignature",{"nth":18,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["UNLModifyValidator",{"nth":19,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ValidatorToDisable",{"nth":20,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ValidatorToReEnable",{"nth":21,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookStateData",{"nth":22,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookReturnString",{"nth":23,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookParameterName",{"nth":24,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookParameterValue",{"nth":25,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Blob",{"nth":26,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["RemarkValue",{"nth":98,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["RemarkName",{"nth":99,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Account",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Owner",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Destination",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Issuer",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Authorize",{"nth":5,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Unauthorize",{"nth":6,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["RegularKey",{"nth":8,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["NFTokenMinter",{"nth":9,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["EmitCallback",{"nth":10,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["HookAccount",{"nth":16,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Inform",{"nth":99,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Indexes",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Hashes",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Amendments",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["NFTokenOffers",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["HookNamespaces",{"nth":5,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["URITokenIDs",{"nth":99,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Paths",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"PathSet"}],["TransactionMetaData",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["CreatedNode",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["DeletedNode",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["ModifiedNode",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["PreviousFields",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["FinalFields",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["NewFields",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["TemplateEntry",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Memo",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["SignerEntry",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["NFToken",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["EmitDetails",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Hook",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Signer",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Majority",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["DisabledValidator",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["EmittedTxn",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookExecution",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookDefinition",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookParameter",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookGrant",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Remark",{"nth":97,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["GenesisMint",{"nth":96,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["ActiveValidator",{"nth":95,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["ImportVLKey",{"nth":94,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookEmission",{"nth":93,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["MintURIToken",{"nth":92,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["AmountEntry",{"nth":91,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Signers",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":false,"type":"STArray"}],["SignerEntries",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Template",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Necessary",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Sufficient",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["AffectedNodes",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Memos",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["NFTokens",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Hooks",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Majorities",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["DisabledValidators",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookExecutions",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookParameters",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookGrants",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Remarks",{"nth":97,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["GenesisMints",{"nth":96,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["ActiveValidators",{"nth":95,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["ImportVLKeys",{"nth":94,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookEmissions",{"nth":93,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Amounts",{"nth":92,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}]],"TRANSACTION_RESULTS":{"telLOCAL_ERROR":-399,"telBAD_DOMAIN":-398,"telBAD_PATH_COUNT":-397,"telBAD_PUBLIC_KEY":-396,"telFAILED_PROCESSING":-395,"telINSUF_FEE_P":-394,"telNO_DST_PARTIAL":-393,"telCAN_NOT_QUEUE":-392,"telCAN_NOT_QUEUE_BALANCE":-391,"telCAN_NOT_QUEUE_BLOCKS":-390,"telCAN_NOT_QUEUE_BLOCKED":-389,"telCAN_NOT_QUEUE_FEE":-388,"telCAN_NOT_QUEUE_FULL":-387,"telWRONG_NETWORK":-386,"telREQUIRES_NETWORK_ID":-385,"telNETWORK_ID_MAKES_TX_NON_CANONICAL":-384,"telNON_LOCAL_EMITTED_TXN":-383,"telIMPORT_VL_KEY_NOT_RECOGNISED":-382,"telCAN_NOT_QUEUE_IMPORT":-381,"temMALFORMED":-299,"temBAD_AMOUNT":-298,"temBAD_CURRENCY":-297,"temBAD_EXPIRATION":-296,"temBAD_FEE":-295,"temBAD_ISSUER":-294,"temBAD_LIMIT":-293,"temBAD_OFFER":-292,"temBAD_PATH":-291,"temBAD_PATH_LOOP":-290,"temBAD_REGKEY":-289,"temBAD_SEND_NATIVE_LIMIT":-288,"temBAD_SEND_NATIVE_MAX":-287,"temBAD_SEND_NATIVE_NO_DIRECT":-286,"temBAD_SEND_NATIVE_PARTIAL":-285,"temBAD_SEND_NATIVE_PATHS":-284,"temBAD_SEQUENCE":-283,"temBAD_SIGNATURE":-282,"temBAD_SRC_ACCOUNT":-281,"temBAD_TRANSFER_RATE":-280,"temDST_IS_SRC":-279,"temDST_NEEDED":-278,"temINVALID":-277,"temINVALID_FLAG":-276,"temREDUNDANT":-275,"temRIPPLE_EMPTY":-274,"temDISABLED":-273,"temBAD_SIGNER":-272,"temBAD_QUORUM":-271,"temBAD_WEIGHT":-270,"temBAD_TICK_SIZE":-269,"temINVALID_ACCOUNT_ID":-268,"temCANNOT_PREAUTH_SELF":-267,"temINVALID_COUNT":-266,"temUNCERTAIN":-265,"temUNKNOWN":-264,"temSEQ_AND_TICKET":-263,"temBAD_NFTOKEN_TRANSFER_FEE":-262,"temAMM_BAD_TOKENS":-261,"temXCHAIN_EQUAL_DOOR_ACCOUNTS":-260,"temXCHAIN_BAD_PROOF":-259,"temXCHAIN_BRIDGE_BAD_ISSUES":-258,"temXCHAIN_BRIDGE_NONDOOR_OWNER":-257,"temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT":-256,"temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT":-255,"temXCHAIN_TOO_MANY_ATTESTATIONS":-254,"temHOOK_DATA_TOO_LARGE":-253,"tefFAILURE":-199,"tefALREADY":-198,"tefBAD_ADD_AUTH":-197,"tefBAD_AUTH":-196,"tefBAD_LEDGER":-195,"tefCREATED":-194,"tefEXCEPTION":-193,"tefINTERNAL":-192,"tefNO_AUTH_REQUIRED":-191,"tefPAST_SEQ":-190,"tefWRONG_PRIOR":-189,"tefMASTER_DISABLED":-188,"tefMAX_LEDGER":-187,"tefBAD_SIGNATURE":-186,"tefBAD_QUORUM":-185,"tefNOT_MULTI_SIGNING":-184,"tefBAD_AUTH_MASTER":-183,"tefINVARIANT_FAILED":-182,"tefTOO_BIG":-181,"tefNO_TICKET":-180,"tefNFTOKEN_IS_NOT_TRANSFERABLE":-179,"tefPAST_IMPORT_SEQ":-178,"tefPAST_IMPORT_VL_SEQ":-177,"tefNONDIR_EMIT":-176,"tefIMPORT_BLACKHOLED":-175,"terRETRY":-99,"terFUNDS_SPENT":-98,"terINSUF_FEE_B":-97,"terNO_ACCOUNT":-96,"terNO_AUTH":-95,"terNO_LINE":-94,"terOWNERS":-93,"terPRE_SEQ":-92,"terLAST":-91,"terNO_RIPPLE":-90,"terQUEUED":-89,"terPRE_TICKET":-88,"terNO_AMM":-87,"terNO_HOOK":-86,"tesSUCCESS":0,"tesPARTIAL":1,"tecCLAIM":100,"tecPATH_PARTIAL":101,"tecUNFUNDED_ADD":102,"tecUNFUNDED_OFFER":103,"tecUNFUNDED_PAYMENT":104,"tecFAILED_PROCESSING":105,"tecDIR_FULL":121,"tecINSUF_RESERVE_LINE":122,"tecINSUF_RESERVE_OFFER":123,"tecNO_DST":124,"tecNO_DST_INSUF_NATIVE":125,"tecNO_LINE_INSUF_RESERVE":126,"tecNO_LINE_REDUNDANT":127,"tecPATH_DRY":128,"tecUNFUNDED":129,"tecNO_ALTERNATIVE_KEY":130,"tecNO_REGULAR_KEY":131,"tecOWNERS":132,"tecNO_ISSUER":133,"tecNO_AUTH":134,"tecNO_LINE":135,"tecINSUFF_FEE":136,"tecFROZEN":137,"tecNO_TARGET":138,"tecNO_PERMISSION":139,"tecNO_ENTRY":140,"tecINSUFFICIENT_RESERVE":141,"tecNEED_MASTER_KEY":142,"tecDST_TAG_NEEDED":143,"tecINTERNAL":144,"tecOVERSIZE":145,"tecCRYPTOCONDITION_ERROR":146,"tecINVARIANT_FAILED":147,"tecEXPIRED":148,"tecDUPLICATE":149,"tecKILLED":150,"tecHAS_OBLIGATIONS":151,"tecTOO_SOON":152,"tecHOOK_REJECTED":153,"tecMAX_SEQUENCE_REACHED":154,"tecNO_SUITABLE_NFTOKEN_PAGE":155,"tecNFTOKEN_BUY_SELL_MISMATCH":156,"tecNFTOKEN_OFFER_TYPE_MISMATCH":157,"tecCANT_ACCEPT_OWN_NFTOKEN_OFFER":158,"tecINSUFFICIENT_FUNDS":159,"tecOBJECT_NOT_FOUND":160,"tecINSUFFICIENT_PAYMENT":161,"tecAMM_UNFUNDED":162,"tecAMM_BALANCE":163,"tecAMM_FAILED_DEPOSIT":164,"tecAMM_FAILED_WITHDRAW":165,"tecAMM_INVALID_TOKENS":166,"tecAMM_FAILED_BID":167,"tecAMM_FAILED_VOTE":168,"tecREQUIRES_FLAG":169,"tecPRECISION_LOSS":170,"tecBAD_XCHAIN_TRANSFER_ISSUE":171,"tecXCHAIN_NO_CLAIM_ID":172,"tecXCHAIN_BAD_CLAIM_ID":173,"tecXCHAIN_CLAIM_NO_QUORUM":174,"tecXCHAIN_PROOF_UNKNOWN_KEY":175,"tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE":176,"tecXCHAIN_WRONG_CHAIN":177,"tecXCHAIN_REWARD_MISMATCH":178,"tecXCHAIN_NO_SIGNERS_LIST":179,"tecXCHAIN_SENDING_ACCOUNT_MISMATCH":180,"tecXCHAIN_INSUFF_CREATE_AMOUNT":181,"tecXCHAIN_ACCOUNT_CREATE_PAST":182,"tecXCHAIN_ACCOUNT_CREATE_TOO_MANY":183,"tecXCHAIN_PAYMENT_FAILED":184,"tecXCHAIN_SELF_COMMIT":185,"tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR":186,"tecINSUF_RESERVE_SELLER":187,"tecIMMUTABLE":188,"tecTOO_MANY_REMARKS":189,"tecHAS_HOOK_STATE":190,"tecLAST_POSSIBLE_ENTRY":255},"TRANSACTION_TYPES":{"Invalid":-1,"Payment":0,"EscrowCreate":1,"EscrowFinish":2,"AccountSet":3,"EscrowCancel":4,"SetRegularKey":5,"NickNameSet":6,"OfferCreate":7,"OfferCancel":8,"Contract":9,"TicketCreate":10,"TicketCancel":11,"SignerListSet":12,"PaymentChannelCreate":13,"PaymentChannelFund":14,"PaymentChannelClaim":15,"CheckCreate":16,"CheckCash":17,"CheckCancel":18,"DepositPreauth":19,"TrustSet":20,"AccountDelete":21,"SetHook":22,"NFTokenMint":25,"NFTokenBurn":26,"NFTokenCreateOffer":27,"NFTokenCancelOffer":28,"NFTokenAcceptOffer":29,"Clawback":30,"URITokenMint":45,"URITokenBurn":46,"URITokenBuy":47,"URITokenCreateSellOffer":48,"URITokenCancelSellOffer":49,"Cron":92,"CronSet":93,"SetRemarks":94,"Remit":95,"GenesisMint":96,"Import":97,"ClaimReward":98,"Invoke":99,"EnableAmendment":100,"SetFee":101,"UNLModify":102,"EmitFailure":103,"UNLReport":104}}');

/***/ }),

/***/ 2103:
/***/ ((module) => {

module.exports = JSON.parse('["A","ABE","ACE","ACT","AD","ADA","ADD","AGO","AID","AIM","AIR","ALL","ALP","AM","AMY","AN","ANA","AND","ANN","ANT","ANY","APE","APS","APT","ARC","ARE","ARK","ARM","ART","AS","ASH","ASK","AT","ATE","AUG","AUK","AVE","AWE","AWK","AWL","AWN","AX","AYE","BAD","BAG","BAH","BAM","BAN","BAR","BAT","BAY","BE","BED","BEE","BEG","BEN","BET","BEY","BIB","BID","BIG","BIN","BIT","BOB","BOG","BON","BOO","BOP","BOW","BOY","BUB","BUD","BUG","BUM","BUN","BUS","BUT","BUY","BY","BYE","CAB","CAL","CAM","CAN","CAP","CAR","CAT","CAW","COD","COG","COL","CON","COO","COP","COT","COW","COY","CRY","CUB","CUE","CUP","CUR","CUT","DAB","DAD","DAM","DAN","DAR","DAY","DEE","DEL","DEN","DES","DEW","DID","DIE","DIG","DIN","DIP","DO","DOE","DOG","DON","DOT","DOW","DRY","DUB","DUD","DUE","DUG","DUN","EAR","EAT","ED","EEL","EGG","EGO","ELI","ELK","ELM","ELY","EM","END","EST","ETC","EVA","EVE","EWE","EYE","FAD","FAN","FAR","FAT","FAY","FED","FEE","FEW","FIB","FIG","FIN","FIR","FIT","FLO","FLY","FOE","FOG","FOR","FRY","FUM","FUN","FUR","GAB","GAD","GAG","GAL","GAM","GAP","GAS","GAY","GEE","GEL","GEM","GET","GIG","GIL","GIN","GO","GOT","GUM","GUN","GUS","GUT","GUY","GYM","GYP","HA","HAD","HAL","HAM","HAN","HAP","HAS","HAT","HAW","HAY","HE","HEM","HEN","HER","HEW","HEY","HI","HID","HIM","HIP","HIS","HIT","HO","HOB","HOC","HOE","HOG","HOP","HOT","HOW","HUB","HUE","HUG","HUH","HUM","HUT","I","ICY","IDA","IF","IKE","ILL","INK","INN","IO","ION","IQ","IRA","IRE","IRK","IS","IT","ITS","IVY","JAB","JAG","JAM","JAN","JAR","JAW","JAY","JET","JIG","JIM","JO","JOB","JOE","JOG","JOT","JOY","JUG","JUT","KAY","KEG","KEN","KEY","KID","KIM","KIN","KIT","LA","LAB","LAC","LAD","LAG","LAM","LAP","LAW","LAY","LEA","LED","LEE","LEG","LEN","LEO","LET","LEW","LID","LIE","LIN","LIP","LIT","LO","LOB","LOG","LOP","LOS","LOT","LOU","LOW","LOY","LUG","LYE","MA","MAC","MAD","MAE","MAN","MAO","MAP","MAT","MAW","MAY","ME","MEG","MEL","MEN","MET","MEW","MID","MIN","MIT","MOB","MOD","MOE","MOO","MOP","MOS","MOT","MOW","MUD","MUG","MUM","MY","NAB","NAG","NAN","NAP","NAT","NAY","NE","NED","NEE","NET","NEW","NIB","NIL","NIP","NIT","NO","NOB","NOD","NON","NOR","NOT","NOV","NOW","NU","NUN","NUT","O","OAF","OAK","OAR","OAT","ODD","ODE","OF","OFF","OFT","OH","OIL","OK","OLD","ON","ONE","OR","ORB","ORE","ORR","OS","OTT","OUR","OUT","OVA","OW","OWE","OWL","OWN","OX","PA","PAD","PAL","PAM","PAN","PAP","PAR","PAT","PAW","PAY","PEA","PEG","PEN","PEP","PER","PET","PEW","PHI","PI","PIE","PIN","PIT","PLY","PO","POD","POE","POP","POT","POW","PRO","PRY","PUB","PUG","PUN","PUP","PUT","QUO","RAG","RAM","RAN","RAP","RAT","RAW","RAY","REB","RED","REP","RET","RIB","RID","RIG","RIM","RIO","RIP","ROB","ROD","ROE","RON","ROT","ROW","ROY","RUB","RUE","RUG","RUM","RUN","RYE","SAC","SAD","SAG","SAL","SAM","SAN","SAP","SAT","SAW","SAY","SEA","SEC","SEE","SEN","SET","SEW","SHE","SHY","SIN","SIP","SIR","SIS","SIT","SKI","SKY","SLY","SO","SOB","SOD","SON","SOP","SOW","SOY","SPA","SPY","SUB","SUD","SUE","SUM","SUN","SUP","TAB","TAD","TAG","TAN","TAP","TAR","TEA","TED","TEE","TEN","THE","THY","TIC","TIE","TIM","TIN","TIP","TO","TOE","TOG","TOM","TON","TOO","TOP","TOW","TOY","TRY","TUB","TUG","TUM","TUN","TWO","UN","UP","US","USE","VAN","VAT","VET","VIE","WAD","WAG","WAR","WAS","WAY","WE","WEB","WED","WEE","WET","WHO","WHY","WIN","WIT","WOK","WON","WOO","WOW","WRY","WU","YAM","YAP","YAW","YE","YEA","YES","YET","YOU","ABED","ABEL","ABET","ABLE","ABUT","ACHE","ACID","ACME","ACRE","ACTA","ACTS","ADAM","ADDS","ADEN","AFAR","AFRO","AGEE","AHEM","AHOY","AIDA","AIDE","AIDS","AIRY","AJAR","AKIN","ALAN","ALEC","ALGA","ALIA","ALLY","ALMA","ALOE","ALSO","ALTO","ALUM","ALVA","AMEN","AMES","AMID","AMMO","AMOK","AMOS","AMRA","ANDY","ANEW","ANNA","ANNE","ANTE","ANTI","AQUA","ARAB","ARCH","AREA","ARGO","ARID","ARMY","ARTS","ARTY","ASIA","ASKS","ATOM","AUNT","AURA","AUTO","AVER","AVID","AVIS","AVON","AVOW","AWAY","AWRY","BABE","BABY","BACH","BACK","BADE","BAIL","BAIT","BAKE","BALD","BALE","BALI","BALK","BALL","BALM","BAND","BANE","BANG","BANK","BARB","BARD","BARE","BARK","BARN","BARR","BASE","BASH","BASK","BASS","BATE","BATH","BAWD","BAWL","BEAD","BEAK","BEAM","BEAN","BEAR","BEAT","BEAU","BECK","BEEF","BEEN","BEER","BEET","BELA","BELL","BELT","BEND","BENT","BERG","BERN","BERT","BESS","BEST","BETA","BETH","BHOY","BIAS","BIDE","BIEN","BILE","BILK","BILL","BIND","BING","BIRD","BITE","BITS","BLAB","BLAT","BLED","BLEW","BLOB","BLOC","BLOT","BLOW","BLUE","BLUM","BLUR","BOAR","BOAT","BOCA","BOCK","BODE","BODY","BOGY","BOHR","BOIL","BOLD","BOLO","BOLT","BOMB","BONA","BOND","BONE","BONG","BONN","BONY","BOOK","BOOM","BOON","BOOT","BORE","BORG","BORN","BOSE","BOSS","BOTH","BOUT","BOWL","BOYD","BRAD","BRAE","BRAG","BRAN","BRAY","BRED","BREW","BRIG","BRIM","BROW","BUCK","BUDD","BUFF","BULB","BULK","BULL","BUNK","BUNT","BUOY","BURG","BURL","BURN","BURR","BURT","BURY","BUSH","BUSS","BUST","BUSY","BYTE","CADY","CAFE","CAGE","CAIN","CAKE","CALF","CALL","CALM","CAME","CANE","CANT","CARD","CARE","CARL","CARR","CART","CASE","CASH","CASK","CAST","CAVE","CEIL","CELL","CENT","CERN","CHAD","CHAR","CHAT","CHAW","CHEF","CHEN","CHEW","CHIC","CHIN","CHOU","CHOW","CHUB","CHUG","CHUM","CITE","CITY","CLAD","CLAM","CLAN","CLAW","CLAY","CLOD","CLOG","CLOT","CLUB","CLUE","COAL","COAT","COCA","COCK","COCO","CODA","CODE","CODY","COED","COIL","COIN","COKE","COLA","COLD","COLT","COMA","COMB","COME","COOK","COOL","COON","COOT","CORD","CORE","CORK","CORN","COST","COVE","COWL","CRAB","CRAG","CRAM","CRAY","CREW","CRIB","CROW","CRUD","CUBA","CUBE","CUFF","CULL","CULT","CUNY","CURB","CURD","CURE","CURL","CURT","CUTS","DADE","DALE","DAME","DANA","DANE","DANG","DANK","DARE","DARK","DARN","DART","DASH","DATA","DATE","DAVE","DAVY","DAWN","DAYS","DEAD","DEAF","DEAL","DEAN","DEAR","DEBT","DECK","DEED","DEEM","DEER","DEFT","DEFY","DELL","DENT","DENY","DESK","DIAL","DICE","DIED","DIET","DIME","DINE","DING","DINT","DIRE","DIRT","DISC","DISH","DISK","DIVE","DOCK","DOES","DOLE","DOLL","DOLT","DOME","DONE","DOOM","DOOR","DORA","DOSE","DOTE","DOUG","DOUR","DOVE","DOWN","DRAB","DRAG","DRAM","DRAW","DREW","DRUB","DRUG","DRUM","DUAL","DUCK","DUCT","DUEL","DUET","DUKE","DULL","DUMB","DUNE","DUNK","DUSK","DUST","DUTY","EACH","EARL","EARN","EASE","EAST","EASY","EBEN","ECHO","EDDY","EDEN","EDGE","EDGY","EDIT","EDNA","EGAN","ELAN","ELBA","ELLA","ELSE","EMIL","EMIT","EMMA","ENDS","ERIC","EROS","EVEN","EVER","EVIL","EYED","FACE","FACT","FADE","FAIL","FAIN","FAIR","FAKE","FALL","FAME","FANG","FARM","FAST","FATE","FAWN","FEAR","FEAT","FEED","FEEL","FEET","FELL","FELT","FEND","FERN","FEST","FEUD","FIEF","FIGS","FILE","FILL","FILM","FIND","FINE","FINK","FIRE","FIRM","FISH","FISK","FIST","FITS","FIVE","FLAG","FLAK","FLAM","FLAT","FLAW","FLEA","FLED","FLEW","FLIT","FLOC","FLOG","FLOW","FLUB","FLUE","FOAL","FOAM","FOGY","FOIL","FOLD","FOLK","FOND","FONT","FOOD","FOOL","FOOT","FORD","FORE","FORK","FORM","FORT","FOSS","FOUL","FOUR","FOWL","FRAU","FRAY","FRED","FREE","FRET","FREY","FROG","FROM","FUEL","FULL","FUME","FUND","FUNK","FURY","FUSE","FUSS","GAFF","GAGE","GAIL","GAIN","GAIT","GALA","GALE","GALL","GALT","GAME","GANG","GARB","GARY","GASH","GATE","GAUL","GAUR","GAVE","GAWK","GEAR","GELD","GENE","GENT","GERM","GETS","GIBE","GIFT","GILD","GILL","GILT","GINA","GIRD","GIRL","GIST","GIVE","GLAD","GLEE","GLEN","GLIB","GLOB","GLOM","GLOW","GLUE","GLUM","GLUT","GOAD","GOAL","GOAT","GOER","GOES","GOLD","GOLF","GONE","GONG","GOOD","GOOF","GORE","GORY","GOSH","GOUT","GOWN","GRAB","GRAD","GRAY","GREG","GREW","GREY","GRID","GRIM","GRIN","GRIT","GROW","GRUB","GULF","GULL","GUNK","GURU","GUSH","GUST","GWEN","GWYN","HAAG","HAAS","HACK","HAIL","HAIR","HALE","HALF","HALL","HALO","HALT","HAND","HANG","HANK","HANS","HARD","HARK","HARM","HART","HASH","HAST","HATE","HATH","HAUL","HAVE","HAWK","HAYS","HEAD","HEAL","HEAR","HEAT","HEBE","HECK","HEED","HEEL","HEFT","HELD","HELL","HELM","HERB","HERD","HERE","HERO","HERS","HESS","HEWN","HICK","HIDE","HIGH","HIKE","HILL","HILT","HIND","HINT","HIRE","HISS","HIVE","HOBO","HOCK","HOFF","HOLD","HOLE","HOLM","HOLT","HOME","HONE","HONK","HOOD","HOOF","HOOK","HOOT","HORN","HOSE","HOST","HOUR","HOVE","HOWE","HOWL","HOYT","HUCK","HUED","HUFF","HUGE","HUGH","HUGO","HULK","HULL","HUNK","HUNT","HURD","HURL","HURT","HUSH","HYDE","HYMN","IBIS","ICON","IDEA","IDLE","IFFY","INCA","INCH","INTO","IONS","IOTA","IOWA","IRIS","IRMA","IRON","ISLE","ITCH","ITEM","IVAN","JACK","JADE","JAIL","JAKE","JANE","JAVA","JEAN","JEFF","JERK","JESS","JEST","JIBE","JILL","JILT","JIVE","JOAN","JOBS","JOCK","JOEL","JOEY","JOHN","JOIN","JOKE","JOLT","JOVE","JUDD","JUDE","JUDO","JUDY","JUJU","JUKE","JULY","JUNE","JUNK","JUNO","JURY","JUST","JUTE","KAHN","KALE","KANE","KANT","KARL","KATE","KEEL","KEEN","KENO","KENT","KERN","KERR","KEYS","KICK","KILL","KIND","KING","KIRK","KISS","KITE","KLAN","KNEE","KNEW","KNIT","KNOB","KNOT","KNOW","KOCH","KONG","KUDO","KURD","KURT","KYLE","LACE","LACK","LACY","LADY","LAID","LAIN","LAIR","LAKE","LAMB","LAME","LAND","LANE","LANG","LARD","LARK","LASS","LAST","LATE","LAUD","LAVA","LAWN","LAWS","LAYS","LEAD","LEAF","LEAK","LEAN","LEAR","LEEK","LEER","LEFT","LEND","LENS","LENT","LEON","LESK","LESS","LEST","LETS","LIAR","LICE","LICK","LIED","LIEN","LIES","LIEU","LIFE","LIFT","LIKE","LILA","LILT","LILY","LIMA","LIMB","LIME","LIND","LINE","LINK","LINT","LION","LISA","LIST","LIVE","LOAD","LOAF","LOAM","LOAN","LOCK","LOFT","LOGE","LOIS","LOLA","LONE","LONG","LOOK","LOON","LOOT","LORD","LORE","LOSE","LOSS","LOST","LOUD","LOVE","LOWE","LUCK","LUCY","LUGE","LUKE","LULU","LUND","LUNG","LURA","LURE","LURK","LUSH","LUST","LYLE","LYNN","LYON","LYRA","MACE","MADE","MAGI","MAID","MAIL","MAIN","MAKE","MALE","MALI","MALL","MALT","MANA","MANN","MANY","MARC","MARE","MARK","MARS","MART","MARY","MASH","MASK","MASS","MAST","MATE","MATH","MAUL","MAYO","MEAD","MEAL","MEAN","MEAT","MEEK","MEET","MELD","MELT","MEMO","MEND","MENU","MERT","MESH","MESS","MICE","MIKE","MILD","MILE","MILK","MILL","MILT","MIMI","MIND","MINE","MINI","MINK","MINT","MIRE","MISS","MIST","MITE","MITT","MOAN","MOAT","MOCK","MODE","MOLD","MOLE","MOLL","MOLT","MONA","MONK","MONT","MOOD","MOON","MOOR","MOOT","MORE","MORN","MORT","MOSS","MOST","MOTH","MOVE","MUCH","MUCK","MUDD","MUFF","MULE","MULL","MURK","MUSH","MUST","MUTE","MUTT","MYRA","MYTH","NAGY","NAIL","NAIR","NAME","NARY","NASH","NAVE","NAVY","NEAL","NEAR","NEAT","NECK","NEED","NEIL","NELL","NEON","NERO","NESS","NEST","NEWS","NEWT","NIBS","NICE","NICK","NILE","NINA","NINE","NOAH","NODE","NOEL","NOLL","NONE","NOOK","NOON","NORM","NOSE","NOTE","NOUN","NOVA","NUDE","NULL","NUMB","OATH","OBEY","OBOE","ODIN","OHIO","OILY","OINT","OKAY","OLAF","OLDY","OLGA","OLIN","OMAN","OMEN","OMIT","ONCE","ONES","ONLY","ONTO","ONUS","ORAL","ORGY","OSLO","OTIS","OTTO","OUCH","OUST","OUTS","OVAL","OVEN","OVER","OWLY","OWNS","QUAD","QUIT","QUOD","RACE","RACK","RACY","RAFT","RAGE","RAID","RAIL","RAIN","RAKE","RANK","RANT","RARE","RASH","RATE","RAVE","RAYS","READ","REAL","REAM","REAR","RECK","REED","REEF","REEK","REEL","REID","REIN","RENA","REND","RENT","REST","RICE","RICH","RICK","RIDE","RIFT","RILL","RIME","RING","RINK","RISE","RISK","RITE","ROAD","ROAM","ROAR","ROBE","ROCK","RODE","ROIL","ROLL","ROME","ROOD","ROOF","ROOK","ROOM","ROOT","ROSA","ROSE","ROSS","ROSY","ROTH","ROUT","ROVE","ROWE","ROWS","RUBE","RUBY","RUDE","RUDY","RUIN","RULE","RUNG","RUNS","RUNT","RUSE","RUSH","RUSK","RUSS","RUST","RUTH","SACK","SAFE","SAGE","SAID","SAIL","SALE","SALK","SALT","SAME","SAND","SANE","SANG","SANK","SARA","SAUL","SAVE","SAYS","SCAN","SCAR","SCAT","SCOT","SEAL","SEAM","SEAR","SEAT","SEED","SEEK","SEEM","SEEN","SEES","SELF","SELL","SEND","SENT","SETS","SEWN","SHAG","SHAM","SHAW","SHAY","SHED","SHIM","SHIN","SHOD","SHOE","SHOT","SHOW","SHUN","SHUT","SICK","SIDE","SIFT","SIGH","SIGN","SILK","SILL","SILO","SILT","SINE","SING","SINK","SIRE","SITE","SITS","SITU","SKAT","SKEW","SKID","SKIM","SKIN","SKIT","SLAB","SLAM","SLAT","SLAY","SLED","SLEW","SLID","SLIM","SLIT","SLOB","SLOG","SLOT","SLOW","SLUG","SLUM","SLUR","SMOG","SMUG","SNAG","SNOB","SNOW","SNUB","SNUG","SOAK","SOAR","SOCK","SODA","SOFA","SOFT","SOIL","SOLD","SOME","SONG","SOON","SOOT","SORE","SORT","SOUL","SOUR","SOWN","STAB","STAG","STAN","STAR","STAY","STEM","STEW","STIR","STOW","STUB","STUN","SUCH","SUDS","SUIT","SULK","SUMS","SUNG","SUNK","SURE","SURF","SWAB","SWAG","SWAM","SWAN","SWAT","SWAY","SWIM","SWUM","TACK","TACT","TAIL","TAKE","TALE","TALK","TALL","TANK","TASK","TATE","TAUT","TEAL","TEAM","TEAR","TECH","TEEM","TEEN","TEET","TELL","TEND","TENT","TERM","TERN","TESS","TEST","THAN","THAT","THEE","THEM","THEN","THEY","THIN","THIS","THUD","THUG","TICK","TIDE","TIDY","TIED","TIER","TILE","TILL","TILT","TIME","TINA","TINE","TINT","TINY","TIRE","TOAD","TOGO","TOIL","TOLD","TOLL","TONE","TONG","TONY","TOOK","TOOL","TOOT","TORE","TORN","TOTE","TOUR","TOUT","TOWN","TRAG","TRAM","TRAY","TREE","TREK","TRIG","TRIM","TRIO","TROD","TROT","TROY","TRUE","TUBA","TUBE","TUCK","TUFT","TUNA","TUNE","TUNG","TURF","TURN","TUSK","TWIG","TWIN","TWIT","ULAN","UNIT","URGE","USED","USER","USES","UTAH","VAIL","VAIN","VALE","VARY","VASE","VAST","VEAL","VEDA","VEIL","VEIN","VEND","VENT","VERB","VERY","VETO","VICE","VIEW","VINE","VISE","VOID","VOLT","VOTE","WACK","WADE","WAGE","WAIL","WAIT","WAKE","WALE","WALK","WALL","WALT","WAND","WANE","WANG","WANT","WARD","WARM","WARN","WART","WASH","WAST","WATS","WATT","WAVE","WAVY","WAYS","WEAK","WEAL","WEAN","WEAR","WEED","WEEK","WEIR","WELD","WELL","WELT","WENT","WERE","WERT","WEST","WHAM","WHAT","WHEE","WHEN","WHET","WHOA","WHOM","WICK","WIFE","WILD","WILL","WIND","WINE","WING","WINK","WINO","WIRE","WISE","WISH","WITH","WOLF","WONT","WOOD","WOOL","WORD","WORE","WORK","WORM","WORN","WOVE","WRIT","WYNN","YALE","YANG","YANK","YARD","YARN","YAWL","YAWN","YEAH","YEAR","YELL","YOGA","YOKE"]');

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __nccwpck_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	var threw = true;
/******/ 	try {
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 		threw = false;
/******/ 	} finally {
/******/ 		if(threw) delete __webpack_module_cache__[moduleId];
/******/ 	}
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nccwpck_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nccwpck_require__.o(definition, key) && !__nccwpck_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nccwpck_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/compat */
/******/ 
/******/ if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/) ? 1 : 0, -1) + "/";
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXPORTS
__nccwpck_require__.d(__webpack_exports__, {
  "W": () => (/* binding */ handleOperation),
  "d": () => (/* binding */ runContract)
});

// EXTERNAL MODULE: external "node:crypto"
var external_node_crypto_ = __nccwpck_require__(6005);
;// CONCATENATED MODULE: external "node:fs"
const external_node_fs_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:fs");
;// CONCATENATED MODULE: ./src/contract/errors.js
class ContractError extends Error {
  constructor(message, code = "CONTRACT_ERROR") {
    super(message);
    this.name = "ContractError";
    this.code = code;
  }
}

function fail(message, code) {
  throw new ContractError(message, code);
}

function toErrorResponse(error) {
  if (error instanceof ContractError) {
    return { ok: false, error: error.message, code: error.code };
  }
  return { ok: false, error: "Unexpected contract error.", code: "UNEXPECTED_ERROR" };
}


;// CONCATENATED MODULE: ./src/contract/state.js



class VaultState {
  constructor(initial = {}) {
    this.vaults = initial.vaults ?? {};
  }

  createVault({
    owner,
    salt,
    metadata = {},
    createdAt,
    manifestTokenId,
    type = "individual",
    authorized = [],
    pendingInvites = []
  }) {
    const vaultId = buildVaultId(owner, salt);
    if (this.vaults[vaultId]) fail("Vault already exists.", "VAULT_ALREADY_EXISTS");

    const dedupAuthorized = [...new Set([owner, ...authorized])];
    this.vaults[vaultId] = {
      id: vaultId,
      type,
      owner,
      createdAt,
      salt,
      metadata,
      manifestTokenId,
      // FUTURE: TEAM MODE - permission list for delegated vault access.
      // client and on-ledger policy controls should evolve this field.
      authorized: dedupAuthorized,
      pendingInvites,
      entries: []
    };
    return this.vaults[vaultId];
  }

  addEntry({ vaultId, actor, owner, cid, entryMetadata, createdAt, tokenId, wrappedKeys = [] }) {
    const vault = this.requireVault(vaultId);
    const principal = actor ?? owner;
    this.assertWriteAccess(vault, principal);
    const entry = {
      tokenId,
      cid,
      metadata: {
        service: entryMetadata.service,
        username: entryMetadata.username ?? null,
        notes: entryMetadata.notes ?? null
      },
      // FUTURE: TEAM MODE - client computes hybrid wrapping and sends ciphertext only.
      wrappedKeys,
      createdAt
    };
    vault.entries.push(entry);
    return entry;
  }

  getEntry({ vaultId, actor, owner, entryIndex, tokenId }) {
    const vault = this.requireVault(vaultId);
    const principal = actor ?? owner;
    this.assertReadAccess(vault, principal);

    let entry = null;
    if (typeof entryIndex === "number") {
      entry = vault.entries[entryIndex] ?? null;
    } else if (tokenId) {
      entry = vault.entries.find((item) => item.tokenId === tokenId) ?? null;
    }

    if (!entry) fail("Entry not found.", "ENTRY_NOT_FOUND");
    return entry;
  }

  getMyVaults(owner, since = null) {
    return Object.values(this.vaults)
      .filter((vault) => vault.owner === owner)
      .filter((vault) => (since === null ? true : compareCreatedAt(vault.createdAt, since) > 0))
      .map((vault) => ({
        vaultId: vault.id,
        type: vault.type,
        createdAt: vault.createdAt,
        entryCount: vault.entries.length,
        authorizedCount: vault.type === "team" ? vault.authorized.length : 1,
        pendingInviteCount: vault.type === "team" ? vault.pendingInvites.length : 0,
        manifestTokenId: vault.manifestTokenId,
        lastActivity: vault.entries.length ? vault.entries[vault.entries.length - 1].createdAt : null
      }))
      .sort((a, b) => compareCreatedAt(b.createdAt, a.createdAt));
  }

  requireVault(vaultId) {
    const vault = this.vaults[vaultId];
    if (!vault) fail("Vault not found.", "VAULT_NOT_FOUND");
    return vault;
  }

  getVaultMetadata({ vaultId, owner }) {
    const vault = this.requireVault(vaultId);
    if (vault.owner !== owner) fail("Only vault owner can read metadata.", "UNAUTHORIZED");
    return vault.metadata ?? {};
  }

  setPasswordBackup({ vaultId, owner, passwordBackup, updatedAt }) {
    const vault = this.requireVault(vaultId);
    if (vault.owner !== owner) fail("Only vault owner can update metadata.", "UNAUTHORIZED");
    vault.metadata = { ...(vault.metadata ?? {}), passwordBackup };
    if (!vault.metadata.vaultId) vault.metadata.vaultId = vault.id;
    if (updatedAt !== undefined) vault.metadata.lastUpdated = updatedAt;
    return vault.metadata;
  }

  clearPasswordBackup({ vaultId, owner, updatedAt }) {
    const vault = this.requireVault(vaultId);
    if (vault.owner !== owner) fail("Only vault owner can update metadata.", "UNAUTHORIZED");
    if (!vault.metadata) vault.metadata = {};
    delete vault.metadata.passwordBackup;
    if (!vault.metadata.vaultId) vault.metadata.vaultId = vault.id;
    if (updatedAt !== undefined) vault.metadata.lastUpdated = updatedAt;
    return vault.metadata;
  }

  snapshot() {
    return JSON.parse(JSON.stringify({ vaults: this.vaults }));
  }

  digest() {
    const stable = stableStringify(this.snapshot());
    return external_node_crypto_.createHash("sha256").update(stable).digest("hex");
  }

  addPendingInvite({ vaultId, invitedBy, address, invitedAt }) {
    const vault = this.requireVault(vaultId);
    if (vault.type !== "team") fail("Invites are supported only for team vaults.", "INVALID_VAULT_TYPE");
    if (vault.owner !== invitedBy) fail("Only vault owner can invite users.", "UNAUTHORIZED");

    const alreadyAuthorized = vault.authorized.includes(address);
    if (alreadyAuthorized) fail("Address is already authorized.", "INVITE_ALREADY_ACCEPTED");

    const existing = vault.pendingInvites.find((invite) => invite.address === address);
    if (existing) fail("Pending invite already exists for this address.", "INVITE_ALREADY_EXISTS");

    vault.pendingInvites.push({
      address,
      invitedBy,
      invitedAt
    });
    return vault.pendingInvites[vault.pendingInvites.length - 1];
  }

  acceptPendingInvite({ vaultId, address }) {
    const vault = this.requireVault(vaultId);
    if (vault.type !== "team") fail("Invites are supported only for team vaults.", "INVALID_VAULT_TYPE");

    const inviteIndex = vault.pendingInvites.findIndex((invite) => invite.address === address);
    if (inviteIndex < 0) fail("Pending invite not found.", "INVITE_NOT_FOUND");

    const invite = vault.pendingInvites[inviteIndex];
    vault.pendingInvites.splice(inviteIndex, 1);
    if (!vault.authorized.includes(address)) {
      vault.authorized.push(address);
    }
    return invite;
  }

  revokePendingInvite({ vaultId, owner, pendingAddress }) {
    const vault = this.requireVault(vaultId);
    if (vault.type !== "team") fail("Invites are supported only for team vaults.", "INVALID_VAULT_TYPE");
    if (vault.owner !== owner) fail("Only vault owner can revoke invites.", "UNAUTHORIZED");

    const inviteIndex = vault.pendingInvites.findIndex((invite) => invite.address === pendingAddress);
    if (inviteIndex < 0) fail("Pending invite not found.", "INVITE_NOT_FOUND");
    const invite = vault.pendingInvites[inviteIndex];
    vault.pendingInvites.splice(inviteIndex, 1);
    return invite;
  }

  removeAuthorizedMember({ vaultId, owner, memberToRemove }) {
    const vault = this.requireVault(vaultId);
    if (vault.type !== "team") fail("Member removal is supported only for team vaults.", "INVALID_VAULT_TYPE");
    if (vault.owner !== owner) fail("Only vault owner can remove members.", "UNAUTHORIZED");
    if (memberToRemove === owner) fail("Owner cannot remove themselves.", "INVALID_OPERATION");

    const idx = vault.authorized.indexOf(memberToRemove);
    if (idx < 0) fail("Member not found in authorized list.", "MEMBER_NOT_FOUND");
    vault.authorized.splice(idx, 1);
    return vault;
  }

  listVaultURITokens({ vaultId, owner }) {
    const vault = this.requireVault(vaultId);
    if (vault.owner !== owner) fail("Only vault owner can list vault URI tokens.", "UNAUTHORIZED");
    const tokens = [];
    if (vault.manifestTokenId) tokens.push(vault.manifestTokenId);
    for (const entry of vault.entries) {
      if (entry.tokenId) tokens.push(entry.tokenId);
    }
    return tokens;
  }

  deleteVault({ vaultId, owner }) {
    const vault = this.requireVault(vaultId);
    if (vault.owner !== owner) fail("Only vault owner can revoke vault.", "UNAUTHORIZED");
    delete this.vaults[vaultId];
  }

  assertReadAccess(vault, actor) {
    if (vault.type === "team") {
      if (!vault.authorized.includes(actor)) fail("Caller is not authorized.", "UNAUTHORIZED");
      return;
    }
    if (vault.owner !== actor) fail("Only vault owner can read entries.", "UNAUTHORIZED");
  }

  assertWriteAccess(vault, actor) {
    if (vault.type === "team") {
      if (!vault.authorized.includes(actor)) fail("Caller is not authorized.", "UNAUTHORIZED");
      return;
    }
    if (vault.owner !== actor) fail("Only vault owner can add entries.", "UNAUTHORIZED");
  }
}

function buildVaultId(owner, salt) {
  return external_node_crypto_.createHash("sha256").update(`${owner}:${salt}`).digest("hex");
}

function stableStringify(value) {
  if (Array.isArray(value)) {
    return `[${value.map(stableStringify).join(",")}]`;
  }
  if (value && typeof value === "object") {
    const keys = Object.keys(value).sort();
    return `{${keys.map((k) => `${JSON.stringify(k)}:${stableStringify(value[k])}`).join(",")}}`;
  }
  return JSON.stringify(value);
}

function compareCreatedAt(left, right) {
  const leftNum = Number(left);
  const rightNum = Number(right);
  if (Number.isFinite(leftNum) && Number.isFinite(rightNum)) {
    return leftNum - rightNum;
  }
  return String(left).localeCompare(String(right));
}


;// CONCATENATED MODULE: external "node:path"
const external_node_path_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:path");
;// CONCATENATED MODULE: ./src/contract/stateStore.js



const DEFAULT_STATE_FILE = "./state/xvault-state.json";

function loadStateFromFs(stateFile = DEFAULT_STATE_FILE) {
  if (!external_node_fs_namespaceObject.existsSync(stateFile)) {
    return { vaults: {} };
  }
  const raw = external_node_fs_namespaceObject.readFileSync(stateFile, "utf8");
  const parsed = JSON.parse(raw);
  return parsed && typeof parsed === "object" ? parsed : { vaults: {} };
}

function saveStateToFs(stateFile = DEFAULT_STATE_FILE, snapshot) {
  const dir = external_node_path_namespaceObject.dirname(stateFile);
  external_node_fs_namespaceObject.mkdirSync(dir, { recursive: true });
  external_node_fs_namespaceObject.writeFileSync(stateFile, `${JSON.stringify(snapshot, null, 2)}\n`, "utf8");
}


;// CONCATENATED MODULE: ./src/contract/cidUtils.js


const CIDV0_REGEX = /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/;
const CIDV1_BASE32_REGEX = /^b[a-z2-7]{20,}$/;
const CIDV1_BASE36_REGEX = /^k[0-9a-z]{20,}$/;

function isLikelyIpfsCid(cid) {
  if (typeof cid !== "string") return false;
  const trimmed = cid.trim();
  if (trimmed.length < 10 || trimmed.length > 120) return false;
  return CIDV0_REGEX.test(trimmed) || CIDV1_BASE32_REGEX.test(trimmed) || CIDV1_BASE36_REGEX.test(trimmed);
}

function assertValidCid(cid) {
  if (!isLikelyIpfsCid(cid)) {
    fail("Invalid IPFS CID format.", "INVALID_CID");
  }
}

function buildGatewayFetchUrl(gatewayBaseUrl, cid) {
  return `${gatewayBaseUrl}/ipfs/${cid}`;
}


;// CONCATENATED MODULE: ./src/contract/config.js
const DEFAULT_GATEWAY = "https://grandfather-as-effect.quicknode-ipfs.com/ipfs";

function getGatewayBaseUrl() {
  const raw = process.env.QUICKNODE_GATEWAY || process.env.QUICKNODE_IPFS_GATEWAY || DEFAULT_GATEWAY;
  return raw.endsWith("/") ? raw.slice(0, -1) : raw;
}

function getQuickNodeApiKeyHint() {
  return process.env.QUICKNODE_IPFS_API_KEY ? "configured" : "not-configured";
}

function isTeamModeEnabled() {
  return process.env.ENABLE_TEAM_MODE === "true";
}

function isMutableUriTokensEnabled() {
  return process.env.ENABLE_MUTABLE_URITOKENS === "true";
}


// EXTERNAL MODULE: ./node_modules/xahau/dist/npm/index.js
var npm = __nccwpck_require__(2365);
;// CONCATENATED MODULE: ./src/contract/xrplUtils.js




const URITOKEN_BURNABLE_FLAG = 0x00000001;
const DEFAULT_URI_ISSUER = "rMsiGfHZDxtj9Y4SSn6Fp5f8n3pHZ3GXXQ";

function validateClassicAddress(address) {
  if (typeof address !== "string" || address.length < 25 || address.length > 40) {
    fail("Invalid Xahau classic address.", "INVALID_ADDRESS");
  }
  if (!(0,npm.isValidClassicAddress)(address)) {
    fail("Invalid Xahau classic address.", "INVALID_ADDRESS");
  }
}

function validateHexSalt(salt) {
  if (
    typeof salt !== "string" ||
    salt.length < 16 ||
    salt.length > 256 ||
    !/^[0-9a-fA-F]+$/.test(salt) ||
    salt.length % 2 !== 0
  ) {
    fail("Salt must be an even-length hex string between 16 and 256 chars.", "INVALID_SALT");
  }
}

function assertBase64(input, fieldName) {
  if (typeof input !== "string" || input.length === 0 || input.length > 1024 * 1024) {
    fail(`${fieldName} must be a non-empty base64 string within size limit.`, "INVALID_INPUT");
  }
  const roundTrip = Buffer.from(input, "base64").toString("base64");
  if (roundTrip.replace(/=+$/, "") !== input.replace(/=+$/, "")) {
    fail(`${fieldName} is not valid base64.`, "INVALID_INPUT");
  }
}

function canonicalizeSignedPayload(payload) {
  return xrplUtils_stableStringify(payload);
}

function hashForSigning(payload) {
  return external_node_crypto_.createHash("sha256").update(canonicalizeSignedPayload(payload)).digest("hex");
}

function verifySignedPayload({
  payload,
  signature,
  signerPublicKey,
  expectedAddress
}) {
  if (!signature || !signerPublicKey) {
    fail("Missing signerPublicKey or signature.", "INVALID_SIGNATURE");
  }
  if (typeof signature !== "string" || signature.length < 16 || !/^[0-9A-Fa-f]+$/.test(signature)) {
    fail("Malformed signature format.", "INVALID_SIGNATURE");
  }
  if (
    typeof signerPublicKey !== "string" ||
    signerPublicKey.length < 16 ||
    signerPublicKey.length > 80 ||
    !/^[A-Za-z0-9]+$/.test(signerPublicKey)
  ) {
    fail("Malformed signerPublicKey format.", "INVALID_SIGNATURE");
  }
  const derived = (0,npm.deriveAddress)(signerPublicKey);
  if (derived !== expectedAddress) {
    fail("Signer public key does not match expected Xahau address.", "INVALID_SIGNATURE");
  }
  const signingHash = hashForSigning(payload);
  const ok = (0,npm.verifyKeypairSignature)(signingHash, signature, signerPublicKey);
  if (!ok) fail("Invalid Xahau signature.", "INVALID_SIGNATURE");
}

function deriveSignerAddress(signerPublicKey) {
  if (
    typeof signerPublicKey !== "string" ||
    signerPublicKey.length < 16 ||
    signerPublicKey.length > 80 ||
    !/^[A-Za-z0-9]+$/.test(signerPublicKey)
  ) {
    fail("Malformed signerPublicKey format.", "INVALID_SIGNATURE");
  }
  return (0,npm.deriveAddress)(signerPublicKey);
}

function buildUriTokenMintTx({
  account = DEFAULT_URI_ISSUER,
  uri,
  owner = undefined,
  flags = URITOKEN_BURNABLE_FLAG
}) {
  if (!uri) fail("URI is required for URITokenMint.", "INVALID_INPUT");
  const tx = {
    TransactionType: "URITokenMint",
    Account: account,
    URI: (0,npm.convertStringToHex)(uri),
    Flags: flags
  };
  if (owner) tx.Destination = owner;
  return tx;
}

function buildUriTokenBurnTx({ account = DEFAULT_URI_ISSUER, uriTokenId }) {
  if (!uriTokenId) fail("uriTokenId is required for URITokenBurn.", "INVALID_INPUT");
  return {
    TransactionType: "URITokenBurn",
    Account: account,
    URITokenID: uriTokenId
  };
}

async function mintUriToken({
  xrplClient,
  uri,
  owner,
  issuer = DEFAULT_URI_ISSUER,
  multisigSigners = [],
  devMode = false
}) {
  const tx = buildUriTokenMintTx({ account: issuer, uri, owner });

  if (!xrplClient || multisigSigners.length === 0) {
    const simulatedTokenId = external_node_crypto_.createHash("sha256")
      .update(`${issuer}:${owner ?? ""}:${uri}`)
      .digest("hex")
      .slice(0, 64);
    return {
      tokenId: simulatedTokenId,
      mode: "simulated",
      tx
    };
  }

  try {
    const prepared = await xrplClient.autofill(tx);
    const signedParts = multisigSigners.map((wallet) => wallet.sign(prepared, true).tx_blob);
    const multiSignedBlob = (0,npm.multisign)(signedParts);
    const submitResult = await xrplClient.submitAndWait(multiSignedBlob);

    return {
      tokenId: submitResult?.result?.meta?.uritoken_id ?? null,
      mode: "submitted",
      txHash: submitResult?.result?.hash ?? null,
      tx: prepared
    };
  } catch (error) {
    if (devMode) {
      const simulatedTokenId = external_node_crypto_.createHash("sha256")
        .update(`${issuer}:${owner ?? ""}:${uri}:fallback`)
        .digest("hex")
        .slice(0, 64);
      return {
        tokenId: simulatedTokenId,
        mode: "simulated_fallback",
        tx
      };
    }
    fail(`XRPL submission failed: ${error.message}`, "XRPL_SUBMISSION_FAILED");
  }
}

async function burnUriToken({
  xrplClient,
  uriTokenId,
  issuer = DEFAULT_URI_ISSUER,
  multisigSigners = [],
  devMode = false
}) {
  const tx = buildUriTokenBurnTx({ account: issuer, uriTokenId });

  if (!xrplClient || multisigSigners.length === 0) {
    return {
      burned: true,
      mode: "simulated",
      tx
    };
  }

  try {
    const prepared = await xrplClient.autofill(tx);
    const signedParts = multisigSigners.map((wallet) => wallet.sign(prepared, true).tx_blob);
    const multiSignedBlob = (0,npm.multisign)(signedParts);
    const submitResult = await xrplClient.submitAndWait(multiSignedBlob);
    return {
      burned: true,
      mode: "submitted",
      txHash: submitResult?.result?.hash ?? null,
      tx: prepared
    };
  } catch (error) {
    if (devMode) {
      return {
        burned: true,
        mode: "simulated_fallback",
        tx
      };
    }
    fail(`XRPL burn failed: ${error.message}`, "XRPL_SUBMISSION_FAILED");
  }
}

function xrplUtils_stableStringify(value) {
  if (Array.isArray(value)) {
    return `[${value.map(xrplUtils_stableStringify).join(",")}]`;
  }
  if (value && typeof value === "object") {
    const keys = Object.keys(value).sort();
    return `{${keys.map((k) => `${JSON.stringify(k)}:${xrplUtils_stableStringify(value[k])}`).join(",")}}`;
  }
  return JSON.stringify(value);
}


;// CONCATENATED MODULE: ./src/contract/index.js
// SPDX-License-Identifier: MIT









const OPS_PER_ROUND_LIMIT = 5;
const contract_DEFAULT_STATE_FILE = process.env.XVAULT_STATE_FILE ?? "./state/xvault-state.json";
const QUICKNODE_GATEWAY = getGatewayBaseUrl();
const ENABLE_XRPL_DEV_FALLBACK = process.env.XVAULT_DEV_XRPL_FALLBACK !== "false";
const ENABLE_TEAM_MODE = isTeamModeEnabled();
const ENABLE_MUTABLE_URITOKENS = isMutableUriTokensEnabled();

const state = new VaultState(loadStateFromFs(contract_DEFAULT_STATE_FILE));
let limiter = { roundKey: null, perAddress: new Map() };

async function handleOperation(op, deps = {}, runtimeContext = {}) {
  if (!op || typeof op !== "object") fail("Operation payload is required.", "INVALID_INPUT");
  const type = op.type;
  const payload = op.payload ?? {};
  const roundKey = resolveRoundKey(runtimeContext, op);

  switch (type) {
    case "createVault":
      return success(type, await createVaultHandler(payload, deps, roundKey));
    case "createTeamVault":
      return success(type, await createTeamVaultHandler(payload, deps, roundKey));
    case "inviteToVault":
      return success(type, await inviteToVaultHandler(payload, roundKey));
    case "acceptInvite":
      return success(type, await acceptInviteHandler(payload, roundKey));
    case "removeMember":
      return success(type, await removeMemberHandler(payload, roundKey));
    case "revokeInvite":
      return success(type, await revokeInviteHandler(payload, roundKey));
    case "updateVaultManifest":
      return success(type, await updateVaultManifestHandler(payload, deps, roundKey));
    case "listVaultURITokens":
      return success(type, await listVaultURITokensHandler(payload));
    case "revokeVault":
      return success(type, await revokeVaultHandler(payload, deps, roundKey));
    case "getPendingInvites":
      return success(type, await getPendingInvitesHandler(payload));
    case "addEntry":
      return success(type, await addEntryHandler(payload, deps, roundKey));
    case "getMyVaults":
      return success(type, getMyVaultsHandler(payload));
    case "getEntry":
      return success(type, getEntryHandler(payload));
    case "stateDigest":
      return success(type, { digest: state.digest() });
    case "addPasswordBackup":
      return success(type, await addPasswordBackupHandler(payload, roundKey));
    case "removePasswordBackup":
      return success(type, await removePasswordBackupHandler(payload, roundKey));
    case "getVaultMetadata":
      return success(type, getVaultMetadataHandler(payload));
    default:
      fail(`Unknown operation type: ${type}`, "UNKNOWN_OPERATION");
  }
}

async function createVaultHandler(payload, deps, roundKey) {
  const vaultType = payload.type ?? "individual";
  if (vaultType === "team") {
    return createTeamVaultHandler(payload, deps, roundKey);
  }
  if (vaultType !== "individual") {
    fail("Unsupported vault type.", "UNSUPPORTED_VAULT_TYPE");
  }
  const rawMetadata = payload.metadata ?? {};
  assertObject(rawMetadata, "metadata");
  validateClassicAddress(payload.owner);
  validateHexSalt(payload.salt);
  const vaultId = buildVaultId(payload.owner, payload.salt);
  if (rawMetadata.passwordBackup) {
    validatePasswordBackupEnvelope(rawMetadata.passwordBackup, vaultId);
  }
  verifySignedPayload({
    payload: {
      type: vaultType,
      owner: payload.owner,
      salt: payload.salt,
      metadata: rawMetadata
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: payload.owner
  });
  enforceRateLimit(payload.owner, roundKey);

  const metadata = normalizeVaultMetadata(rawMetadata, vaultId, roundKey);
  const manifestMint = await mintUriToken({
    xrplClient: deps.xrplClient,
    multisigSigners: deps.multisigSigners ?? [],
    issuer: deps.uriIssuer ?? DEFAULT_URI_ISSUER,
    uri: "ipfs://placeholder-for-now",
    devMode: ENABLE_XRPL_DEV_FALLBACK
  });
  // FUTURE: TEAM MODE - delegation could use URIToken ownership transfer
  // from creator to a managed vault authority account.

  const vault = state.createVault({
    owner: payload.owner,
    salt: payload.salt,
    metadata,
    createdAt: roundKey,
    manifestTokenId: manifestMint.tokenId
  });
  persistState();
  auditLog("createVault", { owner: payload.owner, vaultId: vault.id, success: true });

  return {
    vaultId: vault.id,
    owner: vault.owner,
    createdAt: vault.createdAt,
    manifestTokenId: vault.manifestTokenId,
    mintMode: manifestMint.mode
  };
}

async function createTeamVaultHandler(payload, deps, roundKey) {
  ensureTeamModeEnabled();
  const rawMetadata = payload.metadata ?? {};
  assertObject(rawMetadata, "metadata");
  validateClassicAddress(payload.owner);
  validateHexSalt(payload.salt);
  validateAddressArray(payload.initialAuthorized ?? [], "initialAuthorized");
  const vaultId = buildVaultId(payload.owner, payload.salt);
  if (rawMetadata.passwordBackup) {
    validatePasswordBackupEnvelope(rawMetadata.passwordBackup, vaultId);
  }
  verifySignedPayload({
    payload: {
      type: "team",
      owner: payload.owner,
      salt: payload.salt,
      metadata: rawMetadata,
      initialAuthorized: payload.initialAuthorized ?? []
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: payload.owner
  });
  enforceRateLimit(payload.owner, roundKey);

  const manifestMint = await mintUriToken({
    xrplClient: deps.xrplClient,
    multisigSigners: deps.multisigSigners ?? [],
    issuer: deps.uriIssuer ?? DEFAULT_URI_ISSUER,
    uri: "ipfs://placeholder-for-now",
    devMode: ENABLE_XRPL_DEV_FALLBACK
  });
  // FUTURE: TEAM MODE - mint team policy token or integrate Xahau Hooks.
  // FUTURE: on membership change -> client re-uploads policy blob and calls
  // updateManifestUri when mutable URI support is available.

  const metadata = normalizeVaultMetadata(rawMetadata, vaultId, roundKey);
  const vault = state.createVault({
    owner: payload.owner,
    salt: payload.salt,
    metadata,
    createdAt: roundKey,
    manifestTokenId: manifestMint.tokenId,
    type: "team",
    authorized: payload.initialAuthorized ?? [],
    pendingInvites: []
  });
  persistState();
  auditLog("createTeamVault", { owner: payload.owner, vaultId: vault.id, success: true });

  return {
    vaultId: vault.id,
    owner: vault.owner,
    type: vault.type,
    createdAt: vault.createdAt,
    manifestTokenId: vault.manifestTokenId,
    authorizedCount: vault.authorized.length,
    mintMode: manifestMint.mode
  };
}

async function inviteToVaultHandler(payload, roundKey) {
  ensureTeamModeEnabled();
  assertString(payload.vaultId, "vaultId", 8, 128);
  assertString(payload.invitee, "invitee", 25, 40);
  validateClassicAddress(payload.invitee);

  const vault = state.requireVault(payload.vaultId);
  if (vault.type !== "team") fail("Invites are supported only for team vaults.", "INVALID_VAULT_TYPE");
  const inviter = vault.owner;

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      invitee: payload.invitee,
      action: "inviteToVault"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: inviter
  });
  enforceRateLimit(inviter, roundKey);

  const invite = state.addPendingInvite({
    vaultId: payload.vaultId,
    invitedBy: inviter,
    address: payload.invitee,
    invitedAt: roundKey
  });
  persistState();
  auditLog("invite_sent", { vaultId: payload.vaultId, invitee: payload.invitee, invitedBy: inviter, success: true });

  return {
    success: true,
    pendingInviteCount: vault.pendingInvites.length,
    invitee: invite.address
  };
}

async function acceptInviteHandler(payload, roundKey) {
  ensureTeamModeEnabled();
  assertString(payload.vaultId, "vaultId", 8, 128);
  const signerAddress = deriveSignerAddress(payload.signerPublicKey);
  validateClassicAddress(signerAddress);

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      action: "acceptInvite"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: signerAddress
  });
  enforceRateLimit(signerAddress, roundKey);

  const vault = state.requireVault(payload.vaultId);
  if (vault.type !== "team") fail("Invites are supported only for team vaults.", "INVALID_VAULT_TYPE");

  const invite = state.acceptPendingInvite({
    vaultId: payload.vaultId,
    address: signerAddress
  });
  persistState();
  auditLog("invite_accepted", { vaultId: payload.vaultId, invitee: signerAddress, acceptedAt: roundKey, success: true });

  return {
    success: true,
    authorizedCount: vault.authorized.length,
    invitedBy: invite.invitedBy
  };
}

async function getPendingInvitesHandler(payload) {
  ensureTeamModeEnabled();
  assertString(payload.vaultId, "vaultId", 8, 128);
  const vault = state.requireVault(payload.vaultId);
  if (vault.type !== "team") fail("Pending invites are supported only for team vaults.", "INVALID_VAULT_TYPE");

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      action: "getPendingInvites"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: vault.owner
  });

  return {
    vaultId: payload.vaultId,
    pendingInvites: vault.pendingInvites.map((invite) => ({
      address: invite.address,
      invitedBy: invite.invitedBy,
      invitedAt: invite.invitedAt
    }))
  };
}

async function removeMemberHandler(payload, roundKey) {
  ensureTeamModeEnabled();
  assertString(payload.vaultId, "vaultId", 8, 128);
  assertString(payload.memberToRemove, "memberToRemove", 25, 40);
  validateClassicAddress(payload.memberToRemove);

  const vault = state.requireVault(payload.vaultId);
  if (vault.type !== "team") fail("Member removal is supported only for team vaults.", "INVALID_VAULT_TYPE");
  const owner = vault.owner;

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      memberToRemove: payload.memberToRemove,
      action: "removeMember"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: owner
  });
  enforceRateLimit(owner, roundKey);

  state.removeAuthorizedMember({
    vaultId: payload.vaultId,
    owner,
    memberToRemove: payload.memberToRemove
  });
  persistState();
  auditLog("member_removed", { vaultId: payload.vaultId, removed: payload.memberToRemove, by: owner, success: true });

  return {
    success: true,
    authorizedCount: vault.authorized.length
  };
}

async function revokeInviteHandler(payload, roundKey) {
  ensureTeamModeEnabled();
  assertString(payload.vaultId, "vaultId", 8, 128);
  assertString(payload.pendingAddress, "pendingAddress", 25, 40);
  validateClassicAddress(payload.pendingAddress);

  const vault = state.requireVault(payload.vaultId);
  if (vault.type !== "team") fail("Invites are supported only for team vaults.", "INVALID_VAULT_TYPE");
  const owner = vault.owner;

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      pendingAddress: payload.pendingAddress,
      action: "revokeInvite"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: owner
  });
  enforceRateLimit(owner, roundKey);

  state.revokePendingInvite({
    vaultId: payload.vaultId,
    owner,
    pendingAddress: payload.pendingAddress
  });
  persistState();
  auditLog("invite_revoked", { vaultId: payload.vaultId, pendingAddress: payload.pendingAddress, by: owner, success: true });

  return {
    success: true,
    pendingInviteCount: vault.pendingInvites.length
  };
}

async function updateVaultManifestHandler(payload, deps, roundKey) {
  ensureTeamModeEnabled();
  assertString(payload.vaultId, "vaultId", 8, 128);
  if (!payload.newUri && !payload.newBlobHex) {
    fail("Either newUri or newBlobHex is required.", "INVALID_INPUT");
  }
  if (payload.newUri !== undefined) {
    assertString(payload.newUri, "newUri", 8, 512);
  }
  if (payload.newBlobHex !== undefined) {
    assertString(payload.newBlobHex, "newBlobHex", 2, 4096);
    if (!/^[0-9a-fA-F]+$/.test(payload.newBlobHex)) {
      fail("newBlobHex must be a hex string.", "INVALID_INPUT");
    }
  }

  const vault = state.requireVault(payload.vaultId);
  if (vault.type !== "team") fail("Manifest updates are supported only for team vaults.", "INVALID_VAULT_TYPE");
  const owner = vault.owner;

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      newUri: payload.newUri ?? null,
      newBlobHex: payload.newBlobHex ?? null,
      action: "updateVaultManifest"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: owner
  });
  enforceRateLimit(owner, roundKey);

  // CLIENT RESPONSIBILITY: on membership change (invite accepted/member removed),
  // client must re-encrypt affected entry data, recompute wrappedKeys for active
  // members, upload updated blobs to IPFS, then update vault manifest policy URI.
  // FUTURE: when DynamicURITokens/URITokenModify is available and enabled,
  // submit URITokenModify with URITokenID=vault.manifestTokenId and URI/Blob.
  if (ENABLE_MUTABLE_URITOKENS) {
    persistState();
    auditLog("manifest_updated", { vaultId: payload.vaultId, by: owner, mode: "mutable_stub", success: true });
    return {
      success: true,
      mode: "mutable_stub",
      manifestTokenId: vault.manifestTokenId
    };
  }

  // Fallback (current network reality): burn + re-mint manifest token.
  // This can incur extra XRPL fees and produces a new token ID.
  const burned = await burnUriToken({
    xrplClient: deps.xrplClient,
    multisigSigners: deps.multisigSigners ?? [],
    issuer: deps.uriIssuer ?? DEFAULT_URI_ISSUER,
    uriTokenId: vault.manifestTokenId,
    devMode: ENABLE_XRPL_DEV_FALLBACK
  });
  const oldManifestTokenId = vault.manifestTokenId;
  const nextUri = payload.newUri ?? "ipfs://placeholder-for-now";
  const reminted = await mintUriToken({
    xrplClient: deps.xrplClient,
    multisigSigners: deps.multisigSigners ?? [],
    issuer: deps.uriIssuer ?? DEFAULT_URI_ISSUER,
    uri: nextUri,
    devMode: ENABLE_XRPL_DEV_FALLBACK
  });
  vault.manifestTokenId = reminted.tokenId;
  persistState();
  auditLog("manifest_rotated", {
    vaultId: payload.vaultId,
    by: owner,
    oldManifestTokenId,
    newManifestTokenId: reminted.tokenId,
    success: true
  });

  return {
    success: true,
    mode: "burn_remint",
    manifestTokenId: vault.manifestTokenId,
    burnMode: burned.mode,
    mintMode: reminted.mode
  };
}

async function listVaultURITokensHandler(payload) {
  assertString(payload.vaultId, "vaultId", 8, 128);
  const vault = state.requireVault(payload.vaultId);
  const owner = vault.owner;

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      action: "listVaultURITokens"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: owner
  });

  return {
    vaultId: payload.vaultId,
    tokenIds: state.listVaultURITokens({ vaultId: payload.vaultId, owner })
  };
}

async function revokeVaultHandler(payload, deps, roundKey) {
  assertString(payload.vaultId, "vaultId", 8, 128);
  const vault = state.requireVault(payload.vaultId);
  const owner = vault.owner;

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      confirm: payload.confirm === true,
      action: "revokeVault"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: owner
  });
  enforceRateLimit(owner, roundKey);

  if (vault.type === "team" && payload.confirm !== true) {
    fail("Team vault revocation requires confirm=true.", "CONFIRMATION_REQUIRED");
  }

  const tokenIds = state.listVaultURITokens({ vaultId: payload.vaultId, owner });
  let burnedTokens = 0;
  for (const tokenId of tokenIds) {
    await burnUriToken({
      xrplClient: deps.xrplClient,
      multisigSigners: deps.multisigSigners ?? [],
      issuer: deps.uriIssuer ?? DEFAULT_URI_ISSUER,
      uriTokenId: tokenId,
      devMode: ENABLE_XRPL_DEV_FALLBACK
    });
    burnedTokens += 1;
  }

  // CLIENT RESPONSIBILITY: after vault revocation, clear local cache and
  // unpin associated CIDs from QuickNode if storage reclamation is desired.
  const entryCount = vault.entries.length;
  state.deleteVault({ vaultId: payload.vaultId, owner });
  persistState();
  auditLog("vault_revoked", {
    vaultId: payload.vaultId,
    owner,
    type: vault.type,
    entryCount,
    burnedTokens,
    success: true
  });

  return {
    success: true,
    burnedTokens
  };
}

async function addEntryHandler(payload, deps, roundKey) {
  assertString(payload.vaultId, "vaultId", 8, 128);
  const actor = payload.actor ?? payload.owner;
  assertString(actor, "actor", 25, 40);
  validateClassicAddress(actor);
  assertBase64(payload.encryptedBlob, "encryptedBlob");
  if (typeof payload.cid !== "string") fail("cid must be a string.", "INVALID_INPUT");
  assertValidCid(payload.cid);
  assertObject(payload.entryMetadata, "entryMetadata");
  assertString(payload.entryMetadata.service, "entryMetadata.service", 1, 128);
  if (payload.entryMetadata.username !== undefined) {
    assertString(payload.entryMetadata.username, "entryMetadata.username", 1, 256);
  }
  if (payload.entryMetadata.notes !== undefined) {
    assertString(payload.entryMetadata.notes, "entryMetadata.notes", 1, 4096);
  }
  validateWrappedKeys(payload.wrappedKeys ?? []);

  const vault = state.requireVault(payload.vaultId);
  // CLIENT RESPONSIBILITY: when team membership changes, client must re-encrypt
  // and re-upload entry blobs as needed for the new authorized set.
  // CLIENT RESPONSIBILITY: client computes wrappedKeys using recipients' Xahau
  // public keys; contract only stores ciphertext references.

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      actor,
      encryptedBlob: payload.encryptedBlob,
      cid: payload.cid,
      entryMetadata: payload.entryMetadata,
      wrappedKeys: payload.wrappedKeys ?? []
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: actor
  });
  enforceRateLimit(actor, roundKey);

  const entryMint = await mintUriToken({
    xrplClient: deps.xrplClient,
    multisigSigners: deps.multisigSigners ?? [],
    issuer: deps.uriIssuer ?? DEFAULT_URI_ISSUER,
    uri: `ipfs://${payload.cid}`,
    owner: vault.owner,
    devMode: ENABLE_XRPL_DEV_FALLBACK
  });
  // FUTURE: TEAM MODE - entry-level wrapped key references can be attached
  // in metadata as client-produced wrappedKeys arrays.

  const entry = state.addEntry({
    vaultId: payload.vaultId,
    actor,
    cid: payload.cid,
    entryMetadata: payload.entryMetadata,
    wrappedKeys: payload.wrappedKeys ?? [],
    createdAt: roundKey,
    tokenId: entryMint.tokenId
  });
  persistState();
  auditLog("addEntry", { owner: actor, vaultId: payload.vaultId, success: true });

  return {
    vaultId: payload.vaultId,
    tokenId: entry.tokenId,
    cid: entry.cid,
    createdAt: entry.createdAt,
    metadata: entry.metadata,
    mintMode: entryMint.mode
  };
}

function getEntryHandler(payload) {
  assertString(payload.vaultId, "vaultId", 8, 128);
  const hasIndex = payload.entryIndex !== undefined && payload.entryIndex !== null;
  const hasTokenId = typeof payload.tokenId === "string" && payload.tokenId.length > 0;
  if (!hasIndex && !hasTokenId) {
    fail("Either entryIndex or tokenId is required.", "INVALID_INPUT");
  }
  if (hasIndex && !Number.isInteger(payload.entryIndex)) {
    fail("entryIndex must be an integer.", "INVALID_INPUT");
  }
  const actor = payload.actor ?? payload.owner;
  assertString(actor, "actor", 25, 40);
  validateClassicAddress(actor);

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      actor,
      entryIndex: hasIndex ? payload.entryIndex : null,
      tokenId: hasTokenId ? payload.tokenId : null
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: actor
  });

  const entry = state.getEntry({
    vaultId: payload.vaultId,
    actor,
    entryIndex: hasIndex ? payload.entryIndex : undefined,
    tokenId: hasTokenId ? payload.tokenId : undefined
  });
  auditLog("getEntry", {
    owner: actor,
    vaultId: payload.vaultId,
    by: hasIndex ? "index" : "tokenId",
    success: true
  });

  return {
    cid: entry.cid,
    metadata: entry.metadata,
    gatewayUrl: buildGatewayFetchUrl(QUICKNODE_GATEWAY, entry.cid)
  };
}

function getMyVaultsHandler(payload) {
  assertString(payload.owner, "owner", 25, 40);
  validateClassicAddress(payload.owner);
  const since = payload.since === undefined || payload.since === null ? null : String(payload.since);
  if (since !== null) assertString(since, "since", 1, 64);
  return state.getMyVaults(payload.owner, since);
}

async function addPasswordBackupHandler(payload, roundKey) {
  assertString(payload.vaultId, "vaultId", 8, 128);
  assertObject(payload.passwordBackup, "passwordBackup");
  assertString(payload.actor, "actor", 25, 40);
  validateClassicAddress(payload.actor);
  validatePasswordBackupEnvelope(payload.passwordBackup, payload.vaultId);

  const vault = state.requireVault(payload.vaultId);
  const owner = vault.owner;
  if (payload.actor !== owner) fail("Only vault owner can set password backup.", "UNAUTHORIZED");

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      actor: payload.actor,
      action: "addPasswordBackup",
      passwordBackup: payload.passwordBackup
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: owner
  });
  enforceRateLimit(owner, roundKey);

  state.setPasswordBackup({
    vaultId: payload.vaultId,
    owner,
    passwordBackup: payload.passwordBackup,
    updatedAt: roundKey
  });
  persistState();
  auditLog("password_backup_added", { vaultId: payload.vaultId, owner, success: true });

  return {
    success: true
  };
}

async function removePasswordBackupHandler(payload, roundKey) {
  assertString(payload.vaultId, "vaultId", 8, 128);
  assertString(payload.actor, "actor", 25, 40);
  validateClassicAddress(payload.actor);

  const vault = state.requireVault(payload.vaultId);
  const owner = vault.owner;
  if (payload.actor !== owner) fail("Only vault owner can remove password backup.", "UNAUTHORIZED");

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      actor: payload.actor,
      action: "removePasswordBackup"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: owner
  });
  enforceRateLimit(owner, roundKey);

  state.clearPasswordBackup({ vaultId: payload.vaultId, owner, updatedAt: roundKey });
  persistState();
  auditLog("password_backup_removed", { vaultId: payload.vaultId, owner, success: true });

  return {
    success: true
  };
}

function getVaultMetadataHandler(payload) {
  assertString(payload.vaultId, "vaultId", 8, 128);
  assertString(payload.actor, "actor", 25, 40);
  validateClassicAddress(payload.actor);

  const vault = state.requireVault(payload.vaultId);
  const owner = vault.owner;
  if (payload.actor !== owner) fail("Only vault owner can read metadata.", "UNAUTHORIZED");

  verifySignedPayload({
    payload: {
      vaultId: payload.vaultId,
      actor: payload.actor,
      action: "getVaultMetadata"
    },
    signature: payload.signature,
    signerPublicKey: payload.signerPublicKey,
    expectedAddress: owner
  });

  return {
    vaultId: payload.vaultId,
    metadata: vault.metadata ?? {}
  };
}

function ensureTeamModeEnabled() {
  if (!ENABLE_TEAM_MODE) {
    fail("Team vaults are not enabled in this deployment.", "TEAM_MODE_DISABLED");
  }
}

function normalizeVaultMetadata(metadata, vaultId, roundKey) {
  const normalized = { ...(metadata ?? {}) };
  if (normalized.vaultId && normalized.vaultId !== vaultId) {
    fail("metadata.vaultId does not match computed vaultId.", "INVALID_METADATA");
  }
  normalized.vaultId = vaultId;
  if (normalized.blobVersion === undefined) normalized.blobVersion = 1;
  normalized.lastUpdated = roundKey;
  return normalized;
}

function persistState() {
  saveStateToFs(contract_DEFAULT_STATE_FILE, state.snapshot());
}

function resolveRoundKey(runtimeContext, op) {
  if (runtimeContext.roundKey) return `${runtimeContext.roundKey}`;
  if (runtimeContext.lclSeqNo !== undefined) return `${runtimeContext.lclSeqNo}`;
  if (op.round !== undefined) return `${op.round}`;
  if (op.roundKey !== undefined) return `${op.roundKey}`;
  return "round-unknown";
}

function enforceRateLimit(owner, roundKey) {
  if (!owner) fail("owner is required for mutating operations.", "INVALID_INPUT");
  if (limiter.roundKey !== roundKey) {
    limiter = { roundKey, perAddress: new Map() };
  }
  const count = limiter.perAddress.get(owner) ?? 0;
  if (count >= OPS_PER_ROUND_LIMIT) {
    fail("Rate limit exceeded: max 5 mutating operations per round.", "RATE_LIMIT_EXCEEDED");
  }
  limiter.perAddress.set(owner, count + 1);
}

function auditLog(event, fields) {
  console.info(
    JSON.stringify({
      at: new Date().toISOString(),
      event,
      ...fields
    })
  );
}

async function runContract({ requests, respond, runtimeContext = {}, deps = {} }) {
  for await (const req of requests) {
    try {
      const result = await handleOperation(req, deps, runtimeContext);
      await respond(result);
    } catch (error) {
      const safeError = error instanceof ContractError ? error : new ContractError(error.message, "UNEXPECTED_ERROR");
      auditLog("request_error", {
        type: req?.type ?? "unknown",
        success: false,
        code: safeError.code,
        message: safeError.message
      });
      const errorId = external_node_crypto_.createHash("sha256").update(`${safeError.code}:${safeError.message}`).digest("hex").slice(0, 12);
      await respond({ ...toErrorResponse(safeError), errorId });
    }
  }
}

function success(operation, data) {
  return { ok: true, operation, data };
}

function assertString(value, fieldName, minLen = 1, maxLen = 512) {
  if (typeof value !== "string") fail(`${fieldName} must be a string.`, "INVALID_INPUT");
  const trimmed = value.trim();
  if (trimmed.length < minLen || trimmed.length > maxLen) {
    fail(`${fieldName} length must be between ${minLen} and ${maxLen}.`, "INVALID_INPUT");
  }
}

function assertObject(value, fieldName) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    fail(`${fieldName} must be an object.`, "INVALID_INPUT");
  }
}

function validateAddressArray(values, fieldName) {
  if (!Array.isArray(values)) fail(`${fieldName} must be an array.`, "INVALID_INPUT");
  if (values.length > 50) fail(`${fieldName} exceeds maximum size.`, "INVALID_INPUT");
  for (const address of values) {
    assertString(address, `${fieldName}[]`, 25, 40);
    validateClassicAddress(address);
  }
}

function validateWrappedKeys(wrappedKeys) {
  if (!Array.isArray(wrappedKeys)) fail("wrappedKeys must be an array.", "INVALID_INPUT");
  if (wrappedKeys.length > 200) fail("wrappedKeys exceeds maximum size.", "INVALID_INPUT");
  for (const item of wrappedKeys) {
    assertObject(item, "wrappedKeys[]");
    assertString(item.address, "wrappedKeys[].address", 25, 40);
    validateClassicAddress(item.address);
    assertBase64(item.encryptedKey, "wrappedKeys[].encryptedKey");
  }
}

function validatePasswordBackupEnvelope(passwordBackup, vaultId) {
  assertObject(passwordBackup, "passwordBackup");
  if (!Number.isInteger(passwordBackup.version) || passwordBackup.version !== 1) {
    fail("passwordBackup.version must be 1.", "INVALID_INPUT");
  }
  assertString(passwordBackup.vaultId, "passwordBackup.vaultId", 8, 128);
  if (passwordBackup.vaultId !== vaultId) {
    fail("passwordBackup.vaultId mismatch.", "INVALID_INPUT");
  }
  assertBase64(passwordBackup.salt, "passwordBackup.salt");
  assertBase64(passwordBackup.nonce, "passwordBackup.nonce");
  assertBase64(passwordBackup.authTag, "passwordBackup.authTag");
  assertBase64(passwordBackup.ciphertext, "passwordBackup.ciphertext");
}

async function bootstrapHotPocketRuntime() {
  // Gate bootstrap to real HotPocket runtime only; avoids side effects in tests/tools.
  if (process.stdin.isTTY) return;
  if (!external_node_fs_namespaceObject.existsSync("../patch.cfg")) return;

  const hpargs = await readContractArgs();

  const queue = await collectUserRequests(hpargs);
  let cursor = 0;
  await runContract({
    requests: (async function* iter() {
      for (const item of queue) {
        if (item.request && typeof item.request === "object") {
          yield item.request;
        }
      }
    })(),
    respond: async (payload) => {
      const target = queue[cursor];
      cursor += 1;
      if (!target) return;
      await sendUserOutput(target.outFd, payload);
    },
    runtimeContext: {
      lclSeqNo: hpargs?.lcl_seq_no,
      lclHash: hpargs?.lcl_hash,
      roundKey: hpargs?.lcl_seq_no
    },
    deps: {}
  });
}

bootstrapHotPocketRuntime().catch((error) => {
  auditLog("bootstrap_error", { success: false, message: error?.message ?? String(error) });
});

async function readContractArgs() {
  const argsJson = await new Promise((resolve, reject) => {
    external_node_fs_namespaceObject.readFile(process.stdin.fd, "utf8", (error, data) => {
      if (error) reject(error);
      else resolve(data);
    });
  });
  return JSON.parse(argsJson);
}

async function collectUserRequests(hpargs) {
  const queue = [];
  const users = hpargs?.users && typeof hpargs.users === "object" ? hpargs.users : {};
  const inputFd = hpargs?.user_in_fd;
  for (const [publicKey, records] of Object.entries(users)) {
    if (!Array.isArray(records) || records.length < 1) continue;
    const outFd = records[0];
    for (const input of records.slice(1)) {
      if (!Array.isArray(input) || input.length < 2) continue;
      const [offset, size] = input;
      const raw = await readInputChunk(inputFd, offset, size);
      let request = null;
      try {
        request = JSON.parse(raw.toString("utf8"));
      } catch {
        request = null;
      }
      queue.push({ publicKey, outFd, request });
    }
  }

  return queue;
}

async function readInputChunk(fd, offset, size) {
  const buffer = Buffer.alloc(size);
  await new Promise((resolve, reject) => {
    external_node_fs_namespaceObject.read(fd, buffer, 0, size, offset, (error) => {
      if (error) reject(error);
      else resolve();
    });
  });
  return buffer;
}

async function sendUserOutput(outFd, payload) {
  const message = Buffer.from(JSON.stringify(payload));
  const header = Buffer.alloc(4);
  header.writeUInt32BE(message.byteLength);
  await new Promise((resolve, reject) => {
    external_node_fs_namespaceObject.writev(outFd, [header, message], (error) => {
      if (error) reject(error);
      else resolve();
    });
  });
}


})();

var __webpack_exports__handleOperation = __webpack_exports__.W;
var __webpack_exports__runContract = __webpack_exports__.d;
export { __webpack_exports__handleOperation as handleOperation, __webpack_exports__runContract as runContract };
